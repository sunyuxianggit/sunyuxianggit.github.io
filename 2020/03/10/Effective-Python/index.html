<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Effective Python"><meta name="keywords" content="python"><meta name="author" content="Sun Yuxiang"><meta name="copyright" content="Sun Yuxiang"><title>Effective Python | SunYuxiangのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="SunYuxiangのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一条"><span class="toc-number">1.</span> <span class="toc-text">第一条</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Windows平台下："><span class="toc-number">1.0.1.</span> <span class="toc-text">Windows平台下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#其他程序内："><span class="toc-number">1.0.2.</span> <span class="toc-text">其他程序内：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二条"><span class="toc-number">2.</span> <span class="toc-text">第二条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三条"><span class="toc-number">3.</span> <span class="toc-text">第三条</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#了解bytes、str、和unicode的区别"><span class="toc-number">3.0.1.</span> <span class="toc-text">了解bytes、str、和unicode的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串的转换"><span class="toc-number">3.0.2.</span> <span class="toc-text">字符串的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#推荐的文件操作符"><span class="toc-number">3.0.3.</span> <span class="toc-text">推荐的文件操作符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第四条"><span class="toc-number">4.</span> <span class="toc-text">第四条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第五条"><span class="toc-number">5.</span> <span class="toc-text">第五条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第六条"><span class="toc-number">6.</span> <span class="toc-text">第六条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第七条"><span class="toc-number">7.</span> <span class="toc-text">第七条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第八条"><span class="toc-number">8.</span> <span class="toc-text">第八条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第九条"><span class="toc-number">9.</span> <span class="toc-text">第九条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十条"><span class="toc-number">10.</span> <span class="toc-text">第十条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十一条"><span class="toc-number">11.</span> <span class="toc-text">第十一条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要在for和while循环后面写else语块"><span class="toc-number">12.</span> <span class="toc-text">不要在for和while循环后面写else语块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用"><span class="toc-number">13.</span> <span class="toc-text">引用</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Sun Yuxiang</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/sunyuxianggit" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SunYuxiangのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">文章</a><a class="site-page" href="/archives">归档</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Effective Python</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>编写高质量代码的59+91个建议读书笔记</p>
<h3 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h3><ul>
<li>确认自己所用的python版本。</li>
<li>确保该版本与你想使用的python版本相符。</li>
<li>优先使用python3</li>
</ul>
<h5 id="Windows平台下："><a href="#Windows平台下：" class="headerlink" title="Windows平台下："></a>Windows平台下：</h5><p><code>$python --version</code><br><img src="/2020/03/10/Effective-Python/2020-03-07-11-15-23.png" alt="a"></p>
<a id="more"></a>

<h5 id="其他程序内："><a href="#其他程序内：" class="headerlink" title="其他程序内："></a>其他程序内：</h5><ul>
<li><p>Autodesk Maya:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-18-24.png" alt="b"></p>
</li>
<li><p>Substance Designer:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-19-36.png" alt="c"><br>注：SD里sys.version_info报错，原因未知</p>
</li>
<li><p>Houdini：<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-22-33.png" alt="d"></p>
</li>
</ul>
<p>Tips： Python中sys模块还有一个常用功能：<br><code>sys.path</code>可以用来找到应用程序内的python编译器位置.</p>
<h3 id="第二条"><a href="#第二条" class="headerlink" title="第二条"></a>第二条</h3><p>遵循PEP8 风格指南<br>《Python Enhancement Proposal #8》（8号Python增强法案）又叫PEP8,它是针对Python代码格式而编订的风格指南。</p>
<ul>
<li>使用空格来表示缩进，而不要用制表符（tab）。</li>
<li>和语法相关的每一层缩进都用四个空格表示。</li>
<li>每行的字符数不应超过79。</li>
<li>对于占据多行的长表达式，除了首行之外的其余各行都应该在通常的缩进级别之上再加四个空格。</li>
<li>文件中的代码与函数和类之间应该用两个空行隔开。</li>
<li>在同一个类中，各方法之间应该用一个空行隔开。</li>
<li>在使用下标来获取列表元素、调用函数或给关键字参数赋值的时候，不要再两边添加空格。</li>
<li>为变量赋值的时候，赋值符号的左侧和右侧应该各自写上一个空格，而且只写一个。</li>
</ul>
<p>命名：PEP8 提倡采用不同的命名风格来编写Python代码中的各个部分,以便再阅读代码时可以根据这些名称看出它们的角色。</p>
<ul>
<li>函数、变量名及属性应该用小写字母，各单词之间用下划线相连，例如，lowercase_underscore。</li>
<li>受保护的实例属性，应该以单个下划线开头，例如，_leading_underscore.</li>
<li>私有的实例属性，应该以两个下划线开头，例如__double_leading_underscore.</li>
<li>类与异常， 应该以每个单词首字母均大写的形式来命名，例如，CapitalizedWord。</li>
<li>模块级别的常量，应该全部采用大写字母来拼写，各单词之间以下划线连接，例如，ALL_CAPS。</li>
<li>类中的实例方法（instance method），应该把首个参数命名self，以表示该对象自身.</li>
<li>类方法（class method）的首个参数，应该命名cls，以表示该类自身。</li>
</ul>
<p>表达式和语句《The Zen of Python》（python之禅）中说，每件事都应该有直白的做法，而且最好只有一种。</p>
<ul>
<li>采用内联形式的否定词 ，而不要把否定词放在整个表达式的前面，例如，应该写 if a is not b 而不是 if not a is b。</li>
<li>不要通过检测长度的方法来判断列表是否为空，而是应该采用if not somelist来判定。</li>
<li>同上条，如果判断列表不为空也是一样的， </li>
<li>不要编写单行的if语句、for循环、while循环及except复合语句，而是应该把这些语句分成多行来书写，以示清晰。</li>
<li>import语句应该重视放在文件开头.</li>
<li>引入模块的时候，总是应该使用绝对名称，而不应该根据当前模块的路径来使用相对名称，例如，引入bar包中的foo模块时，应该完成的写出 from bar import foo，而不应该简写为import foo。</li>
<li>如果一定要以相对的名称来编写import语句，那就采用明确的写法:from.import foo。</li>
<li>文件中的那些import语句应该按照顺序划分为三个部分，分别为标准库模块、第三方模块以及自用模块。各import语句应该按照模块的字母顺序来排列。</li>
</ul>
<p>Tips： vscode可以采用pylint来自动检测受测代码是否符合pep8。<br><a href="https://www.pylint.org/" target="_blank" rel="noopener">https://www.pylint.org/</a></p>
<h3 id="第三条"><a href="#第三条" class="headerlink" title="第三条"></a>第三条</h3><h5 id="了解bytes、str、和unicode的区别"><a href="#了解bytes、str、和unicode的区别" class="headerlink" title="了解bytes、str、和unicode的区别"></a>了解bytes、str、和unicode的区别</h5><ul>
<li>python3有两种表示字符序列的类型，bytes和str，前者的实例中包含原始的8位值，后者的实例中包含Unicode字符。</li>
<li>python2中也有两种表示字符序列的类型，str和Unicode. 前者包含原始的八位值，后者的实例着包含unicode字符。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-29-10.png" alt="e"></li>
<li>bytes 类型，是指一堆字节的集合，十六进制表现形式，两个十六进制数构成一个 byte ，以 b 开头的字符串是 bytes 类型。计算机只能存储二进制，字符、图片、视频、音乐等想存到硬盘上，必须以正确的方式编码成二进制后再存，但是转成二进制后不是直接以 0101010 的形式表示的，而是用bytes() 的类型来表示的。</li>
<li>把Unicode字符表示为二进制数据（原始八位值）有很多办法，常见且推荐的编码方式就是UTF-8。</li>
<li>但是python3 的str实例和python2的Unicode实例都没有和特定的二进制编码形式相关联，想要把Unicode字符转换为二进制数据，就必须使用encode方法，想要把二进制数据转化成为Unicode字符，则必须使用decode 方法。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-34-59.png" alt="f"></li>
<li>在 Python3 中内存里的字符串是以 Unicode 编码的，Unicode 的其中一个特性就是跟所有语言编码都有映射关系，所以 UTF-8 格式的文件，在 Windows 电脑上若是不能看，就可以把 UTF-8 先解码成 Unicode ，再由 Unicode 编码成 GBK 就可以了。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-32-20.png" alt="g"><h5 id="字符串的转换"><a href="#字符串的转换" class="headerlink" title="字符串的转换"></a>字符串的转换</h5></li>
<li>在Python3中，接受str或byts，并总是返回str的方法:  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, bytes):<span class="comment">#注意这个函数</span></span><br><span class="line">        value = bytes_or_str.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li>
<li>接受str或bytes，并总是返回bytes的方法：  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li>
<li>在Python2中，接受str或unicode，并总是返回unicode的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_unicode(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, str):</span><br><span class="line">        value &#x3D; unicode_or_str.decode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure></li>
<li>接受str或unicode，并总是返回str的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_str(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, unicode):</span><br><span class="line">        value &#x3D; unicode_or_str.encode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure>
<h5 id="推荐的文件操作符"><a href="#推荐的文件操作符" class="headerlink" title="推荐的文件操作符"></a>推荐的文件操作符</h5>如果通过open函数获取文件句柄，该句柄会采用UTF-8编码格式来操作文件。<br>而在Python2中，文件操作的默认编码格式则是二进制形式。这可能会导致程序出现奇怪的错误。<br>例如，向文件中随机写入一些二进制数据。下面这种方法Python2中可以正常运行，但是在Python3中则不行：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TypeError: must be str, <span class="keyword">not</span> bytes</span><br></pre></td></tr></table></figure>
上述情况是因为Python3给open函数添加了名为encoding的新参数，而这个新参数默认值是’utf-8′。这样在文件句柄上进行read和write操作时，系统就要求开发者必须传入包含unicode字符的str实例，而不接受包含二进制数据的bytes实例。</li>
</ul>
<p>解决这个问题，可以用二进制写入模式(‘wb’)来开启待操作的文件，按照这种方式可同时适配Python2和Python3：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>(读取文件也同理，可使用’rb’模式)</p>
<h3 id="第四条"><a href="#第四条" class="headerlink" title="第四条"></a>第四条</h3><p>用辅助函数来取代复杂的表达式</p>
<ul>
<li>开发者很容易过度运用Python的语法特性，从而写出那种特别复杂并且难以理解的单行表达式。</li>
<li>请把复杂的表达式移入辅助函数中。如果要反复使用相同的逻辑，那就更应该那么做。</li>
<li>使用if/esle表达式，要比用or或者and 这样的Boolean操作符写出的表达式更清晰。</li>
</ul>
<h3 id="第五条"><a href="#第五条" class="headerlink" title="第五条"></a>第五条</h3><p>了解切割序列的方法<br>python提供了一种把序列切成小块的写法，这种切片操作很容易四开发者轻易的访问序列中的某些元素所构成的子集。<br>最简单的用法，就是对内置list和bytes进行切割。<br>切割操作还可以延伸到实现了<strong>getitem</strong>和<strong>setitem</strong>这两个特殊方法的python类上，参见28条。</p>
<ul>
<li>不要写多余的代码。但start索引为零或者end索引为序列长度时，应该将其忽略</li>
<li>切片操作不会计较start或者end索引是否越界，这样我们很容易从前端或者后端开始。</li>
<li>对list赋值时，如果使用切片操作，就会把原列表中处在相关范围内的值替换成新值，即便它们的长度不同也依然可以替换。</li>
</ul>
<h3 id="第六条"><a href="#第六条" class="headerlink" title="第六条"></a>第六条</h3><p>在单词切片操作内，不要同时指定start、 end 和 stride </p>
<ul>
<li>问题在于采用stride方式进行切片时，经常会出现不符合预期的结果</li>
<li>切割列表时，如果制定了stride，代码就会变得费解。尤其是stride为负值的时候更是如此.</li>
<li>在同一个切片操作内，不要同时使用start、end和stride. 如果确实需要执行这种操作，那就考虑将其拆解为两条赋值语句，其中一条做范围切割，另一条做步进，或者考虑使用内置itertools模块中的islice.</li>
</ul>
<p>tips：<br><code>mystring[::-1]#反转字符串</code></p>
<h3 id="第七条"><a href="#第七条" class="headerlink" title="第七条"></a>第七条</h3><p>用列表推导来取代map和filter<br>python提供了一种精炼的写法，可以根据一个列表来制作另外一个列表.这种表达式称为list comprehension （列表推导）</p>
<ul>
<li>列表推导要比内置的map和filter函数清晰</li>
<li>列表推导可以很跳过输入列表中的某些元素</li>
<li>字典与集也支持推导表达式</li>
</ul>
<h3 id="第八条"><a href="#第八条" class="headerlink" title="第八条"></a>第八条</h3><p>不要使用含有两个以上表达式的列表推导</p>
<ul>
<li>列表推导支持多级循环，每一级循环也支持多项条件</li>
<li>超过两个表达式的列表推导难以理解，应该尽量避免<br>Tips：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br><span class="line">print(flat)</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="comment">#下面两种写法是等效的</span></span><br><span class="line"><span class="comment">#要从列表中取出大于4的偶数</span></span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">if</span> x %<span class="number">2</span> ==<span class="number">0</span>]</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">and</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="第九条"><a href="#第九条" class="headerlink" title="第九条"></a>第九条</h3><p>用生成器表达式来改写数据量较大的列表推导<br>列表推导的缺点是，对于输入序列中的每个值来说，都要创建一项仅含一项元素的全新列表，但输入数据较大时，可能会消耗大量内存，并导致程序崩溃。<br>为了解决此问题，python 提供了生成式表达式</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt))</span><br><span class="line">print(it)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x101b81480</span>&gt;</span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">57</span></span><br></pre></td></tr></table></figure>

<p>Tips：<br>获取文件每行的字符数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt)]</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure>

<ul>
<li>当输入的数据量较大时，列表推导可能会因为占用太对内存而出问题。</li>
<li>由生成表达式所返回的迭代器，可以逐次产生输出值，从而避免了内存用量问题。</li>
<li>把某个生成器表达式说返回的迭代器，放在另一个生成器表达式的for子表达式中，即可将二者组合起来。</li>
<li>串在一起的生成器表达式执行速度很快。 </li>
</ul>
<h3 id="第十条"><a href="#第十条" class="headerlink" title="第十条"></a>第十条</h3><p>尽量用enumerate取代range<br>在一些列的整数上面迭代，内置的range函数很有用，<br>当迭代列表的时候，通常还想知道当前元素在列表中的索引。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(flavor_list)):</span><br><span class="line">    flavor = flavor_lsit[i]</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure>
<p>这种代码不利于理解，python提供了enumerate来解决此问题。enumerate可以把各种迭代器包装为生成器，以便稍后产生输出值，生成器每次产生一对输出值，前者为循环下标，后者表示从迭代器中获取到的下一个序列元素，这样写出来的代码会非常整洁。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure>

<ul>
<li>enumerate函数提供了一种精简的写法，可以在遍历迭代器时获知每个元素的索引</li>
<li>尽量用enumerate来改写那种将range与下标访问相结合的序列遍历代码</li>
<li>可以给enumerate 提供第二个参数，已指定开始计数时所用的值（默认为0）</li>
</ul>
<p>Tips:<br>还可以直接指定enumerate开始计数所用的值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list，<span class="number">1</span>):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i,flavor))</span><br></pre></td></tr></table></figure>

<h3 id="第十一条"><a href="#第十一条" class="headerlink" title="第十一条"></a>第十一条</h3><p>用zip函数同时遍历两个迭代器</p>
<ul>
<li><p>使用for循环</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Cecilia</span><br></pre></td></tr></table></figure>
<p>上面这段代码问题在一，整个循环语句看上去很乱，用下标来访问names和letters会使代码不易阅读。<br>改用enumerate可以稍稍缓解这个问题，但仍然不够理想。</p>
</li>
<li><p>使用for循环加enumerate</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names)：</span><br><span class="line">    count =letters[i]</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure></li>
<li><p>使用zip</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letter):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置的zip函数可以平行的遍历多个迭代器</p>
</li>
<li><p>Python3中的zip相当于生成器，会在遍历过程中逐次产生元组，而Python2中的zip则是直接把这些元组完全生成号，并一次性的返回给整份列表。</p>
</li>
<li><p>如果提供的迭代器长度不等，那么zip就会自动提前终止。</p>
</li>
<li><p>itertools 内置模块中的zip_longest函数可以平行的遍历多个迭代器，而不用在乎它们的长度是否相等。</p>
</li>
</ul>
<h3 id="不要在for和while循环后面写else语块"><a href="#不要在for和while循环后面写else语块" class="headerlink" title="不要在for和while循环后面写else语块"></a>不要在for和while循环后面写else语块</h3><ul>
<li>python 有种特殊语法，可在 for及 while 循环的内部语句块之后紧跟一个else块。</li>
<li>只有当整个循环主体都没遇到break语句时，循环后面的else块才会执行。</li>
<li>不要再循环后面使用else块，因为在这种写法即不直观，又容易引人误解。</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/lipandeng/p/11162039.html" target="_blank" rel="noopener">https://www.cnblogs.com/lipandeng/p/11162039.html</a><br><a href="https://lingyunfx.com/?page_id=152" target="_blank" rel="noopener">https://lingyunfx.com/?page_id=152</a></p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/10/Blender%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="fa fa-chevron-left">  </i><span>Blender脚本学习笔记</span></a></div><div class="next-post pull-right"><a href="/2020/03/10/GameCourse101/"><span>GameCourse101</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Sun Yuxiang</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://sunyuxianggit.github.io/" target="_blank" rel="noopener">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SunYuxiangのBlog</title>
  
  <subtitle>好记性,不如烂笔头.今天你要写点什么？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-10T11:51:20.084Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sun Yuxiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective Python</title>
    <link href="http://yoursite.com/2020/03/10/Effective-Python/"/>
    <id>http://yoursite.com/2020/03/10/Effective-Python/</id>
    <published>2020-03-10T11:14:04.000Z</published>
    <updated>2020-03-10T11:51:20.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-Python"><a href="#Effective-Python" class="headerlink" title="Effective Python"></a>Effective Python</h1><h1 id="编写高质量代码的59-91个建议读书笔记"><a href="#编写高质量代码的59-91个建议读书笔记" class="headerlink" title="编写高质量代码的59+91个建议读书笔记"></a>编写高质量代码的59+91个建议读书笔记</h1><h3 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h3><ul><li>确认自己所用的python版本。</li><li>确保该版本与你想使用的python版本相符。</li><li>优先使用python3</li></ul><h5 id="Windows下："><a href="#Windows下：" class="headerlink" title="Windows下："></a>Windows下：</h5><p><code>$python --version</code><br><img src="/2020/03/10/Effective-Python/2020-03-07-11-15-23.png" alt="a"></p><h5 id="其他程序内："><a href="#其他程序内：" class="headerlink" title="其他程序内："></a>其他程序内：</h5><ul><li><p>Autodesk Maya:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-18-24.png" alt="b"></p></li><li><p>Substance Designer:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-19-36.png" alt="c"><br>注：SD里sys.version_info报错，原因未知</p></li><li><p>Houdini：<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-22-33.png" alt="d"></p></li></ul><p>Tips： Python中sys模块还有一个常用功能：<br><code>sys.path</code>可以用来找到应用程序内的python编译器位置.</p><h3 id="第二条"><a href="#第二条" class="headerlink" title="第二条"></a>第二条</h3><p>遵循PEP8 风格指南<br>《Python Enhancement Proposal #8》（8号Python增强法案）又叫PEP8,它是针对Python代码格式而编订的风格指南。</p><ul><li>使用空格来表示缩进，而不要用制表符（tab）。</li><li>和语法相关的每一层缩进都用四个空格表示。</li><li>每行的字符数不应超过79。</li><li>对于占据多行的长表达式，除了首行之外的其余各行都应该在通常的缩进级别之上再加四个空格。</li><li>文件中的代码与函数和类之间应该用两个空行隔开。</li><li>在同一个类中，各方法之间应该用一个空行隔开。</li><li>在使用下标来获取列表元素、调用函数或给关键字参数赋值的时候，不要再两边添加空格。</li><li>为变量赋值的时候，赋值符号的左侧和右侧应该各自写上一个空格，而且只写一个。</li></ul><p>命名：PEP8 提倡采用不同的命名风格来编写Python代码中的各个部分,以便再阅读代码时可以根据这些名称看出它们的角色。</p><ul><li>函数、变量名及属性应该用小写字母，各单词之间用下划线相连，例如，lowercase_underscore。</li><li>受保护的实例属性，应该以单个下划线开头，例如，_leading_underscore.</li><li>私有的实例属性，应该以两个下划线开头，例如__double_leading_underscore.</li><li>类与异常， 应该以每个单词首字母均大写的形式来命名，例如，CapitalizedWord。</li><li>模块级别的常量，应该全部采用大写字母来拼写，各单词之间以下划线连接，例如，ALL_CAPS。</li><li>类中的实例方法（instance method），应该把首个参数命名self，以表示该对象自身.</li><li>类方法（class method）的首个参数，应该命名cls，以表示该类自身。</li></ul><p>表达式和语句《The Zen of Python》（python之禅）中说，每件事都应该有直白的做法，而且最好只有一种。</p><ul><li>采用内联形式的否定词 ，而不要把否定词放在整个表达式的前面，例如，应该写 if a is not b 而不是 if not a is b。</li><li>不要通过检测长度的方法来判断列表是否为空，而是应该采用if not somelist来判定。</li><li>同上条，如果判断列表不为空也是一样的， </li><li>不要编写单行的if语句、for循环、while循环及except复合语句，而是应该把这些语句分成多行来书写，以示清晰。</li><li>import语句应该重视放在文件开头.</li><li>引入模块的时候，总是应该使用绝对名称，而不应该根据当前模块的路径来使用相对名称，例如，引入bar包中的foo模块时，应该完成的写出 from bar import foo，而不应该简写为import foo。</li><li>如果一定要以相对的名称来编写import语句，那就采用明确的写法:from.import foo。</li><li>文件中的那些import语句应该按照顺序划分为三个部分，分别为标准库模块、第三方模块以及自用模块。各import语句应该按照模块的字母顺序来排列。</li></ul><p>Tips： vscode可以采用pylint来自动检测受测代码是否符合pep8。<br><a href="https://www.pylint.org/" target="_blank" rel="noopener">https://www.pylint.org/</a></p><h3 id="第三条"><a href="#第三条" class="headerlink" title="第三条"></a>第三条</h3><h5 id="了解bytes、str、和unicode的区别"><a href="#了解bytes、str、和unicode的区别" class="headerlink" title="了解bytes、str、和unicode的区别"></a>了解bytes、str、和unicode的区别</h5><ul><li>python3有两种表示字符序列的类型，bytes和str，前者的实例中包含原始的8位值，后者的实例中包含Unicode字符。</li><li>python2中也有两种表示字符序列的类型，str和Unicode. 前者包含原始的八位值，后者的实例着包含unicode字符。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-29-10.png" alt="e"></li><li>bytes 类型，是指一堆字节的集合，十六进制表现形式，两个十六进制数构成一个 byte ，以 b 开头的字符串是 bytes 类型。计算机只能存储二进制，字符、图片、视频、音乐等想存到硬盘上，必须以正确的方式编码成二进制后再存，但是转成二进制后不是直接以 0101010 的形式表示的，而是用bytes() 的类型来表示的。</li><li>把Unicode字符表示为二进制数据（原始八位值）有很多办法，常见且推荐的编码方式就是UTF-8。</li><li>但是python3 的str实例和python2的Unicode实例都没有和特定的二进制编码形式相关联，想要把Unicode字符转换为二进制数据，就必须使用encode方法，想要把二进制数据转化成为Unicode字符，则必须使用decode 方法。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-34-59.png" alt="f"></li><li>在 Python3 中内存里的字符串是以 Unicode 编码的，Unicode 的其中一个特性就是跟所有语言编码都有映射关系，所以 UTF-8 格式的文件，在 Windows 电脑上若是不能看，就可以把 UTF-8 先解码成 Unicode ，再由 Unicode 编码成 GBK 就可以了。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-32-20.png" alt="g"><h5 id="字符串的转换"><a href="#字符串的转换" class="headerlink" title="字符串的转换"></a>字符串的转换</h5></li><li>在Python3中，接受str或byts，并总是返回str的方法:  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, bytes):<span class="comment">#注意这个函数</span></span><br><span class="line">        value = bytes_or_str.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li><li>接受str或bytes，并总是返回bytes的方法：  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li><li>在Python2中，接受str或unicode，并总是返回unicode的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_unicode(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, str):</span><br><span class="line">        value &#x3D; unicode_or_str.decode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure></li><li>接受str或unicode，并总是返回str的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_str(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, unicode):</span><br><span class="line">        value &#x3D; unicode_or_str.encode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure><h5 id="推荐的文件操作符"><a href="#推荐的文件操作符" class="headerlink" title="推荐的文件操作符"></a>推荐的文件操作符</h5>如果通过open函数获取文件句柄，该句柄会采用UTF-8编码格式来操作文件。<br>而在Python2中，文件操作的默认编码格式则是二进制形式。这可能会导致程序出现奇怪的错误。<br>例如，向文件中随机写入一些二进制数据。下面这种方法Python2中可以正常运行，但是在Python3中则不行：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TypeError: must be str, <span class="keyword">not</span> bytes</span><br></pre></td></tr></table></figure>上述情况是因为Python3给open函数添加了名为encoding的新参数，而这个新参数默认值是’utf-8′。这样在文件句柄上进行read和write操作时，系统就要求开发者必须传入包含unicode字符的str实例，而不接受包含二进制数据的bytes实例。</li></ul><p>解决这个问题，可以用二进制写入模式(‘wb’)来开启待操作的文件，按照这种方式可同时适配Python2和Python3：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>(读取文件也同理，可使用’rb’模式)</p><h3 id="第四条"><a href="#第四条" class="headerlink" title="第四条"></a>第四条</h3><p>用辅助函数来取代复杂的表达式</p><ul><li>开发者很容易过度运用Python的语法特性，从而写出那种特别复杂并且难以理解的单行表达式。</li><li>请把复杂的表达式移入辅助函数中。如果要反复使用相同的逻辑，那就更应该那么做。</li><li>使用if/esle表达式，要比用or或者and 这样的Boolean操作符写出的表达式更清晰。</li></ul><h3 id="第五条"><a href="#第五条" class="headerlink" title="第五条"></a>第五条</h3><p>了解切割序列的方法<br>python提供了一种把序列切成小块的写法，这种切片操作很容易四开发者轻易的访问序列中的某些元素所构成的子集。<br>最简单的用法，就是对内置list和bytes进行切割。<br>切割操作还可以延伸到实现了<strong>getitem</strong>和<strong>setitem</strong>这两个特殊方法的python类上，参见28条。</p><ul><li>不要写多余的代码。但start索引为零或者end索引为序列长度时，应该将其忽略</li><li>切片操作不会计较start或者end索引是否越界，这样我们很容易从前端或者后端开始。</li><li>对list赋值时，如果使用切片操作，就会把原列表中处在相关范围内的值替换成新值，即便它们的长度不同也依然可以替换。</li></ul><h3 id="第六条"><a href="#第六条" class="headerlink" title="第六条"></a>第六条</h3><p>在单词切片操作内，不要同时指定start、 end 和 stride </p><ul><li>问题在于采用stride方式进行切片时，经常会出现不符合预期的结果</li><li>切割列表时，如果制定了stride，代码就会变得费解。尤其是stride为负值的时候更是如此.</li><li>在同一个切片操作内，不要同时使用start、end和stride. 如果确实需要执行这种操作，那就考虑将其拆解为两条赋值语句，其中一条做范围切割，另一条做步进，或者考虑使用内置itertools模块中的islice.</li></ul><p>tips：<br><code>mystring[::-1]#反转字符串</code></p><h3 id="第七条"><a href="#第七条" class="headerlink" title="第七条"></a>第七条</h3><p>用列表推导来取代map和filter<br>python提供了一种精炼的写法，可以根据一个列表来制作另外一个列表.这种表达式称为list comprehension （列表推导）</p><ul><li>列表推导要比内置的map和filter函数清晰</li><li>列表推导可以很跳过输入列表中的某些元素</li><li>字典与集也支持推导表达式</li></ul><h3 id="第八条"><a href="#第八条" class="headerlink" title="第八条"></a>第八条</h3><p>不要使用含有两个以上表达式的列表推导</p><ul><li>列表推导支持多级循环，每一级循环也支持多项条件</li><li>超过两个表达式的列表推导难以理解，应该尽量避免<br>Tips：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br><span class="line">print(flat)</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="comment">#下面两种写法是等效的</span></span><br><span class="line"><span class="comment">#要从列表中取出大于4的偶数</span></span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">if</span> x %<span class="number">2</span> ==<span class="number">0</span>]</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">and</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="第九条"><a href="#第九条" class="headerlink" title="第九条"></a>第九条</h3><p>用生成器表达式来改写数据量较大的列表推导<br>列表推导的缺点是，对于输入序列中的每个值来说，都要创建一项仅含一项元素的全新列表，但输入数据较大时，可能会消耗大量内存，并导致程序崩溃。<br>为了解决此问题，python 提供了生成式表达式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt))</span><br><span class="line">print(it)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x101b81480</span>&gt;</span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">57</span></span><br></pre></td></tr></table></figure><p>Tips：<br>获取文件每行的字符数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt)]</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure><ul><li>当输入的数据量较大时，列表推导可能会因为占用太对内存而出问题。</li><li>由生成表达式所返回的迭代器，可以逐次产生输出值，从而避免了内存用量问题。</li><li>把某个生成器表达式说返回的迭代器，放在另一个生成器表达式的for子表达式中，即可将二者组合起来。</li><li>串在一起的生成器表达式执行速度很快。 </li></ul><h3 id="第十条"><a href="#第十条" class="headerlink" title="第十条"></a>第十条</h3><p>尽量用enumerate取代range<br>在一些列的整数上面迭代，内置的range函数很有用，<br>当迭代列表的时候，通常还想知道当前元素在列表中的索引。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(flavor_list)):</span><br><span class="line">    flavor = flavor_lsit[i]</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure><p>这种代码不利于理解，python提供了enumerate来解决此问题。enumerate可以把各种迭代器包装为生成器，以便稍后产生输出值，生成器每次产生一对输出值，前者为循环下标，后者表示从迭代器中获取到的下一个序列元素，这样写出来的代码会非常整洁。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure><ul><li>enumerate函数提供了一种精简的写法，可以在遍历迭代器时获知每个元素的索引</li><li>尽量用enumerate来改写那种将range与下标访问相结合的序列遍历代码</li><li>可以给enumerate 提供第二个参数，已指定开始计数时所用的值（默认为0）</li></ul><p>Tips:<br>还可以直接指定enumerate开始计数所用的值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list，<span class="number">1</span>):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i,flavor))</span><br></pre></td></tr></table></figure><h3 id="第十一条"><a href="#第十一条" class="headerlink" title="第十一条"></a>第十一条</h3><p>用zip函数同时遍历两个迭代器</p><ul><li><p>使用for循环</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Cecilia</span><br></pre></td></tr></table></figure><p>上面这段代码问题在一，整个循环语句看上去很乱，用下标来访问names和letters会使代码不易阅读。<br>改用enumerate可以稍稍缓解这个问题，但仍然不够理想。</p></li><li><p>使用for循环加enumerate</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names)：</span><br><span class="line">    count =letters[i]</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure></li><li><p>使用zip</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letter):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure></li><li><p>内置的zip函数可以平行的遍历多个迭代器</p></li><li><p>Python3中的zip相当于生成器，会在遍历过程中逐次产生元组，而Python2中的zip则是直接把这些元组完全生成号，并一次性的返回给整份列表。</p></li><li><p>如果提供的迭代器长度不等，那么zip就会自动提前终止。</p></li><li><p>itertools 内置模块中的zip_longest函数可以平行的遍历多个迭代器，而不用在乎它们的长度是否相等。</p></li></ul><h3 id="不要在for和while循环后面写else语块"><a href="#不要在for和while循环后面写else语块" class="headerlink" title="不要在for和while循环后面写else语块"></a>不要在for和while循环后面写else语块</h3><ul><li>python 有种特殊语法，可在 for及 while 循环的内部语句块之后紧跟一个else块。</li><li>只有当整个循环主体都没遇到break语句时，循环后面的else块才会执行。</li><li>不要再循环后面使用else块，因为在这种写法即不直观，又容易引人误解。</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/lipandeng/p/11162039.html" target="_blank" rel="noopener">https://www.cnblogs.com/lipandeng/p/11162039.html</a><br><a href="https://lingyunfx.com/?page_id=152" target="_blank" rel="noopener">https://lingyunfx.com/?page_id=152</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Effective-Python&quot;&gt;&lt;a href=&quot;#Effective-Python&quot; class=&quot;headerlink&quot; title=&quot;Effective Python&quot;&gt;&lt;/a&gt;Effective Python&lt;/h1&gt;&lt;h1 id=&quot;编写高质量代码的5
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Top 10 ways to make Maya go FASTER</title>
    <link href="http://yoursite.com/2020/03/10/Top%2010%20ways%20to%20make%20Maya%20go%20FASTER/"/>
    <id>http://yoursite.com/2020/03/10/Top%2010%20ways%20to%20make%20Maya%20go%20FASTER/</id>
    <published>2020-03-10T10:49:41.139Z</published>
    <updated>2020-03-10T10:49:41.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Top-10-ways-to-make-Maya-go-FASTER"><a href="#Top-10-ways-to-make-Maya-go-FASTER" class="headerlink" title="Top 10 ways to make Maya go FASTER"></a>Top 10 ways to make Maya go FASTER</h1><h2 id="1关闭一些显示设置："><a href="#1关闭一些显示设置：" class="headerlink" title="1关闭一些显示设置："></a>1关闭一些显示设置：</h2><p>首先是阴影，然后OCC，然后运动模糊然后抗锯齿</p><h2 id="2关闭材质球实时预览"><a href="#2关闭材质球实时预览" class="headerlink" title="2关闭材质球实时预览"></a>2关闭材质球实时预览</h2><p>可以改用右键单个refresh swatch</p><h2 id="3选择暂停viewport"><a href="#3选择暂停viewport" class="headerlink" title="3选择暂停viewport"></a>3选择暂停viewport</h2><a id="more"></a><h2 id="4确保不实用的插件不加载"><a href="#4确保不实用的插件不加载" class="headerlink" title="4确保不实用的插件不加载"></a>4确保不实用的插件不加载</h2><p>还可以导入的时候不自动载入ref，选择手动载入</p><h2 id="5关闭模型的Adaptive-open-Subdiv"><a href="#5关闭模型的Adaptive-open-Subdiv" class="headerlink" title="5关闭模型的Adaptive open Subdiv"></a>5关闭模型的Adaptive open Subdiv</h2><h2 id="6设置Viewport2-0"><a href="#6设置Viewport2-0" class="headerlink" title="6设置Viewport2.0"></a>6设置Viewport2.0</h2><p>1浮点渲染目标，此设置与色彩管理有关系，代价是CPU的RAM</p><p>推荐，R32G32B32A32_Float &gt; R16G16B16A16_Float</p><p>也可以完全禁用</p><p>2性能下把透明贴图算法改成 Alpha Cut</p><p>代价是牺牲了半透明的效果，但是提高了速度</p><h2 id="7使用贴图时，最轻量的贴图是JPEG"><a href="#7使用贴图时，最轻量的贴图是JPEG" class="headerlink" title="7使用贴图时，最轻量的贴图是JPEG"></a>7使用贴图时，最轻量的贴图是JPEG</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Top-10-ways-to-make-Maya-go-FASTER&quot;&gt;&lt;a href=&quot;#Top-10-ways-to-make-Maya-go-FASTER&quot; class=&quot;headerlink&quot; title=&quot;Top 10 ways to make Maya go FASTER&quot;&gt;&lt;/a&gt;Top 10 ways to make Maya go FASTER&lt;/h1&gt;&lt;h2 id=&quot;1关闭一些显示设置：&quot;&gt;&lt;a href=&quot;#1关闭一些显示设置：&quot; class=&quot;headerlink&quot; title=&quot;1关闭一些显示设置：&quot;&gt;&lt;/a&gt;1关闭一些显示设置：&lt;/h2&gt;&lt;p&gt;首先是阴影，然后OCC，然后运动模糊然后抗锯齿&lt;/p&gt;
&lt;h2 id=&quot;2关闭材质球实时预览&quot;&gt;&lt;a href=&quot;#2关闭材质球实时预览&quot; class=&quot;headerlink&quot; title=&quot;2关闭材质球实时预览&quot;&gt;&lt;/a&gt;2关闭材质球实时预览&lt;/h2&gt;&lt;p&gt;可以改用右键单个refresh swatch&lt;/p&gt;
&lt;h2 id=&quot;3选择暂停viewport&quot;&gt;&lt;a href=&quot;#3选择暂停viewport&quot; class=&quot;headerlink&quot; title=&quot;3选择暂停viewport&quot;&gt;&lt;/a&gt;3选择暂停viewport&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python文件打包成可执行文件</title>
    <link href="http://yoursite.com/2020/03/10/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/03/10/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</id>
    <published>2020-03-10T10:49:41.138Z</published>
    <updated>2020-03-10T10:49:41.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python文件打包成可执行文件"><a href="#Python文件打包成可执行文件" class="headerlink" title="Python文件打包成可执行文件"></a>Python文件打包成可执行文件</h1><p>Python是一个脚本语言，被解释器解释执行。它的发布方式：</p><h2 id="py-文件"><a href="#py-文件" class="headerlink" title=".py 文件"></a>.py 文件</h2><p>没什么好讲的，开源项目或者个人练习，直接提供源码最简单粗暴，需要使用者自行安装Python并且安装依赖的各种库。</p><h2 id="pyc-文件"><a href="#pyc-文件" class="headerlink" title=".pyc 文件"></a>.pyc 文件</h2><p>如果觉得源码写的差劲不好意思被别人看到，或者出于保密等不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#代码</span><br><span class="line">import py_compile</span><br><span class="line">py_compile.compile(&quot;D:\Python\main.py&quot;)            # 相对路径或绝对路径</span><br><span class="line"></span><br><span class="line">#命令行下</span><br><span class="line">python -m py_compile test.py</span><br><span class="line">#会在相同路径里面创建__pycache__文件夹，编译过的pyc文件就在里面</span><br><span class="line"></span><br><span class="line">#多个文件</span><br><span class="line">import compileall</span><br><span class="line">compileall.compile_dir(&quot;存放海量py的目录&quot;)</span><br></pre></td></tr></table></figure><h2 id="可执行exe文件"><a href="#可执行exe文件" class="headerlink" title="可执行exe文件"></a>可执行exe文件</h2><ul><li><p>pyInstaller</p><pre><code>1.安装pyInstaller</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pyinstaller #安装</span><br><span class="line">$ pyinstaller --version #查看版本</span><br></pre></td></tr></table></figure><p>  2.如果查看版本报错</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;pyinstall&#39; is not recognized as an internal or external command,operable program or batch file.#需要系统变量里的Path变量下添加其所在目录，然后重启命令行即可.</span><br></pre></td></tr></table></figure><p>  3.使用pyInstaller：</p><figure class="highlight plain"><figcaption><span>-F helloworld.py```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">- py2exe</span><br><span class="line"></span><br><span class="line">1. 命令行&#96;&#96;pip install py2exe&#96;&#96;安装</span><br><span class="line"></span><br><span class="line">1. 在命令行内测试你的程序确定可以运行</span><br><span class="line"></span><br><span class="line">   &#96;&#96;python helloworld.py&#96;&#96;</span><br><span class="line"></span><br><span class="line">2. 创建你自己的执行脚本 (setup.py)</span><br></pre></td></tr></table></figure><pre><code>from distutils.core import setupimport py2exe</code></pre></li></ul><pre><code>   setup(console=[&quot;helloworld.py&quot;]) #这里helloworld.py替换成你的脚本   ``` 3. 在命令行Run your setup script    ``python setup.py py2exe`` 4. 然后再dist文件夹下就会看到生成的.exe 文件了5. 如果出现``IndexError: tuple index out of range``的话是因为py2exe停止支持3.4以上版本，可以换用这个地方的py2exe, 但是好像也是有问题   ref：https://stackoverflow.com/questions/41578808/python-indexerror-tuple-index-out-of-range-when-using-py2exe   ref：https://github.com/albertosottile/py2exe</code></pre><ul><li><p>cx_Freeze</p><ol><li><p><code>$ pip install cx_Freeze</code>安装</p></li><li><p><code>$ cxfreeze hello.py --target-dir dist</code>生成执行文件，如果报错无法识别就参考这个解决</p><p>ref:<a href="https://stackoverflow.com/questions/25242860/cxfreeze-command-not-found-in-windows/25243419#25243419" target="_blank" rel="noopener">https://stackoverflow.com/questions/25242860/cxfreeze-command-not-found-in-windows/25243419#25243419</a> </p></li></ol></li><li><p>auto-py-to-exe 2.6.6</p><ol><li><code>$ pip install auto-py-to-exe</code> 安装</li><li>````$ auto-py-to-exe`` 使用</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python文件打包成可执行文件&quot;&gt;&lt;a href=&quot;#Python文件打包成可执行文件&quot; class=&quot;headerlink&quot; title=&quot;Python文件打包成可执行文件&quot;&gt;&lt;/a&gt;Python文件打包成可执行文件&lt;/h1&gt;&lt;p&gt;Python是一个脚本语言，被解释器解释执行。它的发布方式：&lt;/p&gt;
&lt;h2 id=&quot;py-文件&quot;&gt;&lt;a href=&quot;#py-文件&quot; class=&quot;headerlink&quot; title=&quot;.py 文件&quot;&gt;&lt;/a&gt;.py 文件&lt;/h2&gt;&lt;p&gt;没什么好讲的，开源项目或者个人练习，直接提供源码最简单粗暴，需要使用者自行安装Python并且安装依赖的各种库。&lt;/p&gt;
&lt;h2 id=&quot;pyc-文件&quot;&gt;&lt;a href=&quot;#pyc-文件&quot; class=&quot;headerlink&quot; title=&quot;.pyc 文件&quot;&gt;&lt;/a&gt;.pyc 文件&lt;/h2&gt;&lt;p&gt;如果觉得源码写的差劲不好意思被别人看到，或者出于保密等不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python 进程和线程学习笔记</title>
    <link href="http://yoursite.com/2020/03/10/Python%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/10/Python%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-10T10:49:41.137Z</published>
    <updated>2020-03-10T10:49:41.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-进程和线程学习笔记"><a href="#Python-进程和线程学习笔记" class="headerlink" title="Python 进程和线程学习笔记"></a>Python 进程和线程学习笔记</h1><ul><li><h3 id="进程和线程概述"><a href="#进程和线程概述" class="headerlink" title="进程和线程概述"></a>进程和线程概述</h3><p>进程：对于操作系统来说，一个任务就是一个进程（Process）</p><p>线程：在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p></li><li><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multprocessing # Python 中的 multiprocess 包提供了多进程支持</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#process multprocessing包中的一个类表示进程对象</span><br><span class="line"></span><br><span class="line">from multiprocessing import Process</span><br><span class="line">from tqdm import tqdm</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid())) #getpid()可以拿到进程的ID。</span><br><span class="line">    for i in tqdm(range(10000000)):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;: </span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">有化部分 ，这句代码以上的部分，可以被其它的调用，以下的部分只有这个文件自己可以看见，如果文件被调用了，其他人是无法看见私有化部分的</span><br><span class="line">也就是说你自己运行该模块的时候 这句话是执行的 因为自己运行时__name__就是__main__，而当别人调用你这个模块时，以下代码会被忽略，此时的__name__是模块名</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    print(&#39;Parent process %s.&#39; % os.getpid())</span><br><span class="line">    p &#x3D; Process(target&#x3D;run_proc, args&#x3D;(&#39;test1&#39;,))</span><br><span class="line">    d &#x3D; Process(target&#x3D;run_proc, args&#x3D;(&#39;test2&#39;,))</span><br><span class="line">    print(&#39;Child process will start.&#39;)</span><br><span class="line">    p.start()#调用进程</span><br><span class="line">    d.start()#调用进程</span><br><span class="line">    p.join()#join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步</span><br><span class="line">    d.join()</span><br><span class="line">    print(&#39;Child process end.&#39;)</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#Pool multprocessing包中的一个类，如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</span><br><span class="line"></span><br><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def long_time_task(name):</span><br><span class="line">    # for i in tqdm(range(10000000)):</span><br><span class="line">    #     pass</span><br><span class="line">    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end &#x3D; time.time()</span><br><span class="line">    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    print(&#39;Parent process %s.&#39; % os.getpid())</span><br><span class="line">    p &#x3D; Pool(4)</span><br><span class="line">    #创建子进程池</span><br><span class="line">    #参数数决定同时运行多少进程 如果是4 task4会等待 0 1 2 3 运行完在运行，如果是5 就0 1 2 3 4 一起运行</span><br><span class="line">    #如果你的参数大于你的CPU线程数还是要等待</span><br><span class="line">    #把参数去掉，就是按照操作系统的核数来</span><br><span class="line">    </span><br><span class="line">    for i in range(13):</span><br><span class="line">        p.apply_async(long_time_task, args&#x3D;(i,)) #注意这里，因为是类所有调用函数是 P.</span><br><span class="line">    print(&#39;Waiting for all subprocesses done...&#39;)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&#39;All subprocesses done.&#39;)</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#这种方法可以实现任意进程间的通信，这里写的是主、子进程间的通信</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def foo(aa):#必须要接收一个元祖</span><br><span class="line">    message &#x3D; aa.get()  # 管子的另一端放在子进程这里，子进程接收到了数据</span><br><span class="line">    print(&#39;子进程已收到数据...&#39;)</span><br><span class="line">    print(message)  # 子进程打印出了数据内容...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;: </span><br><span class="line"></span><br><span class="line">    xt &#x3D; multiprocessing.Queue()  # 创建进程通信的Queue，你可以理解为我拿了个管子来...</span><br><span class="line">    jc &#x3D; multiprocessing.Process(target&#x3D;foo, args&#x3D;(xt,))  # multiprocessing.Process创建子进程</span><br><span class="line">    jc.start()  # 启动子进程</span><br><span class="line">    print(&#39;主进程准备发送数据...&#39;)</span><br><span class="line">    xt.put(&#39;有内鬼，终止交易！&#39;)  # 将管子的一端放在主进程这里，主进程往管子里丢入数据</span><br><span class="line">    jc.join()</span><br></pre></td></tr></table></figure><ul><li><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：</span><br><span class="line">import time, threading</span><br><span class="line"># 新线程执行的代码:</span><br><span class="line">def loop():</span><br><span class="line">    print(&#39;thread %s is running...&#39; % threading.current_thread().name)</span><br><span class="line">    n &#x3D; 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&#39;thread %s ended.&#39; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(&#39;thread %s is running...&#39; % threading.current_thread().name)</span><br><span class="line">t &#x3D; threading.Thread(target&#x3D;loop, name&#x3D;&#39;LoopThread&#39;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(&#39;thread %s ended.&#39; % threading.current_thread().name)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-进程和线程学习笔记&quot;&gt;&lt;a href=&quot;#Python-进程和线程学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Python 进程和线程学习笔记&quot;&gt;&lt;/a&gt;Python 进程和线程学习笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;进程和线程概述&quot;&gt;&lt;a href=&quot;#进程和线程概述&quot; class=&quot;headerlink&quot; title=&quot;进程和线程概述&quot;&gt;&lt;/a&gt;进程和线程概述&lt;/h3&gt;&lt;p&gt;进程：对于操作系统来说，一个任务就是一个进程（Process）&lt;/p&gt;
&lt;p&gt;线程：在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;multprocessing # Python 中的 multiprocess 包提供了多进程支持&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Blender脚本学习笔记</title>
    <link href="http://yoursite.com/2020/03/10/Blender%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/10/Blender%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-10T10:49:41.119Z</published>
    <updated>2020-03-10T10:49:41.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blender脚本学习笔记"><a href="#Blender脚本学习笔记" class="headerlink" title="Blender脚本学习笔记"></a>Blender脚本学习笔记</h1><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><p>安装python3.0以上(Blender 2.8是 python3.x)</p></li><li><p>Vscode 安装python 和 blender Development 插件</p></li><li><p>终端安装 fake-bpy 包<code>pip install fake-bpy-module-2.80</code></p><p> <a href="https://github.com/nutti/fake-bpy-module" target="_blank" rel="noopener">https://github.com/nutti/fake-bpy-module</a></p><p>安装完上面这些，vscode里面就会有自动补全</p><p>Debug</p></li><li><p>ctrl + shift + P, select “Blender: Start”</p></li><li><p>选择你的blender安装路径, vscode会连接到blender</p></li><li><p>ctrl + shift + P, “Blender: Run script” 并且可以使用断点调试</p> <a id="more"></a></li></ul><h3 id="插件路径"><a href="#插件路径" class="headerlink" title="插件路径"></a>插件路径</h3><ul><li><p>目录：user\AppData\Roaming\Blender Foundation\Blender\scripts\addons,代表非系统原生的用户插件,blender所有安装的外部插件都会被解压放置到这个文件夹下。</p><p>安装插件可以在blender的addon界面直接选择zip文件安装，也可以把插件文件夹直接拖入此目录。</p></li><li><p>目录：D:\blender-2.81a\2.81\scripts\addons</p><p>第二个是软件原生插件路径，不建议将自己写的插件放入此地，此地不少系统插件的代码可在以后做参考用，值得了解。</p></li></ul><h3 id="如何查看命令"><a href="#如何查看命令" class="headerlink" title="如何查看命令"></a>如何查看命令</h3><ul><li>类似maya 直接执行某个功能，看info输出命令（A+X    清空nfo）</li><li>选中命令直接 Copy Data Path.</li><li>鼠标悬停在某个命令上看提示，如果没有提示，要去perfence里面的interface下勾选Python Tooltips.</li><li>控制台直接输入<code>dir（某个模块名）</code>查看输出</li><li>打开blender的text editor，很多模板文件可供使用：</li><li>用python console中的.后代码提示快捷键自动补全查看方法（ctrl+space）</li><li>查询api</li><li>全球最大爱好者论坛<a href="https://blender.stackexchange.com/" target="_blank" rel="noopener">https://blender.stackexchange.com/</a></li><li>查看各类开源插件</li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li><p>bpy 意思是 blender python</p></li><li><p>常规得到某个物体信息流程 </p><p>1 viewport选中物体 </p><p>2 查看Transform的提示 </p><p>3 调用各种信息 类似 .location</p></li></ul><p>常用命令</p><p><code>bpy.context.</code> 正文，当前环境的所有内容的意思</p><p><code>bpy.context.object</code> 物体</p><p><code>mesh = bpy.data.objects[&quot;mesh&quot;]</code> Mesh变量存储物体mesh</p><p><code>bpy.ops.object.select_all(action=&#39;SELECT&#39;)</code>全选命令</p><p><code>bpy.ops.object.select_all(action=&#39;DESELECT&#39;)</code>全不选命令</p><p><code>bpy.context.view_layer.objects.active = mesh</code>大纲选中，激活物体</p><p><code>bpy.context.object.location</code> 拿到选中物体的世界坐标</p><p><code>bpy.context.object.location.z</code>拿到选中物体的世界坐标中的Z坐标数值</p><p><code>bpy.context.object.location.z += random()</code> 选中物体的世界坐标中的Z坐标数值随机加一个数</p><p><code>bpy.context.object.name</code>查看选中物体的名字</p><p><code>bpy.ops.object.duplicate(linked=False,mode=&#39;TRANSLATION&#39;)</code>复制模型</p><p><code>bpy.ops.object.modifier_add(type=&#39;DECIMATE&#39;)</code>添加编辑器</p><p><code>bpy.context.object.modifiers[&quot;Decimate&quot;].ratio = 0.1</code>设置编辑器参数</p><p><code>bpy.ops.object.modifier_apply(apply_as=&#39;DATA&#39;, modifier=&quot;Decimate&quot;)</code>#应用编辑器</p><p><code>bpy.context.object.name = &quot;要改的名字&quot;</code> 选中物体的名字</p><p><code>bpy.ops.mesh.primitive_cube_add()</code>创建box</p><p><code>bpy.context.object.active_material</code>返回当前选择物体的材质球</p><p><code>bpy.data.materials.get(材质球名称字符串)</code>拿到当前场景的某个材质</p><p><code>bpy.context.view_layer.objects.active.material_slots.data.active_material= 某个材质</code> 给当前激活的物体材质球插槽赋予某个材质</p><p><code>bpy.ops.wm.save_mainfile(filepath=&quot;E:\\Test\\testsave.blend&quot;)</code>存储当前文件</p><p><code>bpy.ops.wm.open_mainfile(filepath=BlendFilePath)</code> 打开文件</p><p>得到当前版本的blender文件夹路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">argv &#x3D; sys.argv #当前blender的路径例：[&#39;D:\\blender-2.81a\\blender.exe&#39;]</span><br></pre></td></tr></table></figure><p>遍历列表选中物体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in bpy.context.visible_objects:#迭代所有可见物体</span><br><span class="line">if i.name &#x3D;&#x3D; &quot;要选物体的名字&quot;:</span><br><span class="line">i.select_set(state&#x3D;True)</span><br><span class="line">for i in bpy.context.visible_objects:</span><br><span class="line">    if i.type &#x3D;&#x3D; &quot;MESH&quot;:#判断物体类型是模型</span><br><span class="line">        bpy.context.view_layer.objects.active &#x3D; i #当前激活物体定义为i</span><br><span class="line">        bpy.ops.object.mode_set(mode&#x3D;&#39;EDIT&#39;) #编辑模式</span><br><span class="line">        bpy.context.tool_settings.mesh_select_mode &#x3D; (False, True, False)#编辑模式的（点线面）</span><br><span class="line">        bpy.ops.mesh.select_all(action&#x3D;&#39;SELECT&#39;)#全选命令</span><br><span class="line">        bpy.ops.object.mode_set(mode&#x3D;&#39;OBJECT&#39;)#关闭编辑模式</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Blender脚本学习笔记&quot;&gt;&lt;a href=&quot;#Blender脚本学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Blender脚本学习笔记&quot;&gt;&lt;/a&gt;Blender脚本学习笔记&lt;/h1&gt;&lt;h3 id=&quot;编辑器&quot;&gt;&lt;a href=&quot;#编辑器&quot; class=&quot;headerlink&quot; title=&quot;编辑器&quot;&gt;&lt;/a&gt;编辑器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装python3.0以上(Blender 2.8是 python3.x)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vscode 安装python 和 blender Development 插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;终端安装 fake-bpy 包&lt;code&gt;pip install fake-bpy-module-2.80&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/nutti/fake-bpy-module&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/nutti/fake-bpy-module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完上面这些，vscode里面就会有自动补全&lt;/p&gt;
&lt;p&gt;Debug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ctrl + shift + P, select “Blender: Start”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择你的blender安装路径, vscode会连接到blender&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ctrl + shift + P, “Blender: Run script” 并且可以使用断点调试&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo博客如何插入图片</title>
    <link href="http://yoursite.com/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-09T14:47:30.000Z</published>
    <updated>2020-03-10T10:49:41.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客如何插入图片"><a href="#Hexo博客如何插入图片" class="headerlink" title="Hexo博客如何插入图片"></a>Hexo博客如何插入图片</h1><ol><li><p>首先确认主页配置的_config.yml中：post_asset_folder:true.<br><img src="/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-07.png" alt="图片测试0"></p></li><li><p>在你的hexo目录下执行：<br><code>npm install hexo-asset-image --save</code><br>若出现错误则先执行：<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p></li><li><p>等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。</p></li><li><p>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中。<br><img src="/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-25.png" alt="图片测试1"></p></li><li><p>在xxxx.md中按照markdown的格式引入图片.</p></li></ol><p>引用：<br><a href="https://www.jianshu.com/p/a2786cdb06e1" target="_blank" rel="noopener">系列4：总结别人hexo博客如何插图片方法（有自己实现的图片实例）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo博客如何插入图片&quot;&gt;&lt;a href=&quot;#Hexo博客如何插入图片&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客如何插入图片&quot;&gt;&lt;/a&gt;Hexo博客如何插入图片&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先确认主页配置的_config.yml中
      
    
    </summary>
    
    
    
      <category term="misc" scheme="http://yoursite.com/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="http://yoursite.com/2019/12/03/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/03/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-03T03:32:35.000Z</published>
    <updated>2020-03-10T10:49:41.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-学习笔记"><a href="#Git-学习笔记" class="headerlink" title="Git 学习笔记"></a>Git 学习笔记</h1><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="1-设置-Git-全局用户名和邮箱"><a href="#1-设置-Git-全局用户名和邮箱" class="headerlink" title="1. 设置 Git 全局用户名和邮箱"></a>1. 设置 Git 全局用户名和邮箱</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;gitaccount&quot; #设置用户名</span><br><span class="line">$ git config --global user.email &quot;gitaccount@example.com&quot; #设置用户名</span><br><span class="line">$ git config --global user.name #查看用户名</span><br><span class="line">$ git config --global user.email #查看邮箱</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-使用流程命令"><a href="#2-使用流程命令" class="headerlink" title="2. 使用流程命令"></a>2. 使用流程命令</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git init #初始化仓库</span><br><span class="line">$ git status # 查看git版本控制状态</span><br><span class="line">$ git add xxxxxx # 加入文件tracked</span><br><span class="line">$ git commit -m &quot;描述&quot; #提交文件到暂存区</span><br><span class="line">$ git log #查看日志</span><br><span class="line">$ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;sunyuxianggit&#x2F;sunyuxianggit.github.io.git #预提交到远端仓库（关联本地和远程仓库）</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><h5 id="3-常见报错"><a href="#3-常见报错" class="headerlink" title="3. 常见报错"></a>3. 常见报错</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists.</span><br><span class="line">$ git remote rm origin #删除远程 URL</span><br><span class="line">ref:https:&#x2F;&#x2F;blog.csdn.net&#x2F;top_code&#x2F;article&#x2F;details&#x2F;50381432</span><br></pre></td></tr></table></figure><h5 id="4-速度问题"><a href="#4-速度问题" class="headerlink" title="4. 速度问题"></a>4. 速度问题</h5><ul><li><p>设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; </span><br><span class="line">git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy</span><br><span class="line">git config --global https.proxy</span><br></pre></td></tr></table></figure></li><li><p>取消设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git-学习笔记&quot;&gt;&lt;a href=&quot;#Git-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Git 学习笔记&quot;&gt;&lt;/a&gt;Git 学习笔记&lt;/h1&gt;&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;h5 id=&quot;1-设置-Git-全局用户名和邮箱&quot;&gt;&lt;a href=&quot;#1-设置-Git-全局用户名和邮箱&quot; class=&quot;headerlink&quot; title=&quot;1. 设置 Git 全局用户名和邮箱&quot;&gt;&lt;/a&gt;1. 设置 Git 全局用户名和邮箱&lt;/h5&gt;   &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name &amp;quot;gitaccount&amp;quot; #设置用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email &amp;quot;gitaccount@example.com&amp;quot; #设置用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name #查看用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email #查看邮箱&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用hexo创建个人blog网页的笔记</title>
    <link href="http://yoursite.com/2019/12/01/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E7%BD%91%E9%A1%B5%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/01/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E7%BD%91%E9%A1%B5%E7%9A%84%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-10T10:49:41.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装支持软件"><a href="#安装支持软件" class="headerlink" title="安装支持软件"></a>安装支持软件</h2><ol><li><p>下载并安装node.js.<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p></li><li><p>下载好可以在cmd里面通过查看版本号来确认安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v #参看node版本号</span><br><span class="line">$ npm -v # 查看npm包管理器版本号</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>由于npm国内下载包速度太慢，所以可以里面npm安装一个cnpm（使用淘宝源）加快速度，不需要可以跳过，同理可以通过查看版本号确认安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry&#x3D;&quot;https:&#x2F;&#x2F;registry.npm.taobao.org&quot; #-g表示全局安装</span><br><span class="line">$ cnpm -v#参看cnpm 版本号</span><br></pre></td></tr></table></figure></li><li><p>使用cnpm 安装hexo，同理可以通过查看版本号确认安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g hexo-cli #全局安装hexo</span><br><span class="line">$ hexo -v #参看hexo版本号</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用hexo搭建博客"><a href="#使用hexo搭建博客" class="headerlink" title="使用hexo搭建博客"></a>使用hexo搭建博客</h2><ol><li><p>首先建立一个空的文件夹blog</p></li><li><p>命令行进入blog文件夹</p></li><li><p>使用hexo生成博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init #生成博客</span><br></pre></td></tr></table></figure></li><li><p>使用hexo server进行本地预览博客，预览完成后Ctrl+C退出预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s#本地预览博客</span><br></pre></td></tr></table></figure></li><li><p>使用hexo new 新建文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n &quot;文章名&quot;</span><br></pre></td></tr></table></figure></li><li><p>先使用hexo clean 清除已经创建的页面，在使用hexo generated生成页面，建议生成先进行本地预览。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean #清除</span><br><span class="line">$ hexo g #生成</span><br></pre></td></tr></table></figure></li></ol><h2 id="如何把博客布置到github上"><a href="#如何把博客布置到github上" class="headerlink" title="如何把博客布置到github上"></a>如何把博客布置到github上</h2><ol><li><p>首先在github自己的账号内新建仓库，注意仓库名就是你的域名。仓库名必须是 [账户名.github.io]</p></li><li><p>安装git并在git下设置用户名和邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name [username]</span><br><span class="line">git config --global user.email [email]</span><br></pre></td></tr></table></figure></li><li><p>在bolg文件夹下安装git部署插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>设置一下bolg文件夹的_config.yml，注意每个冒号后面有空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git </span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;sunyuxianggit&#x2F;sunyuxianggit.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>部署到github，中间需要输入github的账号密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo doploy#部署到GitHub</span><br></pre></td></tr></table></figure></li><li><p>常见错误：</p><p>fatal: in unpopulated submodule ‘.deploy_git’</p><p>这种情况可以先安装下相关的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git –save</span><br><span class="line">$ rm -rf .deploy_git#删掉</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d#重新生成和部署</span><br></pre></td></tr></table></figure></li></ol><h2 id="日常更新文章"><a href="#日常更新文章" class="headerlink" title="日常更新文章"></a>日常更新文章</h2><ol><li>命令行进入blog文件夹使用<code>$ hexo new</code> 新建文章</li><li>使用<code>$ hexo clean</code>清除老页面，然后在使用<code>$ hexo generated</code>生成页面</li><li>使用<code>$ hexo server</code>本地预览没有问题后，使用 <code>$ hexo deploy</code>部署到Github</li></ol><h2 id="如何更换主题"><a href="#如何更换主题" class="headerlink" title="如何更换主题"></a>如何更换主题</h2><ol><li><p>命令行进入blog</p></li><li><p>使用git clone 功能 clone喜欢的主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: yilia#这里</span><br></pre></td></tr></table></figure></li></ol><h2 id="多台设备同步管理"><a href="#多台设备同步管理" class="headerlink" title="多台设备同步管理"></a>多台设备同步管理</h2><ol><li>原创建博客设备把源文件上传到GitHub，上传时注意检查所有.gitignore文件忽略情况和把node_modules文件夹删掉（因为内部文件名太长，上传的话git报错）.</li><li>另一台电脑上将源代码clone下来之后，直接执行 <code>cnpm install</code>把node_modules安装回来.</li><li>然后<code>hexo s</code>正常使用.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装支持软件&quot;&gt;&lt;a href=&quot;#安装支持软件&quot; class=&quot;headerlink&quot; title=&quot;安装支持软件&quot;&gt;&lt;/a&gt;安装支持软件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载并安装node.js.&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载好可以在cmd里面通过查看版本号来确认安装成功。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ node -v #参看node版本号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm -v # 查看npm包管理器版本号&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="个人笔记" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>

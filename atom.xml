<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SunYuxiangのBlog</title>
  
  <subtitle>好记性,不如烂笔头.今天你要写点什么？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-09T10:15:17.179Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sun Yuxiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GAMES101-现代计算机图形学入门-闫令琪(6-10)</title>
    <link href="http://yoursite.com/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/"/>
    <id>http://yoursite.com/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/</id>
    <published>2020-03-24T11:34:27.000Z</published>
    <updated>2020-04-09T10:15:17.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六节"><a href="#第六节" class="headerlink" title="第六节"></a>第六节</h2><h5 id="上节课复习"><a href="#上节课复习" class="headerlink" title="上节课复习"></a>上节课复习</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-25-10-26-53.png" alt><br>MVP（model模型变换- view跟随摄影机变换到相对（0，0，0）位置 - project 投影变换（-1，1的3次方的空间））变换之后在进行视口变换（viewport，-1，1的3次方的空间变换到分辨率空间)</p><a id="more"></a><h5 id="Antialiasing-抗锯齿"><a href="#Antialiasing-抗锯齿" class="headerlink" title="Antialiasing 抗锯齿"></a>Antialiasing 抗锯齿</h5><p>根据上节课的判断，我们可以得到某些像素带你的中心在三角形内部，某些不在，如图：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-05-28.png" alt><br>我们想得到的是这样的三角形：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-05-50.png" alt><br>结果把对应的像素填充完得到这样的三角形：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-05-36.png" alt><br>Aliasing 走样/锯齿<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-08-05.png" alt><br>我们要想抗锯齿首先要明白锯齿是怎么来的。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-09-57.png" alt><br>采样是图形学中广泛存在的做法，光栅化的过程，其实就是在屏幕空间用一系列离散的点（也就是像素的中心）进行是否在三角形内这么一个函数的采样。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-14-26.png" alt><br>照片也是采样：一副照片，就是说所有到达这个感光元件的所在平面的光学信息，我们把它们离散成一系列图片上的像素的过程。</p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-21-37.png" alt><br>采样不光可以发生在不同的未知，也可以发生在不同的时间。<br>视频就是在时间上的采样。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-23-38.png" alt><br>采样是广泛存在的，采样的问题也是广泛存在的。<br>Artifacts(瑕疵)<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-27-36.png" alt><br>采样的问题：</p><ol><li>锯齿</li><li>摩尔纹（把采样的过程的奇数行和奇数列去掉在对起来就会产生这样的问题）</li><li>顺时针变成逆时针(采样速度太慢)<br>信号变化太快，导致采样速度跟不上。</li></ol><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-35-31.png" alt><br>如何做抗锯齿，在采样之前先做个模糊或者滤波。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-36-16.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-11-40-29.png" alt><br>这样操作完之后效果还不错：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-14-39-16.png" alt><br>如果是先采样后模糊呢？结果是不行。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-14-40-02.png" alt></p><p>为什么?<br>为什么说采样的速度的跟不上信号变换的速度就会产生走样，<br>为什么先去做采样，后做模糊操作达不到反走样效果  </p><p>为了解释为什么需要引入频率  </p><h5 id="Frequency-频率："><a href="#Frequency-频率：" class="headerlink" title="Frequency 频率："></a>Frequency 频率：</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-16-57-07.png" alt><br>最简单的正弦余弦波： 差别就是相位不一样。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-16-58-16.png" alt><br>通过调整系数，会得到不同的余弦波，它们的不同在于频率不同，这里我们定义一个事情，cos2pifx, f就是频率，f就可以定义频率变换有多快，周期就是频率的倒数。<br>为什么要介绍这些呢？<br>微积分里面傅里叶基数展开：任何一个周期函数，都可以写成一系列正弦和余弦函数的线性组合以及一个常数项<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-17-23-50.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-17-30-47.png" alt><br>所谓傅里叶变换，其实就是把函数给变成不同频率的段，并且把这些段显示出来。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-17-38-16.png" alt><br>小例子，相同的采样频率，对应上不同的变化频率，采样结果反应实际的效果越差。<br>由此我们可以看出来，采样的频率应该跟随被采样的频率变换。</p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-17-45-11.png" alt><br>如果同一个采样点，采样两种截然不同的函数，结果是一致的，像这样的情况就叫走样/混叠。</p><h5 id="Filtering-滤波："><a href="#Filtering-滤波：" class="headerlink" title="Filtering 滤波："></a>Filtering 滤波：</h5><p>所谓滤波，就是去掉一系列特定的频率。<br>傅里叶变换可以帮住我们理解这样事情。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-17-50-02.png" alt></p><p>左边的图经过傅里叶变换可以变成右边这幅图。<br>图像空间变成频率空间。<br>频率空间怎么理解呢，中心我们把它理解为最低频的区域，边缘是最高频的区域。在不同频率上有多少信息我们用亮度表示，可以看出这幅图大多数信息集中在低频上。对于自然的图片一般都是这样的。为什么会有水平和竖直的道呢?简单说原因是我们在分析一个信号时会认为它是一个周期性重复信号，对于不周期重复的信号，我们认为它是Tiling的，那我们会发现，正常的图片的左右和上下是会发生剧烈变换的，就会产生一个极高的高频。<br>图形的频率信息可以理解为图像相邻像素间色彩的变化。<br>傅里叶变换能够可以让我看到任何图像（任何信号）在各个不同的频率上长什么样，也叫做频谱图。  </p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-18-07-23.png" alt><br>滤波就是去掉一些频率的内容。把低频去掉（就是把图像中变化缓慢的色块去掉）， 在反傅里叶变换，可以得到一张显示物体的边界的图片。<br>这种滤波叫高通滤波（只有高频信息可以通过）。<br>为什么说高频信息对应上人物边界上呢，因为边界就是信息变化剧烈的地方，  </p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-18-41-46.png" alt><br>把高频信息抹掉，只留下低频信息，在反傅里叶变换变回图片，可以得到一张模糊的图片<br>这种滤波叫低通滤波（只有低频信息可以通过）。<br>意味着边界被去掉了，模糊了。  </p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-18-46-37.png" alt><br>保留了某一段频段，我们就会得到这样的效果。  </p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-19-07-20.png" alt><br>滤波就去掉某一特定频率的信息。<br>滤波又等于平均又等于卷积。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-19-23-41.png" alt></p><h5 id="Convolution-卷积："><a href="#Convolution-卷积：" class="headerlink" title="Convolution 卷积："></a>Convolution 卷积：</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-20-40-01.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-20-42-54.png" alt><br>什么是卷积？<br>其实就是加权平均。<br>所谓卷积是，在原始的信号附近取若干数用某一种滤波器的平均（图形学上简化的卷积）。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-20-45-50.png" alt><br>时域的卷积等于频域的乘积。(这块没搞懂，但是好像不影响)<br>例子：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-20-54-51.png" alt><br>任何一个像素都是它周围3<em>3像素的平均<br>拿到一幅图，先把它做傅里叶变换变成频域上的结果，3</em>3的卷积核也做傅里叶变换可以变成频域上，时域上做的卷积（上排乘起来），对应到频域上就是把两个信号乘起来，我们就发现大量的信息都变成黑的，只有中心一部分有信息，就像过了一个低通滤波。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-21-05-48.png" alt><br>卷积核，3*3乘以1/9，不乘亮度就爆了。等于一个像素+旁边八个像素在除以9。我们管他叫低通滤波器。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-21-10-59.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-27-21-11-43.png" alt><br>如果这个box变大变小呢？<br>更大box做卷积操作，得到的结果越模糊，频域上的结果就超级小，更小的box，比像素还小，等于没做滤波，把所有频率都留下来了，</p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-13-58-00.png" alt><br>从频域的角度看采样。<br>采样其实就是重复频率上的内容。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-13-58-43.png" alt><br>时域的卷积等于频域的乘积<br>采样就是重复一个原始信号的频谱。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-14-02-32.png" alt><br>频谱上采样间隔越大，重复的频谱就越密，密到叠到一起就是走样。</p><h5 id="Antialiasing-反走样："><a href="#Antialiasing-反走样：" class="headerlink" title="Antialiasing 反走样："></a>Antialiasing 反走样：</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-14-06-56.png" alt><br>做法：</p><ol><li>680*440分辨率的显示器光栅化一个三角形，一个像素非常大，那当然看起来锯齿很严重，如果视网膜显示屏分辨率很高，对应像素很小，意味着像素和像素的间隔小，意味着采样间隔小，意味着在频谱上，频谱的搬移间隔大不容易混叠到一起，所以走样小。但是受制于物理空间实际因素，不可能开启某个反走样的效果提高分辨率。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-14-12-40.png" alt></li><li><strong>先做模糊，后做采样。</strong>对应到频率上来说，模糊就是低通滤波，去掉高频信号，在采样，就不会发生混叠了。</li></ol><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-14-14-13.png" alt><br>实际操作中，我们用什么滤波器来进行卷积操作呢？<br>对应到三角形，我们怎么把三角形变成模糊三角形?<br>用一个一定大小的低通滤波器对它进行卷积。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-14-16-53.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-14-47-15.png" alt><br>反走样的基本方法：<br>对原始的三角形做以像素大小为卷积核的操作，或者说求个平均，然后在做采样。<br>如图对于任何一个像素，就是这些情况。</p><p>一个三角形对它覆盖的每个像素求个平均，怎么才能把一个三角形在某一个像素里面覆盖的区域算出来？<br>一个近似的方法。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-15-25-24.png" alt><br>一个像素划分成4*4个点，算出近似覆盖率，<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-15-27-12.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-15-29-41.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-15-29-04.png" alt><br>MSAA解决了对信号的模糊这一步操作，采样是隐含在里面的，MSAA 并没有提高分辨率，而是为了得到一个近似合理的覆盖率。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-15-33-24.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-15-33-27.png" alt><br>结果还是挺明显的。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-15-34-08.png" alt><br>没有免费的午餐，增大了计算量，工业界会使用不同排列的采样点，而且每个采样点会得到复用，所以实际上的计算量没有那么高。<br>抗锯齿有很多种方法，最有代表的就是FXAA（图像后期处理）和 TAA（复用上一帧得到感应到结果）<br>超分辨率：<br>从低分辨率到高分辨率<br>本质上还是 采样不足的问题，用深度学习猜出来。</p><h2 id="第七节"><a href="#第七节" class="headerlink" title="第七节"></a>第七节</h2><h3 id="上节复习"><a href="#上节复习" class="headerlink" title="上节复习"></a>上节复习</h3><ol><li>Rasterization 光栅化</li><li>采样</li><li>反走样<br>先采样后做模糊为什么是错的？先采样就是在频谱上进行搬移，产生混叠。再模糊等于对画面施加了一个低通滤波。</li></ol><h3 id="Visibility-Occlusion-可见和遮蔽"><a href="#Visibility-Occlusion-可见和遮蔽" class="headerlink" title="Visibility/Occlusion 可见和遮蔽"></a>Visibility/Occlusion 可见和遮蔽</h3><h5 id="Z-buffering"><a href="#Z-buffering" class="headerlink" title="Z-buffering"></a>Z-buffering</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-16-33-48.png" alt><br>先绘制远的，再绘制近的，近的遮挡远的，就像油画绘制方式，这种算法叫做画家算法。<br>怎么计算深度（先画哪个）其实挺难的，特别是互相覆盖的情况。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-16-44-43.png" alt><br>为了解决这个问题，引入了Zbuffer算法（广泛采用）<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-16-46-31.png" alt><br>对三角形不好排远近顺序，但是对像素排序好排序，每一个像素在这个像素内去记录所表示的几何最浅深度（离我们最近的距离）。<br>为了完成深度缓存，通常的做法是，渲染结果图片的同时生成深度图（深度缓冲）。<br>然后我们利用深度缓存去处理遮挡关系。   </p><p>重要的说明，我们在变换中假设摄影机放在原点朝-Z看，所以Z越小离摄影机越远，越大离摄影机越近。<br>为了方便ZBuff计算，现在我们重新定义Z越小离摄影机越近，Z越大越远。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-17-17-22.png" alt><br>越近值越小，越黑，越大值越大，越白。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-17-18-44.png" alt></p><p>假如有一个像素，我先画了地板，后面又被物体覆盖了，那么在这个像素上，我们查看一下两个东西在这个点的深度，小的覆盖大的。并且更新右边深度图。<br>每一个像素内记录最浅深度。  </p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-17-21-47.png" alt><br>深度缓存： 首先认为所有像素记录的深度都是无限远的，然后把一个个三角形以任意顺序做光栅化变成像素，再在任意三角形覆盖的任意像素的深度信息跟原有的zbuffer作比较，如果比它小，就更新这个像素的颜色和深度到图片和zbuffer上。</p><p>下面是伪代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> [所有三角形列表]:<span class="comment">#在所有三角形列表内循环</span></span><br><span class="line">    <span class="keyword">for</span> pixel <span class="keyword">in</span> t:<span class="comment">#在三角形的所有像素列表内循环</span></span><br><span class="line">        <span class="keyword">if</span> pixel.z &lt; Zbuffer[pixel.xy]:<span class="comment">#判断像素的深度信息是否小于zbuffer如果小于就更新 图片颜色 和zbuffer深度.</span></span><br><span class="line">            framebuffer[x,y] =pixel.rgb</span><br><span class="line">            Zbuffer[pixel.xy] = pixel.z </span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#否则啥也不干</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-17-34-48.png" alt><br>例子：<br>一开始所有的像素对应的深度缓存，存的都无限大的数直（R）后面一个三角形的深度在5，5比无限大小，所以先画图像再更新Zbuffer,然后第二个三角形的深度对比进来，对比每一个像素的深度值，小的像素绘制然后更新，大的就不绘制不更新（5遮挡8），通过这种办法我们可以维护一个逐像素的深度缓存正确。最后我们会得到正确的图像和深度缓存。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-28-18-55-28.png" alt><br>总结一下：<br>画家算法，要花O(Nlog(N))。<br>深度缓存算法，O(n) N=三角形个数。<br>这里这里我们并没有排序所有像素，我们只是记录。等于对每个像素求一堆三角形里面的最小值。  </p><p>假设不会有两个三角形在同一个像素有完全一致的深度，那么如果先画紫色或者先画红色三角形，结果都是一致的。<br>对于反走样的MSAA的方法,对于一个像素中间采样多个点，对于Zbuffer也要对每一个采样点求一个值。  </p><p>注：Zbruffer处理不了透明物体。  </p><h5 id="Shading-着色"><a href="#Shading-着色" class="headerlink" title="Shading 着色"></a>Shading 着色</h5><p>为什么要学着色？<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-10-28-01.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-10-46-05.png" alt><br>引入明暗和颜色。<br>这门课里，对不同物体应用不同材质的过程叫做shading。  </p><h5 id="简单的反射（着色）模型"><a href="#简单的反射（着色）模型" class="headerlink" title="简单的反射（着色）模型"></a>简单的反射（着色）模型</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-10-50-38.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-10-52-21.png" alt><br>高光-漫反射-间接光照<br>把这三部分都分析表示出来，自然可以做出一种材质。使得它长得跟杯子很相似，在开始之前我们需要定义一些东西。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-11-01-15.png" alt>  </p><ol><li>表面方向：在一个小范围可以认为面是平面。面朝向的方向是法线n（表示方向用单位向量）。  </li><li>观测方向：从shading point 往相机连一条线就是v（表示方向用单位向量）。  </li><li>光源方向：动shading point 往光源连一条线就是I（表示方向用单位向量）。  </li><li>shading point这个点的本身物体表面属性：颜色，亮度等。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-11-06-23.png" alt><br>Shading in Local:目前来说我们所说的着色，我们考虑只考虑这个点和其它我们定义的方向属性，但是先不考虑是否在阴影内，也不考虑其它物体是否存在。</li></ol><h5 id="Diffuse-Item-漫反射的表示："><a href="#Diffuse-Item-漫反射的表示：" class="headerlink" title="Diffuse Item 漫反射的表示："></a>Diffuse Item 漫反射的表示：</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-11-11-37.png" alt><br>什么叫漫反射，有一根光线打到物体的某一个点上，会被均匀的反射到各个方向上就叫漫反射，我们把这个表诉出来就行。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-11-14-54.png" alt><br>Lambert’s Cosine Law<br>同样的光照到不同角度的物体上亮度为什么会不同，第一张图接受6根光线，第二张图表面旋转60度接受3根光线，通过观测可以推导出物体表面法线和光线来源的夹角可以决定物体表面有多亮。<br>一个科学解释：首先要考虑光是能量，我们要看到的是这些物体接收了多少能量，接收能量当然跟面积有关，我们考虑shading point接受多少能量，指的是一个单位面积接收了多少能量。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-16-28-30.png" alt><br>能力的衰减，光源在中心，根据能量守恒定律，小的球壳上必然每个点的能量很多，大的球壳，球壳表面积增加，必然每个点分担的能量变少。<br>那我们定义半径为一的球壳上一个点能量为I,那根据能量守恒我们可以算出来半径为r的一个点能量为I/r的平方。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-30-17-57-23.png" alt><br>结论  </p><ol><li><p>光线在传播过程中，如果考虑单位面积，在任何以为所能接收到能量，和光线传播的距离成平方反比，（对于任何一点，光线传播越长，单位面积上所接收到的能量衰减越多）  </p></li><li><p>假设知道点光源，知道shading point离点光源有多远，我们就知道有多少能量传播到shading point ，又根据Lambert’s Cosine Law 我们知道有多少光会被接收，到达和接收算出来那我们就可以得到diffuse的表示方法<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-31-10-20-54.png" alt></p></li><li><p>点光源距离shading point 为2，我们知道点光源强度I知道r就可以算出来在shading point shang 到达了多少能量。  </p></li><li><p>根据Lambert’s, n点乘i可以得到余弦（为了避免得到没有物理意义的负数，光线从下面射到上面，这里用了一个max函数），知道了会接收多少能量。  </p></li><li><p>shading point为什么会有颜色，是因为它本身吸收了一定能量，然后反射出来是它不吸收的能量，也就是被看到的颜色，不同的点有不同的吸收率也就得到不同的颜色，这里我们定义了一个系数kd（表示diffuse），如果kd是1（灰度）就表示所有能量都被吸收了，没有能量被反射出去，如果是一个3维向量（rgb）就表示了颜色。  </p></li><li><p>光线打到shading point 反射光是均匀的半球，所以从哪看都一样，所以跟v完全没关系。  </p></li></ol><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-31-10-46-05.png" alt></p><p>注：这是一个经验模型，并不是完全符合物理的模型。</p><h2 id="第八节"><a href="#第八节" class="headerlink" title="第八节"></a>第八节</h2><h5 id="上节课复习-1"><a href="#上节课复习-1" class="headerlink" title="上节课复习"></a>上节课复习</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-31-11-34-08.png" alt><br>上节课学了Blinn -Phong着色模型，在一定的光照下，希望算清楚一个点是什么样的亮度。有什么样的颜色。分析了茶杯图片，着色分为漫反射项，高光项，和环境光项。<br>有两个事情再强调下：</p><ol><li>我们所谓的着色是在某一个shading point，要想得到一整张图要在很多地方应用很多次</li><li>lighting 的方向，是指从shading point 指向光源，从光源的位置减去shading point的位置在归一化变成的单位向量。</li></ol><h5 id="Specular-Term-高光项的表示："><a href="#Specular-Term-高光项的表示：" class="headerlink" title="Specular Term 高光项的表示："></a>Specular Term 高光项的表示：</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-31-22-57-12.png" alt><br>什么是高光: 平面比较光滑，接近镜面（如果是镜面就是根据入射角，法线很容易算出出射角如图V，如果是接近镜面就是在镜面反射的出射角附近如图R），如果能观察到高光那么观测角就在R接近，其他时间肯定看不到。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-31-23-05-19.png" alt><br>聪明的Blinn-Phong模型：<br>当我的观察方向和镜面方式R接近的时候，其实就说明法线方向和所谓“半程向量”很接近。<br>求两个单位向量的角平分线，很简单，两个向量一加，根据平行四边形法则，加出来的方向一定在中心，在做一下归一会就是h了。<br>h（半程向量）和n（法线）接近就说明V（观测方向）和R（反射方向）接近。<br>这样的好处就是如果要判断我是否看的到高光只需要看n（法线）和h（半程向量）是否接近。<br>（怎么样衡量两个向量是否接近，就看两个向量的点乘的结果是否接近1）</p><ol><li>ks 表示镜面反射系数。</li><li>（I/r的平方）多少能量到达。</li><li>这里为啥不考虑多少能量接收，因为blinn phone是一个经验模型</li><li>n和h点乘判断我的视角和高光有多接近，（为了避免得到没有物理意义的负数，光线从下面射到上面，这里用了一个max函数）<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-31-23-36-28.png" alt></li><li>指数P是因为点乘的容忍度太高，向量偏离很大点乘数还是很高，如图，如果直接拿来用的话高光范围太大到45度还能看到，给定一个指数可以控制曲线也就是控制高光范围比如系数64到15度的时候就没有高光了，blinn pong模型经常用到100-200.<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-31-23-43-12.png" alt><br>列是镜面反射系数变换，行是系数变换。<h5 id="Ambient-Term-环境光照的表示："><a href="#Ambient-Term-环境光照的表示：" class="headerlink" title="Ambient Term 环境光照的表示："></a>Ambient Term 环境光照的表示：</h5></li></ol><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-13-27-16.png" alt><br>观察得到茶杯的背面可以接收到环境光</p><ol><li>环境光不讲究从哪个地方照射</li><li>环境光跟观测方向也没关系</li><li>跟物体表面法线也没关系<br>blinn phong 模型里面的环境光是常数（一个颜色），保证场景内没有黑的地方，把所有其他的项都加起来提示一个亮度<br>Ia是环境光的强度<br>Ka是环境光的系数</li></ol><h5 id="所有的项都加起来"><a href="#所有的项都加起来" class="headerlink" title="所有的项都加起来"></a>所有的项都加起来</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-13-35-59.png" alt><br>环境光（和法线方向无关，和光照方向无关，和观测方向无关） + 漫发射（和观测方向无关）+高光（和三个都有关） = Blinn-Phong Reflection模型。<br>任何一个shading point（一个点）知道了之后，对所以的点做一遍操作，整个场景就计算出来了。</p><h5 id="Shading-Frequencies-着色频率"><a href="#Shading-Frequencies-着色频率" class="headerlink" title="Shading Frequencies 着色频率"></a>Shading Frequencies 着色频率</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-14-17-09.png" alt><br>三个几何表示完全相同的球，为什么着色了之后结果各不相同呢？<br>着色频率：就是把着色应用到哪些点上。<br>第一个球是着色应用在面上（根据面法线）<br>第二个球是着色应用在顶点上（vertexes），也就是一个三角面应用三次着色（然后根据插值算出来面）<br>第三个球是着色应用在每一个像素上（也就是根据每一个三角形顶点法线，进行插值，求出每一个像素的法线，然后着色，）</p><p>把以上三种方法做一个正规的定义</p><ol><li>Flat Shading（把三角形面的面法线求出来，算出来一个shading的结果应用到这个三角形上）<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-15-20-22.png" alt></li><li>Gouraud shading（每个顶点（vertexes）的法线求出来，对三个点着色之后再插值到整个面上）<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-15-38-56.png" alt></li><li>Phong Shading （根据每一个三角形顶点法线，进行插值，求出每一个像素的法线，然后着色）注意不要和Blinn Phong 反射模型混淆<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-15-39-16.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-15-52-07.png" alt><br>不同模型不同着色频率的对比图<h5 id="不同的法线怎么算"><a href="#不同的法线怎么算" class="headerlink" title="不同的法线怎么算"></a>不同的法线怎么算</h5>逐顶点的顶点法线怎么算？<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-15-59-35.png" alt><br>结论：任何一个顶点都会和很多个不同的三角形有所关联，那么顶点的法线就是它相邻面的面法线求个平均（加一下三角形面积的权）<br>逐像素的像素法线怎么算？<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-16-27-29.png" alt><br>结论：知道两个顶点的法线，怎么插值出像素的法线呢？这里要用到重心坐标</li></ol><h5 id="Graphics-Pipeline"><a href="#Graphics-Pipeline" class="headerlink" title="Graphics Pipeline"></a>Graphics Pipeline</h5><blockquote><p>已知：</p><ol><li>着色模型</li><li>着色模型怎么用</li><li>三维模型</li><li>不同的光照条件<br>求：<br>渲染结果。  </li></ol></blockquote><p>这种从三维场景到一张图片中间的过程叫做渲染的图形管线（老说法）现在叫做实时渲染管线。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-17-01-12.png" alt></p><ol><li>Application 应用阶段： 输入一堆空间中的点（3D 空间）</li><li>Vertex Processing 阶段： 把顶点变换到屏幕空间</li><li>Triangle Processing 阶段： 在屏幕空间中形成三角形</li><li>Rasterization 阶段： 通过光栅化离散成屏幕上的像素（fragment类比与像素）</li><li>Fragment Processing 阶段： 判断像素或者fragment是否可见 </li><li>Framebuffer Operations 阶段： 对fragment进行着色求出所有的像素</li><li>Display 阶段： 得到一张二维的图片<br>这些操作都是在显卡上进行的。</li></ol><p>之前都是在说把三维空间中的三角形投影到屏幕上，这里为啥说把三维空间中的点投影到屏幕上在连成三角形呢？<br>这个问题是因为我们如何定义空间中的模型？<br>我们可以定义所有三角形的顶点，然后定义哪三个顶点会形成三角形。<br>这样点投影完之后形成三角形，就跟直接三角形投影就没有区别了。</p><p>例子：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-22-24-18.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-22-25-09.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-22-25-21.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-22-25-42.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-22-25-52.png" alt></p><ol><li>MVP变换，对每一个顶点</li><li>对应的三个顶点连接成三角形</li><li>光栅化</li><li>判断像素或者fragment是否可见</li><li>这里根据 着色频率不同会产生差异<ul><li>如果着色频率是Gouraud shading（每个顶点进行着色），着色会发生在vertex processing顶点阶段,Fragment Processing 阶段插值</li><li>如果着色频率是Phong shading（每个像素进行着色）, 就是在Fragment processing 像素或者Fragment阶段</li></ul></li><li>纹理映射稍后说</li></ol><h5 id="shader概念完善"><a href="#shader概念完善" class="headerlink" title="shader概念完善"></a>shader概念完善</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-23-28-48.png" alt><br><strong>在现在的GPU渲染管线里面有些部分是允许编程的（顶点阶段和像素阶段），这个阶段决定像素和顶点如何运作，也就是shader。</strong><br>shader 的功能是顶点和像素的着色<br>shader 是指能在硬件上执行的语言<br>shader 是通用的 每一个 顶点（或者fragment 或者像素 ）都会执行一次，<strong>不用for循环</strong><br>如果写的是顶点shader 这个shader就叫做 vertex shader ， 如果写的是像素或者片段shader就叫做fragment shader 或者pixel shader  </p><p>对于一个像素或者顶点shader，它需要完成这个像素/顶点最后的颜色是什么，要写清楚怎么样算，然后把它输出出去，这就是一个着色的过程。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D myTexture; <span class="comment">//uniform指的是 全局变量 纹理</span></span><br><span class="line">uniform vec3 lightDir; <span class="comment">//全局变量 关照方向</span></span><br><span class="line"></span><br><span class="line">varying vec2 uv; <span class="comment">//忽略uv</span></span><br><span class="line">varying vec3 norm; <span class="comment">//插值出来像素的法线 opengl下不用管有顶点法线方向，它会自动插值出每个像素法线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">diffuseShader</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> vec3 kd;  </span><br><span class="line"> kd = texture2d(myTexture, uv);  <span class="comment">//漫反射系数</span></span><br><span class="line"> kd *= clamp(dot(–lightDir, norm), <span class="number">0.0</span>, <span class="number">1.0</span>);  <span class="comment">//认为入射向量朝内，所以有负号，这里就是求了L和N的点积，然后限制到0，1</span></span><br><span class="line"> gl_FragColor = vec4(kd, <span class="number">1.0</span>);  <span class="comment">//固定的值 表示这个像素颜色是什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-04-23-45-41.png" alt></p><h5 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-05-23-21-39.png" alt><br>如果只考虑球的着色，两个点光源的着色效果加起来就可以了，<br>但是有贴图的话其实就是物体每一个点的漫反射系数（点的属性）发生改变。<br>接下来的问题就是怎么定义一个点的属性呢？<br>首先如果要定义一个点属性，就需要知道这个点在哪里，在这里当然是在物体表面。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-05-23-34-14.png" alt><br>以上证明了任何一个三维物体的表面都是二维的。<br>例子：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-05-23-36-59.png" alt><br>怎么把几何上的所有三角形毫无拉伸（大的三角形还是大的，小的还是小的）无缝衔接的放到二维上面，是一个研究方向叫做Paremter Geomerty （几何参数化）<br>怎么把一个空间中的三角形映射到二维图片上？不是图形学范畴，这里认为已经有了这样一个映射关系。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-05-23-55-56.png" alt><br>任何一个三维空间中的点已经有了二维纹理上的坐标（UV）<br>U在0，1，V也在0,1，约定俗成。<br>不同的三维位置可以映射到相同的二维纹理上，但是为什么会没有接缝呢？<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-00-04-55.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-00-05-28.png" alt><br>当然是因为tiling贴图啊！！</p><p>下一个问题是，我如果知道三角形三个顶点对应的纹理坐标，那我如何知道三角形内部任意一个点对应的纹理坐标？<br>这里还是使用插值算法。<br>我如果已经知道三角形三个顶点有各自不同的属性，那么我如何把这个属性在三角形内部做一个平滑的过度，给我任何一个三角形内部的点，我都可以知道对应的属性插值之后的值。<br>这里用到了重心算法，下节讲。<br>纹理和着色的关系：<br>纹理是定义着色的时候需要的各个不同点的属性。也就是不希望着色的时候每个点都以相同的方式来着色，然后我就用纹理方式改变一些逐点的属性。<br>着色和材质有什么区别：<br>不同的材质就是不同的着色方法。</p><h2 id="第九节"><a href="#第九节" class="headerlink" title="第九节"></a>第九节</h2><h5 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-09-52-08.png" alt><br>着色的主要内容</p><ol><li><p>学习了着色模型，特别是Blinn phong，还手推了Blinn Phong着色模型,包括三个不同的项，高光项、漫反射项和环境光项，然后把三个项都合在一起就得到了一个材质，结论是我们如何去定义物体的表面与光线如何在物体表面作用，我们就可以得到某一种外观，最重要的是光线如何与材质如何作用。</p></li><li><p>学习了着色可以应用到不同的地方，应用在面上就是flat shading、应用在顶点上就是Gouraud shading、应用在像素上就是phong shading。这中间都涉及到大量的插值，如果是Gouraud shading，我们可以算出三角形三个顶点的着色结果，并且要在三角形内做插值，如果是phong shading，我们需要三角形三个顶点的法线方向然后对三角形内部的顶点做插值算出来任意像素的法线方向，然后shading。</p></li><li><p>学习了在硬件中是如何实现的，整个一套渲染管线，最重要的顶点的处理和 像素的处理。这两个都是可以编程的，如果是对顶点进行编程就是vertex shader，如果是对像素就是 fragment shader 或者 pixel shader。</p></li><li><p>学习了简单的纹理映射的知识，把三维空间中实际是二维的物理表面贴上一张图，提到了物体表面上各个不同的位置如何去映射到不同的二维空间（实际上是提前得到的）。</p></li></ol><h5 id="插值之前要明确的"><a href="#插值之前要明确的" class="headerlink" title="插值之前要明确的"></a>插值之前要明确的</h5><p>为了学会如何在三角形内部进行不同属性的插值，我们需要学习重心坐标。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-10-27-11.png" alt><br>在学习之前这些问题需要搞明白：</p><ol><li>我们为什么要在三角形内部进行插值？<br>我们为了完成着色，很多内容是在三角形顶点上进行定义和计算的，在三角形内部任何一个点也想获得一个值，如果每个点的值都知道也就是得到从一个点过度到另外一个点的平滑的过度。</li><li>我们插值什么内容？<br>定义在顶点上有各种各样不同的属性，比如纹理（之前定义了三个顶点分别映射到纹理上面哪三个坐标，那三角形内部映射到哪里呢？）颜色（三个顶点分别是红绿蓝，那么在三角形内部是怎么样的过度？），法线（三个顶点的法线插值出三角形内部像素的法线）<br>基本上来说可以对三角形顶点上任意的值进行插值。</li><li>怎么做插值？<br>用重心坐标做插值。<h5 id="Barycentric-Coordinate-重心坐标"><a href="#Barycentric-Coordinate-重心坐标" class="headerlink" title="Barycentric Coordinate 重心坐标"></a>Barycentric Coordinate 重心坐标</h5><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-11-41-25.png" alt><br>重心坐标：</li><li>定义在一个三角形上的,换了三角形重心坐标就变了</li><li>在三角形ABC所形成的平面内，任何一个点（x，y）都可以表示成三个顶点abc的线性组合（x，y） = αA+βB+γC （ABC指的都是坐标），线性组合的系数要满足a+b+r =1</li><li>给我任意三个点ABC，不管ABC是在什么坐标系里面表示三角形，只要有一个点在ABC所在的平面上，我都可以通过α+β+γ=1这三个数做一个线性的平均，然后得到这个任意点在重心坐标下的表示。</li><li>实际上由于α+β+γ=1这个关系，其实知道两个数就知道了第三个数。</li><li>如果这个点在三角形内，这三个系数不为负，如果有某一个以上的数为负但同时满足α+β+γ=1，就证明这个点在三角形所在平面但是不在三角形内。</li></ol><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-14-50-26.png" alt><br>A点自己的重心坐标是什么呢？<br>（α，β，γ）=（1，0，0）<br>(x,y) = αA+βB+γC</p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-15-13-35.png" alt></p><p>为什么α+β+γ=1呢？<br>这个是重心坐标规定的事情，如果加起来不等于就证明这个这个点不在三角形所在的平面内，这个相对复杂，不多解释，拿来用即可。<br>结论： α+β+γ=1限制了你所要的点在三角形所在的平面内。  </p><p>从重心坐标的定义我们已经知道了ABC三个点的坐标是什么。<br>那如果要求任意一个点的重心坐标是什么呢？这里重心坐标给出了另外一个定义：<br>任意点的重心坐标其实是可以通过面积比求出来。<br>面积比指的是 对面的三角形面积比整个三角形面积。<br>例如，我要求α的值，就是求点A对面的AA三角形面积比上三角形总面积的值。<br>从这个定义我们就知道了如果已知三角形三个点，那么可以非常轻松的得到三角形的重心坐标（就是把三角形均匀分成三个等面积的三角形的点）。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-15-19-01.png" alt><br>对于任意的一个点我们怎么计算呢？</p><ol><li>利用面积算</li><li>简化版本<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-16-05-49.png" alt></li></ol><h5 id="使用重心坐标"><a href="#使用重心坐标" class="headerlink" title="使用重心坐标"></a>使用重心坐标</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-16-07-08.png" alt><br>用重心坐标做任意一个三角形内部的点的插值<br>已知三角形内部任意点都可以用αA+βB+γC来表示，那么如果要插值某个属性，那么其也可以用线性坐标给组合起来。<br>例如，已知V的表示方法，那么把对应VA，VB，VC换成 ABC的属性值（颜色，坐标，法线，深度，材质属性）就是这个点的插值出来的属性值。</p><p>注意：经过投影，三角形三个点坐标发生变换，重心坐标会改变。<br>这个事情告诉我们要插值三维空间中的属性，就要用三维空间内的坐标，不能在投影之后的三角形坐标上做.<br>深度的问题：光栅化之后三角形已经投影到屏幕上了，会覆盖很多像素，像素都有中心，像素这些中心的这些点，我可以知道它投影了的三角形的哪里，在投影了的三角形做深度的插值是不对的。<br>应该找到像素中心点对应的三角形在三维空间的位置，在三维空间中做插值以三维空间的坐标做深度插值，然后再换回来。<br>怎么样把投影到屏幕上的在投影回去，应用逆变换即可。</p><h5 id="Texture-Magnification-如果纹理很小怎么办"><a href="#Texture-Magnification-如果纹理很小怎么办" class="headerlink" title="Texture Magnification 如果纹理很小怎么办"></a>Texture Magnification 如果纹理很小怎么办</h5><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-16-36-18.png" alt><br>屏幕上不管是像素还是用了MSAA有一个采样点，肯定有一个位置，有了这个位置我们可以插值出来这个位置的在UV空间上的纹理坐标。有了这个坐标去纹理纹理空间查询一下它的值，然后把这个值应用到漫反射系数上，就等于是把这张图给贴在了物体上。<br>但是这样会带来几个问题:</p><ol><li>Texture Magnification 纹理的放大<br>如果这个纹理太小怎么办？<br>比如一个很大面积的墙，给一张很小的贴图。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-21-34-27.png" alt><br>那我们模型上任意一个点我都可以找到对应的纹理空间位置，然后这个位置可能不是一个整数（也就是对应的不是一个整像素），那我们就把他四舍五入成整像素，相当于在一定的范围内查找一个相同的<strong>纹理上的像素</strong>（texel纹理元素 纹素），<br>pixel：生成的画面上的一个像素<br>texel：纹理上的一个像素<br>因为纹理太小，如果做简单的四舍五入，那么一个3<em>3 或者5</em>5的pixel像素范围可能会被映射到一个texel像素上，例如Nearest。<br>如果希望结果是模糊一点，那如果在查询纹理的时候你给我一个非整数的坐标，那应该如何得到它的值呢？<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-22-25-13.png" alt><br>Bilinear 双线性插值：<br>如图，每个格子是一个像素，每个黑点是像素中心，如果pixel采样到红点位置，如果是Nearest算法就是返回一个那个像素的颜色，如果是Bilinear 双线性插值算法就是如果不是刚刚好落在一个像素上，就做以下操作：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-22-35-55.png" alt><br>首先是拿到临近四个Texel纹素的值，然后投影出来s和t的值（s和t必小于1，因为纹理空间一个像素的距离是1，不到一个像素就是肯定小于1）<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-22-38-06.png" alt><br>然后做一下线性插值Linear interpolation。<br>线性插值：有两个不同的值，定义在两个不同的位置上。如果有X是0到1，如果认为X等于0的时候在一个位置上，x等于1的时候在另一个位置上，那么求x等于0.5的时候在哪？肯定在这两个位置的中间。以此类推，这就是线性插值，简称Lerp.<br>Lerp(X，v0，v1) 等于线性插值v0和v1，分别定义在位置0和位置1上，x是一个0到1之间的值，x = 0的时候，右边的值等于v0，x = 1的时候，右边的值等于v1，x = 0.5的时候，右边的值正好等于两者中间。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-22-50-08.png" alt><br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-23-12-23.png" alt><br>用线性插值，可以算出u0在两个像素（u00和u10）中间的颜色，同样道理可以算出u1在两个像素（u01和u11）中间的颜色，同样道理在做一下垂直的插值就可以算出来红点出的颜色了。现在这个点的颜色就综合考虑了它周围四个<br>点的颜色了（等于加了权重）。因为做了两次线性插值（水平和垂直）就叫做双线性插值。<br>注意，这里水平或者垂直先后顺序相互没有影响。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-23-42-08.png" alt><br>缺点，跟Bicubic双向三次的算法质量比还是差一些。<br>Bicubic:取周围16个像素，也是做水平和垂直插值，每次用四个做一个三次插值（不是线性），运算量大，效果更好。<h5 id="Texture-Magnification-如果纹理很大怎么办"><a href="#Texture-Magnification-如果纹理很大怎么办" class="headerlink" title="Texture Magnification 如果纹理很大怎么办"></a>Texture Magnification 如果纹理很大怎么办</h5>纹理大了会引起更大的问题。如图：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-06-23-49-51.png" alt><br>如果简单的应用纹理（像素中心找到纹理坐标，求出纹理上的值，已经学了插值所以任意的纹理的值都知道），就会得到上图右边的效果。  </li></ol><ul><li><p>为什么会出现这个问题？<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-07-16-17-01.png" alt><br>首先近处的一个像素覆盖的纹理范围是相对较小，如上图左边方块，在远处，一个像素覆盖了很大的纹理。<br>这个情况告诉我们，屏幕上的像素覆盖纹理的大小是各不相同的。<br>那么对于一个像素，如果它覆盖的纹理范围很小，那通过像素中心的纹理坐标查询一下它纹理空间的纹理对应值，没有问题，但是如果一个像素覆盖了很大的纹理范围，那我通过这个纹理的中心（蓝点）拿到对应的纹理坐标一个纹理像素的值，就会产生错误，因为一个纹理像素代表不了一个范围。  </p></li><li><p>如何解决？<br>MSAA或者超采样，都差不多一个概念，<br>一个像素用更多的样本去采样纹理空间，如果每个像素用512个采样点，把这点对应的纹理空间值平均一下。就会得到下面的结果。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-07-16-29-45.png" alt></p></li></ul><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-07-16-34-25.png" alt><br>走样的问题：信号变换过快，采样速度（频率）跟不上。<br>当像素采样的时候，因为对应的纹理大，就是每一块纹素小，很多块纹素包含在同一个像素中，这些纹素颜色都是不相同的，变化频率高，而采样频率低，当然就会走样。如果要不走样就需要提高采样频率。但是造成速度慢。<br>另外的思路：<br>如果不想走样，就不采样。<br>我们可以直接拿到像素对应纹素范围的平均值。<br>经典问题：点查询问题，和范围查询问题。多个领域都有应用。<br>说白了就是一张图，指定任意范围，能不能快速返回平均值给我。</p><p><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-07-16-51-19.png" alt><br>如图，同一个像素对应不同的纹素范围。</p><ul><li>Mipmap<br>Mipmap 允许快速的、大约的、正方形的范围查询。又叫图像金字塔。<br>什么叫Mipmap：从一张图生成一系列图。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-07-16-57-05.png" alt><br>这里为了显示，所以拉大了图片.<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-07-17-00-21.png" alt><br>可以产生log2（图片像素）个mipmap，生成的mipmap占用了1/3原始图片的大小。</li></ul><p>怎么知道要查询的区域有多大？<br>近似的办法：任何一个像素都可以映射到纹理，如图：红蓝点分布对应<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-14-34-54.png" alt><br>在Pixel 上距离为1的像素，对应到Texel上的距离是可以求出来的。如图：<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-14-39-31.png" alt><br>du和dv是纹理空间的两个像素采样点的距离，dx和dy表示pixel空间距离。<br>max（横向两个像素对应纹理实际空间长度，竖向两个像素对应纹理实际空间长度）。<br>然后近似营造一个正方形空间。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-15-31-49.png" alt><br>当我们可以把一个像素覆盖的区域，近似成正方形算出来之后，就是如何根据预计算好的Mip查询这个边长是L的正方形平均值是多少。<br>举个例子，如果这个L是4，那么我们就知道它肯定在第二层mipmap的时候变成一个像素。<br>也就是说根据这个区域，可以求出它在第几层会变成一个像素的大小，然后直接查询那个mipmap的像素的值就好了。</p><p>总结，通过计算一个pixel映射的texel近似范围，可以求出这个范围在第几层mip map是一个像素，然后拿到这个像素的值。拿空间换时间的技术。<br>近大：使用底层mipmap纹理，远小：使用高层纹理mipmap对应。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-18-17-52.png" alt><br>变换不连续，只算了整数层的mipmap效果。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-18-31-36.png" alt><br>三线性插值：为了避免出现这样的结果，可以利用插值求出非整数层。<br>比如1.8层，我们可以先找第一层做对应范围双线性插值，再找第二层做对应范围双线性插值，然后把这个结果当做层与层直接在做一次线性插值。这样我们利用三线性插值可以在任意的浮点数位置求出对应的平滑的像素数值，而且在层与层也可以求出平滑的像素数值。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-19-34-33.png" alt></p><p>MipMap能完全解决问题吗？<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-19-41-46.png" alt><br>如图，mipmap跟超采样对比。<br>mipmap远处会出现过度的模糊（overblur）。主要因为采样的毕竟是近似的正方形。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-19-48-55.png" alt><br>各向异性过滤比mimmap效果要好。<br>什么叫各向异性:在不同的方向上它的表现各不相同，考虑各个方向，之前认为在水平和竖直上完全相同（各向同性）。<br>为什么会这样呢？<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-20-18-18.png" alt><br>屏幕上的像素映射到纹理上，很有可能会出现超级狭长的斜着的范围，把它近似的算成一个框，那就会求很大的一个范围的平均值，必然就overblur，<br>各向异性允许我们在一个<strong>矩形</strong>范围内快速查询，自然得到的结果就会好很多，但注意还是近似。各向异性开销是MipMap的三倍。<br>各向异性在游戏引擎中一般还有选项X，2X就是横向竖向压缩两倍，以此类推。<br>存储量随着X的上升会逐渐达到3倍。也就是跟计算力没有关系，主要跟显存的大小有关系，如果显存足够，可以把X开到最高。<br><img src="/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-04-08-20-22-23.png" alt><br>EWA过滤器，利用圆形多次求取值。</p><h5 id="Applications-of-texture-纹理的其他应用"><a href="#Applications-of-texture-纹理的其他应用" class="headerlink" title="Applications of texture 纹理的其他应用"></a>Applications of texture 纹理的其他应用</h5><p>以后再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第六节&quot;&gt;&lt;a href=&quot;#第六节&quot; class=&quot;headerlink&quot; title=&quot;第六节&quot;&gt;&lt;/a&gt;第六节&lt;/h2&gt;&lt;h5 id=&quot;上节课复习&quot;&gt;&lt;a href=&quot;#上节课复习&quot; class=&quot;headerlink&quot; title=&quot;上节课复习&quot;&gt;&lt;/a&gt;上节课复习&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/2020/03/24/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-6-10/2020-03-25-10-26-53.png&quot; alt&gt;&lt;br&gt;MVP（model模型变换- view跟随摄影机变换到相对（0，0，0）位置 - project 投影变换（-1，1的3次方的空间））变换之后在进行视口变换（viewport，-1，1的3次方的空间变换到分辨率空间)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="computer graphics" scheme="http://yoursite.com/tags/computer-graphics/"/>
    
  </entry>
  
  <entry>
    <title>SubstancePainter_Plugin_Study_Notes</title>
    <link href="http://yoursite.com/2020/03/14/SubstancePainter-Plugin-Study-Notes/"/>
    <id>http://yoursite.com/2020/03/14/SubstancePainter-Plugin-Study-Notes/</id>
    <published>2020-03-14T08:08:52.000Z</published>
    <updated>2020-03-17T03:14:04.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Substance-Painter-Plugin-学习笔记"><a href="#Substance-Painter-Plugin-学习笔记" class="headerlink" title="Substance Painter Plugin 学习笔记"></a>Substance Painter Plugin 学习笔记</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-13-21-25-23.png" alt></p><a id="more"></a><h2 id="需要了解学习的模块"><a href="#需要了解学习的模块" class="headerlink" title="需要了解学习的模块"></a>需要了解学习的模块</h2><h3 id="Qml文件"><a href="#Qml文件" class="headerlink" title="Qml文件"></a>Qml文件</h3><p>文档： Substance Painter打开 Help-Docmentation-Scripting API<br><a href="https://doc.qt.io/qt-5/qtquick-index.html" target="_blank" rel="noopener">UI</a></p><h4 id="插件骨骼"><a href="#插件骨骼" class="headerlink" title="插件骨骼"></a>插件骨骼</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin &#123;</span><br><span class="line">        <span class="comment">// starts a timer that will trigger the 'onTick' callback at regular interval</span></span><br><span class="line">        <span class="comment">// 启动一个计时器，该计时器将定期触发“ on tick”回调</span></span><br><span class="line">        tickIntervalMS: <span class="number">-1</span> <span class="comment">// -1 禁用（默认值）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// starts a JSON server on the given port:</span></span><br><span class="line">        <span class="comment">// 在给定的端口上启动json服务器</span></span><br><span class="line">        <span class="comment">// you send javascript that will be evaluated and you get the result in JSON format</span></span><br><span class="line">        <span class="comment">//您发送将被评估的javascript，并以json格式获取结果</span></span><br><span class="line">        jsonServerPort: <span class="number">-1</span> <span class="comment">// -1 禁用（默认值）</span></span><br><span class="line"></span><br><span class="line">        Component.onCompleted: &#123;</span><br><span class="line">                <span class="comment">// Called after the object has been instantiated.</span></span><br><span class="line">                <span class="comment">// 在实例化对象之后调用。</span></span><br><span class="line">                <span class="comment">// This can be used to execute script code at startup,</span></span><br><span class="line">                <span class="comment">// 可用于在启动时执行脚本代码，</span></span><br><span class="line">                <span class="comment">// once the full QML environment has been established.</span></span><br><span class="line">                <span class="comment">// 现已建立完整的qml环境</span></span><br><span class="line">                alg.log.info(<span class="string">"Component.onCompleted"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onTick: &#123;</span><br><span class="line">                <span class="comment">// Do something at each tick, depending on tickIntervalMS value</span></span><br><span class="line">                <span class="comment">// 在每个滴答声中有一些东西，具体取决于滴答间隔ms值</span></span><br><span class="line">                alg.log.info(<span class="string">"onTick"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onConfigure: &#123;</span><br><span class="line">                <span class="comment">// Do something when the user request the plugin configuration panel</span></span><br><span class="line">                <span class="comment">// 当用户请求插件配置面板时执行某些操作</span></span><br><span class="line">                alg.log.info(<span class="string">"onConfigure"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onApplicationStarted: &#123;</span><br><span class="line">                <span class="comment">// Called when the application is started</span></span><br><span class="line">                <span class="comment">// 启动应用程序时调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onApplicationStarted"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onNewProjectCreated: &#123;</span><br><span class="line">                <span class="comment">// Called when a new project is created, before the onProjectOpened callback</span></span><br><span class="line">                <span class="comment">// 在创建新项目时调用，在on project打开回调之前调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onNewProjectCreated"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onProjectOpened: &#123;</span><br><span class="line">                <span class="comment">// Called when the project is fully loaded</span></span><br><span class="line">                <span class="comment">// 在项目完全加载时调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onProjectOpened"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onProjectAboutToClose: &#123;</span><br><span class="line">                <span class="comment">// Called before project unload</span></span><br><span class="line">                <span class="comment">// 在项目卸载之前调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onProjectAboutToClose"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onProjectAboutToSave: <span class="function"><span class="keyword">function</span>(<span class="params">destinationUrl</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Called before a save, 'destination_url' parameter contains the save destination</span></span><br><span class="line">                <span class="comment">// 在保存之前调用，“目标网址”参数包含保存目标</span></span><br><span class="line">                alg.log.info(<span class="string">"onProjectAboutToSave: "</span>+destinationUrl)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onProjectSaved: &#123;</span><br><span class="line">                <span class="comment">// Called after the project was saved</span></span><br><span class="line">                <span class="comment">// 项目保存后调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onProjectSaved"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onComputationStatusChanged: <span class="function"><span class="keyword">function</span>(<span class="params">isComputing</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Called when the state of the engine computing stacks content change.</span></span><br><span class="line">                <span class="comment">// 当引擎计算堆栈的状态更改内容时调用。</span></span><br><span class="line">                <span class="comment">// If the stack content is computed, 'isComputing' parameter will be false</span></span><br><span class="line">                <span class="comment">// 如果计算堆栈内容，则“正在计算”参数为false</span></span><br><span class="line">                alg.log.info(<span class="string">"onComputationStatusChanged: "</span>+isComputing)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onExportAboutToStart: <span class="function"><span class="keyword">function</span>(<span class="params">maps</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Called just before the export process starts.</span></span><br><span class="line">                <span class="comment">// 在导出过程开始之前调用。</span></span><br><span class="line">                <span class="comment">// 'maps' is the list of filepaths expected to be written.</span></span><br><span class="line">                <span class="comment">// “映射”是预期要写入的文件路径的列表。</span></span><br><span class="line">                alg.log.info(<span class="string">"onExportAboutToStart: "</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> stackName <span class="keyword">in</span> maps) &#123;</span><br><span class="line">                    alg.log.info(stackName);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> filePath <span class="keyword">in</span> maps[stackName]) &#123;</span><br><span class="line">                        alg.log.info(maps[stackName][filePath]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Example:</span></span><br><span class="line">                <span class="comment">// Open the 'PreviewSphere' sample, set 'C:/tmp' as export path, choose 'png' as export</span></span><br><span class="line">                <span class="comment">// 打开“预览球”示例，将“ c：/ tmp”设置为导出路径，选择“ png”作为导出</span></span><br><span class="line">                <span class="comment">// format and select the 'PBR MetalRough' config, the example above will output:</span></span><br><span class="line">                <span class="comment">// 格式化并选择“ pbr metal raw”配置，以上示例将输出：</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// onExportAboutToStart:</span></span><br><span class="line">                <span class="comment">// Sphere</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_BaseColor.png</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_Roughness.png</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_Metallic.png</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_Normal.png</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_Height.png</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Please note the 'Opacity' and 'Emissive' maps are not listed here because they</span></span><br><span class="line">                <span class="comment">// 请注意，此处未列出“不透明”和“发射”地图，因为它们</span></span><br><span class="line">                <span class="comment">// can not be exported with this sample while the actual export will warn about it.</span></span><br><span class="line">                <span class="comment">// 不能与该样品一起出口，但实际出口会发出警告。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onExportFinished: <span class="function"><span class="keyword">function</span>(<span class="params">status, maps</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Called right after the export process ends.</span></span><br><span class="line">                <span class="comment">// 在导出过程结束后立即调用</span></span><br><span class="line">                <span class="comment">// 'status' is the error status returned by the process. Available values are:</span></span><br><span class="line">                <span class="comment">// “状态”是进程返回的错误状态。,可用值为：</span></span><br><span class="line">                <span class="comment">// - Export.Status_Ok</span></span><br><span class="line">                <span class="comment">// - Export.Status_Warn</span></span><br><span class="line">                <span class="comment">// - Export.Status_Error</span></span><br><span class="line">                <span class="comment">// - Export.Status_Canceled</span></span><br><span class="line">                <span class="comment">// 'maps' is the list of filepaths effectively exported.</span></span><br><span class="line">                <span class="comment">// “映射”是有效导出的文件路径的列表。</span></span><br><span class="line">                alg.log.info(<span class="string">"onExportFinished: "</span>)</span><br><span class="line">                <span class="keyword">if</span> (status != Export.Status_Ok) &#123;</span><br><span class="line">                    alg.log.error(<span class="string">"Export failed."</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> stackName <span class="keyword">in</span> maps) &#123;</span><br><span class="line">                        alg.log.info(stackName);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> filePath <span class="keyword">in</span> maps[stackName]) &#123;</span><br><span class="line">                            alg.log.info(maps[stackName][filePath]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Plugin meta data:<br>Information about the plugin can be provided by creating a plugin.json file in the plugin directory. Available properties are:<br>可以通过在plugin目录中创建一个plugin.json文件来提供有关该插件的信息。,可用属性为：<br>description: plugin description, displayed in the plugin about dialog.<br>url: project homepage, displayed in the plugin about dialog. Warning, the scheme is mandatory to create a clickable link.<br>version: plugin version.<br>license: plugin license.<br>min_api_version: required minimal scripting API version.<br>Example:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">"description"</span>: <span class="string">"This is a sample plugin"</span>,</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"https://www.allegorithmic.com"</span>,</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">        <span class="string">"license"</span>: <span class="string">"&lt;a href=\"https://opensource.org/licenses/MIT\"&gt;MIT&lt;/a&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="定制UI"><a href="#定制UI" class="headerlink" title="定制UI"></a>定制UI</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin &#123;</span><br><span class="line">        <span class="comment">// 在实例化对象之后调用。</span></span><br><span class="line">        <span class="comment">// 可用于在启动时执行脚本代码，</span></span><br><span class="line">        <span class="comment">// 建立环境</span></span><br><span class="line">        Component.onCompleted: &#123;</span><br><span class="line">                <span class="comment">// 创建一个toolbar 按钮</span></span><br><span class="line">                <span class="keyword">var</span> t = alg.ui.addToolBarWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">                t.rectangle.color = <span class="string">"blue"</span></span><br><span class="line">                t = alg.ui.addToolBarWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">                t.rectangle.color = <span class="string">"green"</span></span><br><span class="line">                t = alg.ui.addToolBarWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">                t.rectangle.color = <span class="string">"yellow"</span></span><br><span class="line">                t = alg.ui.addToolBarWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">                t.rectangle.color = <span class="string">"purple"</span></span><br><span class="line">                <span class="comment">// 创建停靠小部件</span></span><br><span class="line">                alg.ui.addDockWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.3</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">Item &#123;</span><br><span class="line">        width: <span class="number">24</span></span><br><span class="line">        height: <span class="number">24</span></span><br><span class="line">        objectName: <span class="string">"My plugin UI"</span></span><br><span class="line">        property alias rectangle: rect</span><br><span class="line"></span><br><span class="line">        Rectangle &#123;</span><br><span class="line">                id: rect</span><br><span class="line">                anchors.fill: parent</span><br><span class="line">                color: <span class="string">"red"</span></span><br><span class="line">                MouseArea &#123;</span><br><span class="line">                        id: mouseArea</span><br><span class="line">                        anchors.fill: parent</span><br><span class="line">                        onClicked: &#123;</span><br><span class="line">                                <span class="keyword">var</span> ok = alg.mapexport.showExportDialog();<span class="comment">//打开导出窗口  alg是指Javascript API</span></span><br><span class="line">                                <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                                        alg.log.info(<span class="string">"Export successful!"</span>)</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        alg.log.warn(<span class="string">"Export cancelled!"</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Javascript-API"><a href="#Javascript-API" class="headerlink" title="Javascript API"></a>Javascript API</h4><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><p>substance painter  hello world 窗口</p><ul><li>首先需要有一个定义主入口点的qml文件main. </li></ul><ol><li>C:\Users\sunyuxiang\Documents\Allegorithmic\Substance Painter\plugins</li><li>在此处创建一个名为“ HelloPlugin”的文件夹 </li><li>在插件内，创建两个文件  <pre><code>* plugin.json * main.qml </code></pre></li><li>打开main.qml文件写入</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin </span><br><span class="line">&#123;</span><br><span class="line">        Component.onCompleted: </span><br><span class="line">        &#123;</span><br><span class="line">                alg.log.info(<span class="string">"hello world!"</span>)<span class="comment">//注意这里，alg.log.info()等于python里面的print()</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>填写JSON文件：</li></ul><ol><li>JSON文件包含插件的元数据，在这里显示.<br><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-06-10-45-09.png" alt><br><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-06-10-43-52.png" alt></li><li>我们知道json文件是键值对,观察一下现有插件的json文件,然后修改一后面的值改为.<br><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-06-10-47-53.png" alt></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"This is a sample plugin to print hello world"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"https://test"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="string">"license"</span>: <span class="string">"&lt;a href=\"https://opensource.org/licenses/MIT\"&gt;MIT&lt;/a&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后打开substance painter</li></ul><ol><li>可以看到log文件已经打印出了hello world<br><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-06-10-56-41.png" alt></li><li>plugins下的对应插件名字下面的about也可以正常工作</li><li>现在 我们可以看到插件的加载，还可以看到plugin.json文件的关于窗口信息.</li></ol><ul><li>添加一个窗口</li></ul><ol><li>在我们的HelloPlugin目录中创建一个HelloWorldWindow.qml.</li><li>编辑文件，添加代码来定义一个简单的窗口。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import AlgWidgets 1.0 &#x2F;&#x2F;窗口类导入</span><br><span class="line"></span><br><span class="line">AlgWindow</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 属性就像对象类型上的变量</span><br><span class="line">    id: window&#x2F;&#x2F;对应 main.qml的id 这个id很有用，因为它允许我们在插件的其他位置引用该对象，访问其可见性之类的属性。  </span><br><span class="line">    title: &quot;hello world window&quot;</span><br><span class="line">    visible: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在，我们有一个简单的窗口，但是在看到窗口之前，我们需要在main.qml文件中实例化它。 </li></ul><ol><li>编辑main.qml<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin </span><br><span class="line">&#123;       </span><br><span class="line">        HelloWorldWindow<span class="comment">// 在这里声明一个window，HelloWorldWindow指向HelloWorldWindow.qml</span></span><br><span class="line">        &#123;</span><br><span class="line">                id: <span class="built_in">window</span><span class="comment">//对应 HelloWorldWindow.qml的id</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Component.onCompleted: </span><br><span class="line">        &#123;</span><br><span class="line">                alg.log.info(<span class="string">"hello world!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>现在打开substance painter 禁用插件在启用插件就会看到该窗口弹出，这是因为在加载插件时首先实例化该窗口（？），我们稍后将解决此问题。 </li></ol><ul><li>创建一个按钮：</li></ul><ol><li>接下来创建一个按钮来替代禁用/启用</li><li>打开“ HelloWorldWindow.qml”文件。</li><li>我们将添加三件事： <pre><code>* 一系列的布局元素。 * 一个标签。 * 一个按钮</code></pre></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AlgWidgets <span class="number">1.0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这些模块是UI布局需要的</span></span><br><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.7</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.3</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"."</span></span><br><span class="line"></span><br><span class="line">AlgWindow</span><br><span class="line">&#123;</span><br><span class="line">    id: <span class="built_in">window</span><span class="comment">//对应 main.qml的id</span></span><br><span class="line">    title: <span class="string">"hello world window"</span></span><br><span class="line">    visible: <span class="literal">true</span><span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">    ColumnLayout <span class="comment">//也可以用 RowLayout这里定义了一系列的布局元素 </span></span><br><span class="line">    &#123;</span><br><span class="line">        id: horizontalLayout</span><br><span class="line">        anchors.fill: parent</span><br><span class="line"></span><br><span class="line">        Rectangle <span class="comment">//这里定义了一系列的布局元素 </span></span><br><span class="line">        &#123;</span><br><span class="line">            id: buttonBar</span><br><span class="line">            anchors.left: parent.left</span><br><span class="line">            anchors.right: parent.right</span><br><span class="line"></span><br><span class="line">            ColumnLayout<span class="comment">//也可以用 RowLayout这里定义了一系列的布局元素 </span></span><br><span class="line">            &#123;</span><br><span class="line">                anchors.fill:parent</span><br><span class="line"></span><br><span class="line">                AlgLabel<span class="comment">//一个标签</span></span><br><span class="line">                &#123;</span><br><span class="line">                    id: buttonLabel</span><br><span class="line">                    font.pixelSize: <span class="number">14</span></span><br><span class="line">                    font.bold: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">                    text: <span class="string">"Press Me"</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                AlgButton<span class="comment">//一个按钮</span></span><br><span class="line">                &#123;</span><br><span class="line">                    text: <span class="string">"Say Hello!"</span></span><br><span class="line">                    <span class="comment">//Layout.preferredWidth: Style.widgets.buttonWidth</span></span><br><span class="line"></span><br><span class="line">                    onClicked:</span><br><span class="line">                    &#123;</span><br><span class="line">                        alg.log.info(<span class="string">"hello World"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. QML窗口是使用一系列嵌套的布局对象创建的-为了达到我们的目的，我们将使用列，矩形和行。 2. 我们需要添加其他导入语句来访问这些对象类型-QtQuick和QtQuick.Layouts。3. 该列表示总体布局-元素将按照添加顺序堆叠在此形状中。 4. 矩形允许我们使用子布局填充此列的分区。 5. 最后，行布局允许我们添加将按照添加顺序从左到右呈现的元素。 6. 在行布局中添加AlgLabel和AlgButton将两个新元素添加到我们的窗口中。 7. 最后，为按钮定义“ onClicked”事件将替换启动时登录main.qml的位置。 </code></pre><ul><li><p>重新加载脚本：<br>可以使用painter中的Plugins-&gt; HelloPlugin-&gt; Reload  菜单即时重新加载脚本。在后面debug和尝试过程中这个超级有用，避免了我们要重新开关软件。</p></li><li><p>将插件添加到工具栏：</p></li></ul><ol><li>现在如果关闭插件窗口，则必须通过reload插件才能再次打开插件窗口。 </li><li>让我们在工具栏上添加一个按钮，来替代每次reload调用窗口。</li><li>工具栏中的按钮将非常简单，要做的就是在按下插件窗口时切换可见性。 </li><li>首先，我们将通过改变visible值的true改为false,让插件窗口不会加载自动弹出。</li><li>创建一个名为“ toolbar.qml ” 的新文件，并且与我们之前所做的类似,仅一排，带有一个按钮。<br>比较重要的是-插件加载时，属性变量“ windowReference”将由我们的插件填充。<br>由于windowReference在本地以null开头，因此我们稍后将对其的调用包装在try / catch块中。<br>如果脚本中其他地方的内容使我们无法创建窗口，那么这将阻止崩溃，我们可以将信息打印到控制台。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.7</span><br><span class="line">import QtQuick.controls 2.0</span><br><span class="line">import AlgWidgets 1.0</span><br><span class="line"></span><br><span class="line">Row &#x2F;&#x2F;现在是横向的如果需要侧边的话就是AlgToolBarButton</span><br><span class="line">&#123;</span><br><span class="line">    property var windowReference : null</span><br><span class="line"></span><br><span class="line">    Button</span><br><span class="line">    &#123;</span><br><span class="line">        id: rect</span><br><span class="line">        width: 30</span><br><span class="line">        height: 30</span><br><span class="line"></span><br><span class="line">        onClicked:</span><br><span class="line">        &#123;</span><br><span class="line">            try </span><br><span class="line">            &#123;</span><br><span class="line">                windowReference.visible &#x3D; true</span><br><span class="line">            &#125;</span><br><span class="line">            catch(err) </span><br><span class="line">            &#123;</span><br><span class="line">                alg.log.exception(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>最后，在“ main.qml”文件中，我们将添加一个新的工具栏小部件，该小部件将把“ toolbar.qml”实例化为工具栏上的按钮。<br>我们还使用其ID将HelloWorldWindow实例分配给工具栏按钮中的windowReference变量。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin </span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 在这里声明一个window，HelloWorldWindow指向HelloWorldWindow.qml</span></span><br><span class="line">        HelloWorldWindow</span><br><span class="line">        &#123;</span><br><span class="line">                id: <span class="built_in">window</span><span class="comment">//对应 HelloWorldWindow.qml的id</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Component.onCompleted: </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">var</span> qmToolbar = alg.ui.addWidgetToPluginToolBar(<span class="string">"toolbar.qml"</span>)</span><br><span class="line">                qmToolbar.windowReference = <span class="built_in">window</span><span class="comment">//这里调用了window</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这就是向Substance Painter添加基本插件的小例子.</li><li>ref：<a href="http://peterhanshawart.blogspot.com/2017/11/making-hello-world-substance-painter.html" target="_blank" rel="noopener">http://peterhanshawart.blogspot.com/2017/11/making-hello-world-substance-painter.html</a></li></ul><h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">AlgWindow</span><br><span class="line">&#123;</span><br><span class="line">    Item</span><br><span class="line">    &#123;</span><br><span class="line">        Item </span><br><span class="line">        &#123;</span><br><span class="line">            Row</span><br><span class="line">            &#123;</span><br><span class="line">                Alglabel &#123;&#125;</span><br><span class="line">                AlgTextInput &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Row</span><br><span class="line">            &#123;</span><br><span class="line">                AlgComboBox &#123;&#125;</span><br><span class="line">                AlgLabel &#123;&#125;</span><br><span class="line">                AlgComboBox &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Row</span><br><span class="line">            &#123;</span><br><span class="line">                AlgCheckBox &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        GridView</span><br><span class="line">        &#123;</span><br><span class="line">            ListElement &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Item </span><br><span class="line">        &#123;</span><br><span class="line">            Row </span><br><span class="line">            &#123;</span><br><span class="line">                Rectangle &#123;&#125;</span><br><span class="line">                FileDialog &#123;&#125;</span><br><span class="line">                AlgButton &#123;&#125;</span><br><span class="line">                AlgButton &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pysbs模块"><a href="#pysbs模块" class="headerlink" title="pysbs模块"></a>pysbs模块</h3><p><a href="https://docs.substance3d.com/sat" target="_blank" rel="noopener">pysbs文档链接</a></p><p>pysbs模块介绍：pysbs是.sbs文件的Python API，pysbs提供了无需使用Substance Designer应用程序即可生成或修改物质的方法，只需使用Python编写脚本即可。</p><p>它有两个主要组件:</p><ul><li>命令行工具.这是一组命令行工具，用于烘焙网格物体的图，对物质进行简单的修改，创建物质档案并绘制图。</li><li>Pysbs-Python API，Python API是一个python软件包，用于读取和修改sbs文件，例如从多种物质组装复合材料或在文件中批量重命名节点。</li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>批量修改sbs文件的图表尺寸</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pysbs <span class="keyword">import</span> context, substance, sbsenum</span><br><span class="line"></span><br><span class="line">sbs_mtls = [] <span class="comment"># Your list of sbs files to process.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_sbs_graph_to_relative</span><span class="params">(sbs_path)</span>:</span></span><br><span class="line">    <span class="comment"># Build doc.</span></span><br><span class="line">    ctx = context.Context()</span><br><span class="line">    sbs_doc = substance.SBSDocument(ctx, sbs_path)</span><br><span class="line">    sbs_doc.parseDoc()</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># Get your graph.</span></span><br><span class="line">    graph = sbs_doc.getSBSGraphList()[<span class="number">0</span>]</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># Change the outputsize inheritance value.</span></span><br><span class="line">    <span class="comment"># Bug: The aRelativeTo argument doesn't appear to do anything.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># https://docs.substance3d.com/sat/pysbs-python-api/api-content/libraries/sbsenum</span></span><br><span class="line">    graph.setBaseParameterValue(</span><br><span class="line">        aParameter=sbsenum.CompNodeParamEnum.OUTPUT_SIZE,</span><br><span class="line">        aParamValue=[sbsenum.OutputSizeEnum.SIZE_1, sbsenum.OutputSizeEnum.SIZE_1],</span><br><span class="line">        aRelativeTo=sbsenum.ParamInheritanceEnum.PARENT</span><br><span class="line">    )</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># Save pkg.</span></span><br><span class="line">    sbs_doc.writeDoc()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span> pkg <span class="keyword">in</span> sbs_mtls:</span><br><span class="line">    set_sbs_graph_to_relative(pkg)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Substance-Painter-Plugin-学习笔记&quot;&gt;&lt;a href=&quot;#Substance-Painter-Plugin-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Substance Painter Plugin 学习笔记&quot;&gt;&lt;/a&gt;Substance Painter Plugin 学习笔记&lt;/h1&gt;&lt;h2 id=&quot;核心思路&quot;&gt;&lt;a href=&quot;#核心思路&quot; class=&quot;headerlink&quot; title=&quot;核心思路&quot;&gt;&lt;/a&gt;核心思路&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-13-21-25-23.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SubstancePainter" scheme="http://yoursite.com/tags/SubstancePainter/"/>
    
  </entry>
  
  <entry>
    <title>Blender脚本学习笔记</title>
    <link href="http://yoursite.com/2020/03/10/Blender%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/10/Blender%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-10T11:14:04.000Z</published>
    <updated>2020-03-15T14:57:22.368Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><p>安装python3.0以上(Blender 2.8是 python3.x)</p></li><li><p>Vscode 安装python 和 blender Development 插件</p></li><li><p>终端安装 fake-bpy 包<code>pip install fake-bpy-module-2.80</code></p><p> <a href="https://github.com/nutti/fake-bpy-module" target="_blank" rel="noopener">https://github.com/nutti/fake-bpy-module</a></p><p>安装完上面这些，vscode里面就会有自动补全</p><p>Debug</p></li><li><p>ctrl + shift + P, select “Blender: Start”</p></li><li><p>选择你的blender安装路径, vscode会连接到blender</p></li><li><p>ctrl + shift + P, “Blender: Run script” 并且可以使用断点调试</p> <a id="more"></a></li></ul><h3 id="插件路径"><a href="#插件路径" class="headerlink" title="插件路径"></a>插件路径</h3><ul><li><p>目录：user\AppData\Roaming\Blender Foundation\Blender\scripts\addons,代表非系统原生的用户插件,blender所有安装的外部插件都会被解压放置到这个文件夹下。</p><p>安装插件可以在blender的addon界面直接选择zip文件安装，也可以把插件文件夹直接拖入此目录。</p></li><li><p>目录：D:\blender-2.81a\2.81\scripts\addons</p><p>第二个是软件原生插件路径，不建议将自己写的插件放入此地，此地不少系统插件的代码可在以后做参考用，值得了解。</p></li></ul><h3 id="如何查看命令"><a href="#如何查看命令" class="headerlink" title="如何查看命令"></a>如何查看命令</h3><ul><li>类似maya 直接执行某个功能，看info输出命令（A+X    清空nfo）</li><li>选中命令直接 Copy Data Path.</li><li>鼠标悬停在某个命令上看提示，如果没有提示，要去perfence里面的interface下勾选Python Tooltips.</li><li>控制台直接输入<code>dir（某个模块名）</code>查看输出</li><li>打开blender的text editor，很多模板文件可供使用：</li><li>用python console中的.后代码提示快捷键自动补全查看方法（ctrl+space）</li><li>查询api</li><li>全球最大爱好者论坛<a href="https://blender.stackexchange.com/" target="_blank" rel="noopener">https://blender.stackexchange.com/</a></li><li>查看各类开源插件</li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li><p>bpy 意思是 blender python</p></li><li><p>常规得到某个物体信息流程 </p><p>1 viewport选中物体 </p><p>2 查看Transform的提示 </p><p>3 调用各种信息 类似 .location</p></li></ul><p>常用命令</p><p><code>bpy.context.</code> 正文，当前环境的所有内容的意思</p><p><code>bpy.context.object</code> 物体</p><p><code>mesh = bpy.data.objects[&quot;mesh&quot;]</code> Mesh变量存储物体mesh</p><p><code>bpy.ops.object.select_all(action=&#39;SELECT&#39;)</code>全选命令</p><p><code>bpy.ops.object.select_all(action=&#39;DESELECT&#39;)</code>全不选命令</p><p><code>bpy.context.view_layer.objects.active = mesh</code>大纲选中，激活物体</p><p><code>bpy.context.object.location</code> 拿到选中物体的世界坐标</p><p><code>bpy.context.object.location.z</code>拿到选中物体的世界坐标中的Z坐标数值</p><p><code>bpy.context.object.location.z += random()</code> 选中物体的世界坐标中的Z坐标数值随机加一个数</p><p><code>bpy.context.object.name</code>查看选中物体的名字</p><p><code>bpy.ops.object.duplicate(linked=False,mode=&#39;TRANSLATION&#39;)</code>复制模型</p><p><code>bpy.ops.object.modifier_add(type=&#39;DECIMATE&#39;)</code>添加编辑器</p><p><code>bpy.context.object.modifiers[&quot;Decimate&quot;].ratio = 0.1</code>设置编辑器参数</p><p><code>bpy.ops.object.modifier_apply(apply_as=&#39;DATA&#39;, modifier=&quot;Decimate&quot;)</code>#应用编辑器</p><p><code>bpy.context.object.name = &quot;要改的名字&quot;</code> 选中物体的名字</p><p><code>bpy.ops.mesh.primitive_cube_add()</code>创建box</p><p><code>bpy.context.object.active_material</code>返回当前选择物体的材质球</p><p><code>bpy.data.materials.get(材质球名称字符串)</code>拿到当前场景的某个材质</p><p><code>bpy.context.view_layer.objects.active.material_slots.data.active_material= 某个材质</code> 给当前激活的物体材质球插槽赋予某个材质</p><p><code>bpy.ops.wm.save_mainfile(filepath=&quot;E:\\Test\\testsave.blend&quot;)</code>存储当前文件</p><p><code>bpy.ops.wm.open_mainfile(filepath=BlendFilePath)</code> 打开文件</p><p>得到当前版本的blender文件夹路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">argv &#x3D; sys.argv #当前blender的路径例：[&#39;D:\\blender-2.81a\\blender.exe&#39;]</span><br></pre></td></tr></table></figure><p>遍历列表选中物体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in bpy.context.visible_objects:#迭代所有可见物体</span><br><span class="line">if i.name &#x3D;&#x3D; &quot;要选物体的名字&quot;:</span><br><span class="line">i.select_set(state&#x3D;True)</span><br><span class="line">for i in bpy.context.visible_objects:</span><br><span class="line">    if i.type &#x3D;&#x3D; &quot;MESH&quot;:#判断物体类型是模型</span><br><span class="line">        bpy.context.view_layer.objects.active &#x3D; i #当前激活物体定义为i</span><br><span class="line">        bpy.ops.object.mode_set(mode&#x3D;&#39;EDIT&#39;) #编辑模式</span><br><span class="line">        bpy.context.tool_settings.mesh_select_mode &#x3D; (False, True, False)#编辑模式的（点线面）</span><br><span class="line">        bpy.ops.mesh.select_all(action&#x3D;&#39;SELECT&#39;)#全选命令</span><br><span class="line">        bpy.ops.object.mode_set(mode&#x3D;&#39;OBJECT&#39;)#关闭编辑模式</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编辑器&quot;&gt;&lt;a href=&quot;#编辑器&quot; class=&quot;headerlink&quot; title=&quot;编辑器&quot;&gt;&lt;/a&gt;编辑器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装python3.0以上(Blender 2.8是 python3.x)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vscode 安装python 和 blender Development 插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;终端安装 fake-bpy 包&lt;code&gt;pip install fake-bpy-module-2.80&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/nutti/fake-bpy-module&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/nutti/fake-bpy-module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完上面这些，vscode里面就会有自动补全&lt;/p&gt;
&lt;p&gt;Debug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ctrl + shift + P, select “Blender: Start”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择你的blender安装路径, vscode会连接到blender&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ctrl + shift + P, “Blender: Run script” 并且可以使用断点调试&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="blender" scheme="http://yoursite.com/tags/blender/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python</title>
    <link href="http://yoursite.com/2020/03/10/Effective-Python/"/>
    <id>http://yoursite.com/2020/03/10/Effective-Python/</id>
    <published>2020-03-10T11:14:04.000Z</published>
    <updated>2020-03-11T02:25:37.725Z</updated>
    
    <content type="html"><![CDATA[<p>编写高质量代码的59+91个建议读书笔记</p><h3 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h3><ul><li>确认自己所用的python版本。</li><li>确保该版本与你想使用的python版本相符。</li><li>优先使用python3</li></ul><h5 id="Windows平台下："><a href="#Windows平台下：" class="headerlink" title="Windows平台下："></a>Windows平台下：</h5><p><code>$python --version</code><br><img src="/2020/03/10/Effective-Python/2020-03-07-11-15-23.png" alt="a"></p><a id="more"></a><h5 id="其他程序内："><a href="#其他程序内：" class="headerlink" title="其他程序内："></a>其他程序内：</h5><ul><li><p>Autodesk Maya:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-18-24.png" alt="b"></p></li><li><p>Substance Designer:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-19-36.png" alt="c"><br>注：SD里sys.version_info报错，原因未知</p></li><li><p>Houdini：<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-22-33.png" alt="d"></p></li></ul><p>Tips： Python中sys模块还有一个常用功能：<br><code>sys.path</code>可以用来找到应用程序内的python编译器位置.</p><h3 id="第二条"><a href="#第二条" class="headerlink" title="第二条"></a>第二条</h3><p>遵循PEP8 风格指南<br>《Python Enhancement Proposal #8》（8号Python增强法案）又叫PEP8,它是针对Python代码格式而编订的风格指南。</p><ul><li>使用空格来表示缩进，而不要用制表符（tab）。</li><li>和语法相关的每一层缩进都用四个空格表示。</li><li>每行的字符数不应超过79。</li><li>对于占据多行的长表达式，除了首行之外的其余各行都应该在通常的缩进级别之上再加四个空格。</li><li>文件中的代码与函数和类之间应该用两个空行隔开。</li><li>在同一个类中，各方法之间应该用一个空行隔开。</li><li>在使用下标来获取列表元素、调用函数或给关键字参数赋值的时候，不要再两边添加空格。</li><li>为变量赋值的时候，赋值符号的左侧和右侧应该各自写上一个空格，而且只写一个。</li></ul><p>命名：PEP8 提倡采用不同的命名风格来编写Python代码中的各个部分,以便再阅读代码时可以根据这些名称看出它们的角色。</p><ul><li>函数、变量名及属性应该用小写字母，各单词之间用下划线相连，例如，lowercase_underscore。</li><li>受保护的实例属性，应该以单个下划线开头，例如，_leading_underscore.</li><li>私有的实例属性，应该以两个下划线开头，例如__double_leading_underscore.</li><li>类与异常， 应该以每个单词首字母均大写的形式来命名，例如，CapitalizedWord。</li><li>模块级别的常量，应该全部采用大写字母来拼写，各单词之间以下划线连接，例如，ALL_CAPS。</li><li>类中的实例方法（instance method），应该把首个参数命名self，以表示该对象自身.</li><li>类方法（class method）的首个参数，应该命名cls，以表示该类自身。</li></ul><p>表达式和语句《The Zen of Python》（python之禅）中说，每件事都应该有直白的做法，而且最好只有一种。</p><ul><li>采用内联形式的否定词 ，而不要把否定词放在整个表达式的前面，例如，应该写 if a is not b 而不是 if not a is b。</li><li>不要通过检测长度的方法来判断列表是否为空，而是应该采用if not somelist来判定。</li><li>同上条，如果判断列表不为空也是一样的， </li><li>不要编写单行的if语句、for循环、while循环及except复合语句，而是应该把这些语句分成多行来书写，以示清晰。</li><li>import语句应该重视放在文件开头.</li><li>引入模块的时候，总是应该使用绝对名称，而不应该根据当前模块的路径来使用相对名称，例如，引入bar包中的foo模块时，应该完成的写出 from bar import foo，而不应该简写为import foo。</li><li>如果一定要以相对的名称来编写import语句，那就采用明确的写法:from.import foo。</li><li>文件中的那些import语句应该按照顺序划分为三个部分，分别为标准库模块、第三方模块以及自用模块。各import语句应该按照模块的字母顺序来排列。</li></ul><p>Tips： vscode可以采用pylint来自动检测受测代码是否符合pep8。<br><a href="https://www.pylint.org/" target="_blank" rel="noopener">https://www.pylint.org/</a></p><h3 id="第三条"><a href="#第三条" class="headerlink" title="第三条"></a>第三条</h3><h5 id="了解bytes、str、和unicode的区别"><a href="#了解bytes、str、和unicode的区别" class="headerlink" title="了解bytes、str、和unicode的区别"></a>了解bytes、str、和unicode的区别</h5><ul><li>python3有两种表示字符序列的类型，bytes和str，前者的实例中包含原始的8位值，后者的实例中包含Unicode字符。</li><li>python2中也有两种表示字符序列的类型，str和Unicode. 前者包含原始的八位值，后者的实例着包含unicode字符。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-29-10.png" alt="e"></li><li>bytes 类型，是指一堆字节的集合，十六进制表现形式，两个十六进制数构成一个 byte ，以 b 开头的字符串是 bytes 类型。计算机只能存储二进制，字符、图片、视频、音乐等想存到硬盘上，必须以正确的方式编码成二进制后再存，但是转成二进制后不是直接以 0101010 的形式表示的，而是用bytes() 的类型来表示的。</li><li>把Unicode字符表示为二进制数据（原始八位值）有很多办法，常见且推荐的编码方式就是UTF-8。</li><li>但是python3 的str实例和python2的Unicode实例都没有和特定的二进制编码形式相关联，想要把Unicode字符转换为二进制数据，就必须使用encode方法，想要把二进制数据转化成为Unicode字符，则必须使用decode 方法。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-34-59.png" alt="f"></li><li>在 Python3 中内存里的字符串是以 Unicode 编码的，Unicode 的其中一个特性就是跟所有语言编码都有映射关系，所以 UTF-8 格式的文件，在 Windows 电脑上若是不能看，就可以把 UTF-8 先解码成 Unicode ，再由 Unicode 编码成 GBK 就可以了。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-32-20.png" alt="g"><h5 id="字符串的转换"><a href="#字符串的转换" class="headerlink" title="字符串的转换"></a>字符串的转换</h5></li><li>在Python3中，接受str或byts，并总是返回str的方法:  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, bytes):<span class="comment">#注意这个函数</span></span><br><span class="line">        value = bytes_or_str.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li><li>接受str或bytes，并总是返回bytes的方法：  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li><li>在Python2中，接受str或unicode，并总是返回unicode的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_unicode(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, str):</span><br><span class="line">        value &#x3D; unicode_or_str.decode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure></li><li>接受str或unicode，并总是返回str的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_str(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, unicode):</span><br><span class="line">        value &#x3D; unicode_or_str.encode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure><h5 id="推荐的文件操作符"><a href="#推荐的文件操作符" class="headerlink" title="推荐的文件操作符"></a>推荐的文件操作符</h5>如果通过open函数获取文件句柄，该句柄会采用UTF-8编码格式来操作文件。<br>而在Python2中，文件操作的默认编码格式则是二进制形式。这可能会导致程序出现奇怪的错误。<br>例如，向文件中随机写入一些二进制数据。下面这种方法Python2中可以正常运行，但是在Python3中则不行：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TypeError: must be str, <span class="keyword">not</span> bytes</span><br></pre></td></tr></table></figure>上述情况是因为Python3给open函数添加了名为encoding的新参数，而这个新参数默认值是’utf-8′。这样在文件句柄上进行read和write操作时，系统就要求开发者必须传入包含unicode字符的str实例，而不接受包含二进制数据的bytes实例。</li></ul><p>解决这个问题，可以用二进制写入模式(‘wb’)来开启待操作的文件，按照这种方式可同时适配Python2和Python3：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>(读取文件也同理，可使用’rb’模式)</p><h3 id="第四条"><a href="#第四条" class="headerlink" title="第四条"></a>第四条</h3><p>用辅助函数来取代复杂的表达式</p><ul><li>开发者很容易过度运用Python的语法特性，从而写出那种特别复杂并且难以理解的单行表达式。</li><li>请把复杂的表达式移入辅助函数中。如果要反复使用相同的逻辑，那就更应该那么做。</li><li>使用if/esle表达式，要比用or或者and 这样的Boolean操作符写出的表达式更清晰。</li></ul><h3 id="第五条"><a href="#第五条" class="headerlink" title="第五条"></a>第五条</h3><p>了解切割序列的方法<br>python提供了一种把序列切成小块的写法，这种切片操作很容易四开发者轻易的访问序列中的某些元素所构成的子集。<br>最简单的用法，就是对内置list和bytes进行切割。<br>切割操作还可以延伸到实现了<strong>getitem</strong>和<strong>setitem</strong>这两个特殊方法的python类上，参见28条。</p><ul><li>不要写多余的代码。但start索引为零或者end索引为序列长度时，应该将其忽略</li><li>切片操作不会计较start或者end索引是否越界，这样我们很容易从前端或者后端开始。</li><li>对list赋值时，如果使用切片操作，就会把原列表中处在相关范围内的值替换成新值，即便它们的长度不同也依然可以替换。</li></ul><h3 id="第六条"><a href="#第六条" class="headerlink" title="第六条"></a>第六条</h3><p>在单词切片操作内，不要同时指定start、 end 和 stride </p><ul><li>问题在于采用stride方式进行切片时，经常会出现不符合预期的结果</li><li>切割列表时，如果制定了stride，代码就会变得费解。尤其是stride为负值的时候更是如此.</li><li>在同一个切片操作内，不要同时使用start、end和stride. 如果确实需要执行这种操作，那就考虑将其拆解为两条赋值语句，其中一条做范围切割，另一条做步进，或者考虑使用内置itertools模块中的islice.</li></ul><p>tips：<br><code>mystring[::-1]#反转字符串</code></p><h3 id="第七条"><a href="#第七条" class="headerlink" title="第七条"></a>第七条</h3><p>用列表推导来取代map和filter<br>python提供了一种精炼的写法，可以根据一个列表来制作另外一个列表.这种表达式称为list comprehension （列表推导）</p><ul><li>列表推导要比内置的map和filter函数清晰</li><li>列表推导可以很跳过输入列表中的某些元素</li><li>字典与集也支持推导表达式</li></ul><h3 id="第八条"><a href="#第八条" class="headerlink" title="第八条"></a>第八条</h3><p>不要使用含有两个以上表达式的列表推导</p><ul><li>列表推导支持多级循环，每一级循环也支持多项条件</li><li>超过两个表达式的列表推导难以理解，应该尽量避免<br>Tips：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br><span class="line">print(flat)</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="comment">#下面两种写法是等效的</span></span><br><span class="line"><span class="comment">#要从列表中取出大于4的偶数</span></span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">if</span> x %<span class="number">2</span> ==<span class="number">0</span>]</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">and</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="第九条"><a href="#第九条" class="headerlink" title="第九条"></a>第九条</h3><p>用生成器表达式来改写数据量较大的列表推导<br>列表推导的缺点是，对于输入序列中的每个值来说，都要创建一项仅含一项元素的全新列表，但输入数据较大时，可能会消耗大量内存，并导致程序崩溃。<br>为了解决此问题，python 提供了生成式表达式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt))</span><br><span class="line">print(it)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x101b81480</span>&gt;</span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">57</span></span><br></pre></td></tr></table></figure><p>Tips：<br>获取文件每行的字符数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt)]</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure><ul><li>当输入的数据量较大时，列表推导可能会因为占用太对内存而出问题。</li><li>由生成表达式所返回的迭代器，可以逐次产生输出值，从而避免了内存用量问题。</li><li>把某个生成器表达式说返回的迭代器，放在另一个生成器表达式的for子表达式中，即可将二者组合起来。</li><li>串在一起的生成器表达式执行速度很快。 </li></ul><h3 id="第十条"><a href="#第十条" class="headerlink" title="第十条"></a>第十条</h3><p>尽量用enumerate取代range<br>在一些列的整数上面迭代，内置的range函数很有用，<br>当迭代列表的时候，通常还想知道当前元素在列表中的索引。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(flavor_list)):</span><br><span class="line">    flavor = flavor_lsit[i]</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure><p>这种代码不利于理解，python提供了enumerate来解决此问题。enumerate可以把各种迭代器包装为生成器，以便稍后产生输出值，生成器每次产生一对输出值，前者为循环下标，后者表示从迭代器中获取到的下一个序列元素，这样写出来的代码会非常整洁。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure><ul><li>enumerate函数提供了一种精简的写法，可以在遍历迭代器时获知每个元素的索引</li><li>尽量用enumerate来改写那种将range与下标访问相结合的序列遍历代码</li><li>可以给enumerate 提供第二个参数，已指定开始计数时所用的值（默认为0）</li></ul><p>Tips:<br>还可以直接指定enumerate开始计数所用的值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list，<span class="number">1</span>):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i,flavor))</span><br></pre></td></tr></table></figure><h3 id="第十一条"><a href="#第十一条" class="headerlink" title="第十一条"></a>第十一条</h3><p>用zip函数同时遍历两个迭代器</p><ul><li><p>使用for循环</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Cecilia</span><br></pre></td></tr></table></figure><p>上面这段代码问题在一，整个循环语句看上去很乱，用下标来访问names和letters会使代码不易阅读。<br>改用enumerate可以稍稍缓解这个问题，但仍然不够理想。</p></li><li><p>使用for循环加enumerate</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names)：</span><br><span class="line">    count =letters[i]</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure></li><li><p>使用zip</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letter):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure></li><li><p>内置的zip函数可以平行的遍历多个迭代器</p></li><li><p>Python3中的zip相当于生成器，会在遍历过程中逐次产生元组，而Python2中的zip则是直接把这些元组完全生成号，并一次性的返回给整份列表。</p></li><li><p>如果提供的迭代器长度不等，那么zip就会自动提前终止。</p></li><li><p>itertools 内置模块中的zip_longest函数可以平行的遍历多个迭代器，而不用在乎它们的长度是否相等。</p></li></ul><h3 id="不要在for和while循环后面写else语块"><a href="#不要在for和while循环后面写else语块" class="headerlink" title="不要在for和while循环后面写else语块"></a>不要在for和while循环后面写else语块</h3><ul><li>python 有种特殊语法，可在 for及 while 循环的内部语句块之后紧跟一个else块。</li><li>只有当整个循环主体都没遇到break语句时，循环后面的else块才会执行。</li><li>不要再循环后面使用else块，因为在这种写法即不直观，又容易引人误解。</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/lipandeng/p/11162039.html" target="_blank" rel="noopener">https://www.cnblogs.com/lipandeng/p/11162039.html</a><br><a href="https://lingyunfx.com/?page_id=152" target="_blank" rel="noopener">https://lingyunfx.com/?page_id=152</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写高质量代码的59+91个建议读书笔记&lt;/p&gt;
&lt;h3 id=&quot;第一条&quot;&gt;&lt;a href=&quot;#第一条&quot; class=&quot;headerlink&quot; title=&quot;第一条&quot;&gt;&lt;/a&gt;第一条&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;确认自己所用的python版本。&lt;/li&gt;
&lt;li&gt;确保该版本与你想使用的python版本相符。&lt;/li&gt;
&lt;li&gt;优先使用python3&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Windows平台下：&quot;&gt;&lt;a href=&quot;#Windows平台下：&quot; class=&quot;headerlink&quot; title=&quot;Windows平台下：&quot;&gt;&lt;/a&gt;Windows平台下：&lt;/h5&gt;&lt;p&gt;&lt;code&gt;$python --version&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/2020/03/10/Effective-Python/2020-03-07-11-15-23.png&quot; alt=&quot;a&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101-现代计算机图形学入门-闫令琪(1-5)</title>
    <link href="http://yoursite.com/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/"/>
    <id>http://yoursite.com/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/</id>
    <published>2020-03-10T11:14:04.000Z</published>
    <updated>2020-04-09T09:33:18.697Z</updated>
    
    <content type="html"><![CDATA[<p>GAMES101-现代计算机图形学入门-闫令琪(1-5) 课程学习笔记</p><h2 id="第一节-引入"><a href="#第一节-引入" class="headerlink" title="第一节 引入"></a>第一节 引入</h2><p>怎么判断一个游戏画面的技术水平，有一个很简单的方法就是画面亮不亮。</p><h2 id="第二节-线性代数"><a href="#第二节-线性代数" class="headerlink" title="第二节 线性代数"></a>第二节 线性代数</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量是带有方向的量<br>重要的两个量是方向和长度<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-49-03.png" alt>  </p><a id="more"></a><p>数学： 向量<br>物理： 矢量<br>向量长度：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-49-24.png" alt><br>向量加法（求和）：<br>几何上<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-49-38.png" alt><br>数学上<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-49-58.png" alt><br>我们把向量表示成直角坐标系这种形式是有助于计算向量的长度的。  </p><h4 id="向量的点乘和叉乘"><a href="#向量的点乘和叉乘" class="headerlink" title="向量的点乘和叉乘"></a>向量的点乘和叉乘</h4><p>向量更广泛的用法<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-50-12.png" alt>  </p><h5 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-50-25.png" alt><br>左边是两个向量，右边是一个数字。<br>如果两个向量都是单位向量，那么它们点乘的结果就是余弦的值。  </p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-58-31.png" alt><br>点乘既然是一种运算，运算法则都会满足一些性质。<br>交换律 结合律 分配律  </p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-08-11.png" alt><br>如果是在坐标系下，就跟简单。  </p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-02-30.png" alt>  </p><ol><li>点乘在图形学最重要的作用就是找到两个向量的夹角。<br>比如 光从哪个地方射过来（向量）物体表面法线是什么样的（向量）我们从哪里看（向量）</li><li>第二个重要作用就是找到一个向量的投影到另一个向量是长什么样的。<br>投影算出来有什么好处呢？ 我们可以把一个向量分解成两个向量，一个平行一个垂直。这样可以帮助我们把任意向量分解到任意坐标轴。<br> <img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-17-01.png" alt></li><li>在图形学里，我们还可以根据点乘的结果判定两个向量是否接近是否远离。</li><li>向量点乘还可以告诉大家一个前与后的信息，如图（向量a和向量b点乘为正值且接近1，向量a和向量c点乘为负值，如果有一个向量跟向量a一样，那点乘结果为1，如果有一个向量正好在虚线上，那点乘的值为0，如果跟向量a正好相反，那点乘结果为-1）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-44-08.png" alt>  </li></ol><h5 id="叉乘（叉积）"><a href="#叉乘（叉积）" class="headerlink" title="叉乘（叉积）"></a>叉乘（叉积）</h5><p>叉乘是给定两个向量计算出同时垂直与这两个向量的新的向量，另外同时垂直这两个向量也就是必然垂直这两个向量形成的平面<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-57-13.png" alt><br><strong>右手螺旋定则</strong>（DirectX是右手，openGL是左手）。<br>定义，右手伸值大拇指向天空，四个拇指朝向手心握（逆时针运动），如果大拇指向大地，四个拇指朝向手心握（顺时针运动）。这里右手指向天空为正，所以逆时针运动为正。</p><p>例子：</p><ol><li>Z叉乘X,XYZXYZ,Z到X就是顺时针，所以得到正Y。</li><li>Y叉乘X，XYZXYZ,Y到X就是逆时针，所以得到负Z。</li></ol><p>向量的叉乘并不满足交换律（如果要交换需要加一个负号）<br>向量的叉积还有一个作用是我们利用它来建立一个三维空间中的直角坐标系<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-14-04-16.png" alt><br>几何：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-14-36-32.png" alt>  </p><p>叉积怎么算，有什么用处：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-14-37-55.png" alt><br>特别重要 </p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-14-38-58.png" alt></p><ol><li>判定左和右<br>如图左侧，XY为平面，通过右手螺旋定则，Z为朝向我们自身的向量，如果想判断向量b在向量a左侧还是右侧（什么是左侧右侧? 从向量a顺时针旋转到达向量b为左侧，逆时针为右侧），在这里根据图示很容易看出来向量b是在向量a的左侧，如果用数字表示就是 向量a叉乘向量b得到的结果是正值（指向身体）就说明向量b在向量a的左侧，如果向量b叉乘向量a得到的结果是负值（指向身体外侧），那就说明向量a在向量b右侧，</li><li>判定内与外<br>如图右侧，先判断向量AP是否在向量AB的左侧，在判断向量BP是否在向量BC的左侧，在判断向量AP是否在ac的左侧，如果都是在左侧就说明点P在三角形内部，否则肯定有一个判断是在右侧。<br>这里假设了ABC三个点是逆时针排布，如果换成顺时针也没有问题，只不过是都在左侧。<br>所以我们可以忽略三角形的排布顺序，只要三个边左或者右保持一致就说明点在三角形内部。这点非常重要，是光栅化的基础（用来判断像素是否在三角形的内部）。</li></ol><h4 id="向量定义坐标系"><a href="#向量定义坐标系" class="headerlink" title="向量定义坐标系"></a>向量定义坐标系</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-15-51-31.png" alt><br>向量叉乘可以定义一些互相垂直的轴，就会形成坐标系如图。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-15-52-25.png" alt><br>这里顶一个uvw坐标系，三个向量单位长度都为1，互相垂直，给你u和v 叉乘得到w。<br>我们可以利用投影把任意一个向量分解到三个轴上去，利用点乘，因为什么呢？向量P点乘向量U，等于是向量P的长度乘以向量U的长度在乘以cosθ，向量U又恰好是单位向量为1，等于是向量P的长度乘以cosθ，根据下图三角函数，就会得出向量P在向量U上的投影，同理获得向量P在向量V和向量W上的投影，有了这三个投影就可以获得坐标系下的这个向量。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-16-07-00.png" alt><br>cosA = c/b  </p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-16-47-04.png" alt><br><strong>在图像学里，变换就是矩阵的最大应用。</strong><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-20-44-32.png" alt>  </p><h5 id="矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量"><a href="#矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量" class="headerlink" title="矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量."></a>矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量.</h5><h5 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-20-53-06.png" alt><br>矩阵乘矩阵必须要符合条件才能乘，如图必须第一个矩阵的列数和第二个矩阵的行数相同相乘才有意义。<br><strong>关于新得到的矩阵每一个元素都是什么，有不同的数学定义，这个地方比较不容易记住，这里给大家提供一个容易记得方法，比如左下角这个8，他的坐标是三行一列，这里三行对应第一个矩阵（0，4），一列对应第二个矩阵（3，2），这两个向量点乘。</strong><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-21-50-50.png" alt><br>矩阵乘法是没有交换律的，但是矩阵是由结合律和分配律。  </p><h5 id="矩阵乘向量"><a href="#矩阵乘向量" class="headerlink" title="矩阵乘向量"></a>矩阵乘向量</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-21-53-53.png" alt></p><blockquote><p>一个矩阵如何和一个向量乘？当我们认为向量是列向量就有意义了（也就是说M永远为1）。    </p></blockquote><p><em>这是最重要的核心。</em><br>下面表示一个2D向量按Y轴镜像的操作。</p><h5 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-22-01-06.png" alt><br>性质： 如果要乘两个矩阵在转置好比相对后一个矩阵做装置在乘以前一个矩阵做转置的结果。</p><h5 id="特殊的矩阵，单位矩阵"><a href="#特殊的矩阵，单位矩阵" class="headerlink" title="特殊的矩阵，单位矩阵"></a>特殊的矩阵，单位矩阵</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-22-07-51.png" alt><br>对角阵，只有对角线上有非零的元素，<br>矩阵的逆：如果你能找到一个矩阵，和原来的矩阵相乘，不管乘得顺序，得到的结果都是I，那么我们就认为这两个矩阵是互逆的。<br>逆矩阵的计算和转置的矩阵很相似。</p><h5 id="向量点乘和叉乘的矩阵形式"><a href="#向量点乘和叉乘的矩阵形式" class="headerlink" title="向量点乘和叉乘的矩阵形式"></a>向量点乘和叉乘的矩阵形式</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-22-12-11.png" alt><br>点乘：向量a点乘向量b 等于向量a转置和向量b的乘法。<br>叉乘：相对点乘困难一些，相当于把向量a转换成一个矩阵（dual matrix）乘以向量b</p><h2 id="第三节-变换"><a href="#第三节-变换" class="headerlink" title="第三节 变换"></a>第三节 变换</h2><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-16-48-49.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-16-53-27.png" alt></p><h4 id="我们为什么要学习变换："><a href="#我们为什么要学习变换：" class="headerlink" title="我们为什么要学习变换："></a>我们为什么要学习变换：</h4><ul><li>Modeling：<br>位移 旋转 缩放<br>很多动画就是由各种不同的变换合成在一起形成的。</li><li>Viewing：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-16-58-58.png" alt><br>光栅化成像涉及到大量的变换。<br>3D -&gt; 2D 从三维到二维的变换我们叫做投影，这个投影也是一种非常重要的变换，之后会学到。<h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-01-01.png" alt><br>今天我们的目标就是，把矩阵和变换联系起来。<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="标准缩放"><a href="#标准缩放" class="headerlink" title="标准缩放"></a>标准缩放</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-02-15.png" alt><br>横轴和纵轴都缩放了0.5，也就是说把任何一个点坐标(X,Y)进行缩放操作0.5倍。<br>如果用数学形式表示, 可以表示为<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-06-00.png" alt><br>如果用矩阵形式表示可以表示为对角矩阵。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-06-36.png" alt><br>是不是这样的，我们可以验证一下。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-32-25.png" alt><h5 id="如果XY的缩放各不相同"><a href="#如果XY的缩放各不相同" class="headerlink" title="如果XY的缩放各不相同:"></a>如果XY的缩放各不相同:</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-34-39.png" alt><h5 id="如果是反射（对称）的操作："><a href="#如果是反射（对称）的操作：" class="headerlink" title="如果是反射（对称）的操作："></a>如果是反射（对称）的操作：</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-36-36.png" alt><br>等于是Y轴不变，X轴反过来。<h5 id="如果是切变的操作："><a href="#如果是切变的操作：" class="headerlink" title="如果是切变的操作："></a>如果是切变的操作：</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-39-12.png" alt><br>注意这里可以通过一个点的变换前到变换后的变化推导出,Y是不变的，X是变成了X+ay，由x+ay倒推出矩阵.<h5 id="如果是旋转的操作："><a href="#如果是旋转的操作：" class="headerlink" title="如果是旋转的操作："></a>如果是旋转的操作：</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-00-56.png" alt><br>默认是绕(0,0)点旋转，逆时针旋转.<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-00-15.png" alt><br>简单的推导：</li><li>不管再复杂的操作，先找到一个一一对应的关系点，再倒推。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-13-23.png" alt><br>通过（1，0）点的对应关系点配合三角函数可以得到矩阵AC值，那么通过（0，1）点的对应关系点可以找到BC.<h5 id="变换的共同点"><a href="#变换的共同点" class="headerlink" title="变换的共同点"></a>变换的共同点</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-33-00.png" alt><br>X pu ruai mu = 变换矩阵*X<br>这样变换和矩阵的联系就建立起来了，对于一个变换就可以用矩阵来表示。<br>概念区分： 我们要用一个相同维度的矩阵来乘以向量。<h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4></li></ul><h5 id="为什么要学习齐次坐标，为什么要引入这个复杂的东西。"><a href="#为什么要学习齐次坐标，为什么要引入这个复杂的东西。" class="headerlink" title="为什么要学习齐次坐标，为什么要引入这个复杂的东西。"></a>为什么要学习齐次坐标，为什么要引入这个复杂的东西。</h5><p>因为平移变换特别特殊。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-40-34.png" alt><br>如果简单的写出来，是挺简单的，但是没有办法转换成矩阵:<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-41-24.png" alt><br>所以无奈之下必须要用齐次坐标。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-42-38.png" alt><br>平移操作并不属于一个线性变换（因为线性变换必须等于一个向量等于一个矩阵乘以另外一个向量），但是我们不希望把平移当作一个特殊的情况处理，因为人类总是懒的。所以有没有办法可以把我们提到的所有变换归纳成一个最简单的变换来表示。<br>tradeoff：权衡.</p><h5 id="齐次坐标-1"><a href="#齐次坐标-1" class="headerlink" title="齐次坐标"></a>齐次坐标</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-19-26-18.png" alt><br>如果XY表示点的坐标那就加上1，如果是向量加上0。为什么区别对待?<br>因为向量具有<strong>平移不变性</strong>：<br>如果有一个向量经过一个表示平移的矩阵，我们希望它的结果还是XY0.</p><blockquote><p>向量是个所谓的“过程量”，不依赖于本身的位置。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-19-39-25.png" alt></p></blockquote><ol><li>如果两个向量相加，结果是新的向量（x1+x2，y1+y2，0+0）有意义。</li><li>如果两个点相减（形成一个从被减数指向减数向量）（x1-x2，y1-y2，1-1=0）点减点等于向量，有意义。</li><li>如果是点加向量，一个点沿着向量移动到一个新的点上，<br>（x1+x2，y1+y2，1+0=1）有意义。</li><li>一个点加一个点，没意义，扩充的定义。</li><li>对于任何的二维点，我们认为，(x/w,y/2,w/w),w!=0(0就是向量了。)</li><li>一个点加一个点，表示这两个点的中点。为什么？因为一个点加一个点w会变成2，这个w变成1的过程就是在求中点。</li></ol><p>最重要的不是这些变换，而是目的，我们的目的是就是为了把所有的变换写出一个矩阵乘以一个向量的形式。</p><h5 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-20-00-24.png" alt><br>线性变换+位移，对于类似的变换就叫仿射变换。<br>所有的仿射变换都可以写成齐次坐标这种形式。<br>验证：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-20-03-21.png" alt><br>只要表示<strong>仿射变换</strong>最后一行都是001，理论上只用存储上面的部分就行了。</p><h5 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h5><p>逆变换是指把一个变换的操作反过来。<br>在数学对应的正好是乘以这个变换的逆矩阵（一个矩阵乘以它自己的逆矩阵一定等于单位矩阵）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-31-02.png" alt></p><h5 id="变换组合-分解"><a href="#变换组合-分解" class="headerlink" title="变换组合/分解"></a>变换组合/分解</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-38-30.png" alt><br>对于这样一个变换我们可以把它看成先平移在旋转，如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-39-04.png" alt><br>但是结果不对，因为旋转还是绕(0,0)点。怎么操作对呢？如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-40-32.png" alt></p><p>如此可以得到两个信息：</p><ol><li>复杂的变换可以通过简单的变化得到。</li><li>变换的顺序非常重要。(对应矩阵乘法不满足交换律{变换就是在某一个向量前面乘以一个矩阵，再变换一次就是再在前面乘以一个矩阵，矩阵的乘的顺序变换那结果就会发生变化})<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-45-44.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-46-04.png" alt><br>先乘旋转矩阵再乘平移矩阵，也就是等号左边逐个变换逐个向左写，等会右边乘的时候也是从右往左乘（跟整数乘法正好相反），推广概念如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-51-43.png" alt><br>Tips：矩阵没有交换律，但是有结合律。可以把A1到An乘完得到一个矩阵在和向量相乘，也就是说，<strong>一个矩阵就可以表示非常复杂的变换</strong></li></ol><p>同样道理，变换既然可以合成也就可以分解。如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-57-30.png" alt><br>如果我们想已给定点为中心进行旋转，可以分解如图，先把这个点移到（0,0）点{移动一个-C}，然后旋转，再移动回去{移动一个C}</p><h5 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h5><p>三维的变换就是把二维的变换拿过去做类比就可以（包括齐次坐标表示）。<br>三维空间也会有线性变换，三维空间也会有平移。也不希望三维空间的平移变成特殊现学，也就再次用齐次坐标，再加一个数。四维数表示三维空间的点和向量。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-06-16.png" alt><br>4X4矩阵<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-15-08.png" alt><br>三维空间中 仿射变换的情况下， 最后一行肯定是（0，0，0，1）</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如上图的变换，是先表示的线性变换还是先表示的位移？<br>是先进行的线性变换，再进行的位移。遇到此类问题可以考虑不用齐次坐标的表示。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-20-14.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-21-42.png" alt></p><h2 id="第四节-变换续"><a href="#第四节-变换续" class="headerlink" title="第四节 变换续"></a>第四节 变换续</h2><h5 id="上节的补充"><a href="#上节的补充" class="headerlink" title="上节的补充"></a>上节的补充</h5><p>二维情况下，如果不考虑齐次坐标，变换可以用2x2的矩阵来表示，<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-46-17.png" alt><br>注意这里:<br>cos -θ 等于cosθ<br>sin -θ 等于-sinθ</p><p>这里有两个情况：</p><ol><li>和上面的矩阵相比这样我们就发现，旋转θ角和旋转-θ角就是把这个矩阵做了一个转置（行列对换）。  </li><li>从定义上来看，旋转θ角和旋转-θ角，应该是一个互逆的关系，旋转-θ角应该就是旋转θ角的到的矩阵的逆。<br>由此可以得出，如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-04-08.png" alt><br>旋转矩阵的转置等于旋转矩阵的逆<br>tips：<br>在数学上如果一个矩阵的逆等于这个矩阵的转置，那么这个矩阵叫做正交矩阵。<h5 id="上节的复习"><a href="#上节的复习" class="headerlink" title="上节的复习"></a>上节的复习</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-08-03.png" alt><h5 id="本节"><a href="#本节" class="headerlink" title="本节"></a>本节</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-37-29.png" alt><br>把三维变换结束掉之后，重点是viewing变换。<h5 id="三维变换-1"><a href="#三维变换-1" class="headerlink" title="三维变换"></a>三维变换</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-39-20.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-43-42.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-43-58.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-44-37.png" alt><br>对于三维空间的旋转变换，如果直接考虑绕任意一个轴旋转是很复杂的，但是如果绕XYZ的话就会相对简单，比如绕X轴移动的平面，其X坐标是不会发生任何改变的，发生改变的是Y，Z两个轴的数值。所以Rx和Rz都是有一个轴是不发生任何改变。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-16-48-58.png" alt><br>注意RxRz的符号是一致的，但是Ry是反的为什么呢，图上如果要的到Y就是Z叉乘X（xyzxyz循环对称性质），因为是反着的，所以结果符号是反的。<blockquote><p>这是因为二维平面定义时，逆时针实际是在三维从Z正向看，因此三维绕Y旋转，逆时针实际上是从Z向X运动，但是旋转矩阵的行列对应关系是X向Z转,取逆（转置）就得到了。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-16-48-21.png" alt><br>对于任意一个旋转，我们可以把它分解为绕X绕Y绕Z旋转。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-17-07-40.png" alt></p></blockquote></li></ol><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-17-11-12.png" alt><br>默认向量n的起点在原点，如果不是的话，可以用上一节的方法，先把它移动到原点，变换完再挪回去。  </p><h5 id="Viewing变换"><a href="#Viewing变换" class="headerlink" title="Viewing变换"></a>Viewing变换</h5><p>最终目的，是把三维空间里面的东西变成二维的。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-17-31-42.png" alt><br>|现实生活里拍照片动作|viewing变换动作|<br>|——————|————–|<br>|找好位置摆好pos|模型变换 model transformation|<br>|找到一个好的角度|视图变换 view transformation|<br>|茄子|投影变换 projection transformation|<br>简称MVP变换<br>怎么做view变换呢？<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-17-56-38.png" alt></p><ol><li>位置 往哪看 </li><li>往哪看</li><li>相机本身的向上方向</li></ol><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-18-00-49.png" alt></p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-21-13-05.png" alt></p><p>注意这里还是右手坐标系，可以使用右手螺旋定则判定。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-21-24-36.png" alt></p><p>怎么把这种变换表示成矩阵呢？<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-21-26-48.png" alt></p><ol><li>位移： 注意应该先做线性变换在做平移，但是为了理解方便这里先做了平移，后做线性变换，但是接下来往左写，是一样的。</li><li>旋转：这里把某个向量旋转成标准轴不好实现，但是反过来把某个标准轴旋转成某个向量好实现，所以我们就等于先求出逆变换，（这里的矩阵逆用的很巧妙），怎么对一个旋转矩阵求逆呢？利用旋转矩阵是正交矩阵，正交矩阵的逆就是它的转置（本节课开始证明的）。</li><li>这个Mview矩阵就可以把摄影机移动到零点，同理也可以把其他所有东西移动到相对位置上。视图变换  </li></ol><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-22-04-47.png" alt><br>总结：</p><ol><li>任何时候只要相机和物体应用同样的变换或者位移，结果不变。</li><li>视图变换操作的是相机，其他物体跟着变换。<h5 id="Projection-transforamtion投影变换"><a href="#Projection-transforamtion投影变换" class="headerlink" title="Projection transforamtion投影变换"></a>Projection transforamtion投影变换</h5></li><li>Orthographic projection 正交投影</li><li>Perspective projection 透视投影<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-43-42.png" alt><br>左边的正交投影，平行线永远平行（多用于工程制图）<br>右边透视投影近大远小，平行线延长终会相交（人眼）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-45-52.png" alt><br>左边透视投影，我们认为某个位置上的摄影机是一个点，去连出空间中的一个四棱锥。<br>右边正交投影，假设摄影机离得无限远，直到近和远的平面一样大。<h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5>正交投影相对好理解。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-51-04.png" alt><br>理解：</li><li>定义摄影机在原点，看向-Z，顶部朝Y</li><li>把Z轴坐标丢掉</li><li>把结果都挪到-1,1<br>实际操作：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-57-00.png" alt></li><li>首先定义空间中的一个立方体,</li><li>在xyz三轴找到对应的坐标 left，right，bottom，top，far，near，有了这六个数就可以定义这个立方体</li><li>映射到canonical cube -1,1，</li></ol><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-59-32.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-11-13.png" alt></p><p>把这个变换写成矩阵的形式：</p><ol><li>注意这里是先做平移，后面在做缩放</li><li>平移X值是指先求出矩形的长r+l除以2得到长的中心，在移动负中心的位置就是移动到x轴的中心，其它轴以此类推。</li><li>缩放X值，是先求出x的覆盖范围也就是长度r-l，跟比2的倍数也就是2/r-l，为什么是2，因为canonical的x长度是-1到1长度2。有了这个倍数，在对其进行缩放就把元素匹配到canonical cube里了。其它轴以此类推。</li></ol><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-27-18.png" alt></p><ol><li>因为摄影机看向-Z，所以这里的far是小于near的(-10小于-1)**</li><li>这里opengl 左手系就是far大于near，但是左手系会带来别的问题，x叉乘Y不等于Z等。<h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-28-56.png" alt></li><li>用的最广泛的投影</li><li>进大远小</li><li>平行线不平行，相交与一点<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-37-47.png" alt></li></ol><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-40-21.png" alt><br>在继续学习之前<br>这里复习了一下齐次坐标，当一个点（xyz1）的每个数都乘以任意一个数，表示的点不变。<br>例如（1，0，0，1）和（2，0，0，2）都代表（1，0，0）<br>简单，但是有用。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-49-43.png" alt><br>先定义个Frustum（平截头体），跟右边的Cuboid（长方体）对比，我们会发现只有远端的平面不一样，假如我们把远端的平面缩放到跟近端的平面一样，那就是跟正交投影一样了。<br>也就是我们把投射投影拆成了两步：  </p><ol><li>把远端的平面挤压到跟近端的平面一样，也就是把frustum变成cuboid。也就是求一个矩阵MPersp-&gt;Ortho</li><li>做一下正交投影</li></ol><p>规定：  </p><ol><li>近平面任何一点都不变。</li><li>远处的平面 Z值是f，操作完之后 远处的平面Z值仍然是F,同理，近平面的Z也不变。</li><li>远平面的中心点，缩放完之后还是中心点，坐标也是完全不变的。</li></ol><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-16-41-56.png" alt><br>挤压这步怎么做，也就是怎么求一个矩阵MPersp？<br>假设我们从侧面望Frustum上看，这里最左边是摄影机，朝-Z看，如上图。<br>看到两个相似三角形，根据相似三角形定理，Y’比上Y等于N比上Z<br>所以我们可以得到  y’ = （n/z）<em>y<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-17-48-02.png" alt><br>同理我们可以得到  X’ = （n/z）</em>x<br>现在我们知道XY在变换之后的结果，我们可以利用齐次坐标的属性共同乘以Z。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-17-59-58.png" alt><br>跟我们知道的结果，我们可以反推出矩阵：<br>如上图上方4<em>4矩阵乘以向量（x，y，z，1），得到（nx，ny，unknow，z）。<br>我们知道矩阵乘法是，一行乘一列，X是第一行第一列，也就是4</em>4矩阵的第一行点乘向量（x，y，z，1）一列，<br>得到nx，所以矩阵的第一行就只能是 （n,0,0,0）.</p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-17-30.png" alt><br>两个观察发现：</p><ol><li>任何点在近平面上是完全不变的。</li><li>任何点的z坐标值在远平面也是完全不变的。远平面的中心点，缩放完之后还是中心点，坐标也是完全不变的<br>根据这两个发现：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-21-41.png" alt><br>这里利用了齐次坐标的特性，把（x,y,n,1）四个数同时乘以n变成（nx，ny，n平方，n）<br>在利用任何点在近平面完全不变可以列出等式：<br>第三行的n平方 等于 矩阵M的第三行乘以向量第一列（x,y,n,1）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-47-46.png" alt><br>远平面的中心点，缩放完之后还是中心点，坐标也是完全不变的，利用了齐次坐标的特性，把（0,0,f,1）四个数同时乘以f变成（0，0，f平方，f）<br>为啥必须乘以f，是因为我们希望最后以为是Z也就是远平面的z也就是f值：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-52-45.png" alt><br>得到两个等式：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-54-15.png" alt><br>根据这两个等式，我们可以解出A和B。<br>这里利用了完全平方公式。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-18-14-33-16.png" alt><br>课后问题：<br>对于Frustum，我们知道变换完之后远平面和近平面的z是不变的，那中间任意一点的z呢？是会被推向近平面还是推向远平面？<br>变远。<br>很奇怪的是数值变的异常大，比如我指认n是-3 f是-5，得到矩阵之后，给定一个中间点（0，1，-4，1）（这里必须是点，也就是w是1，因为向量平移不变），结果是(0,-3,17,-4) ，由于齐次坐标（x/w，y/w，z/w，w/w），所以结果是（0，0.75，-4.25，1），所以变远了。</li></ol><h2 id="第五节-光栅化"><a href="#第五节-光栅化" class="headerlink" title="第五节 光栅化"></a>第五节 光栅化</h2><h4 id="上节课内容复习"><a href="#上节课内容复习" class="headerlink" title="上节课内容复习"></a>上节课内容复习</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-18-15-18-16.png" alt><br>观测变换</p><ul><li>视图变换：利用摄影机和物体相对位置不变，摄影机视口内容不变的原理，把摄影机移动到原点 向上+Y，看向-Z，把其它所有内容都和相机一样运动。</li><li>从三维投影的二维，提到了两类变换，正交和透视。<br>做完经典的观测变换（把物体都移动到-1，1这个立方体里面）之后，我们需要把物体画在屏幕上。这步叫做光栅化。</li></ul><p>透视投影转换正交投影<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-10-11-54.png" alt><br>遮挡和可见性</p><h4 id="透视投影近平面推导"><a href="#透视投影近平面推导" class="headerlink" title="透视投影近平面推导"></a>透视投影近平面推导</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-17-32-24.png" alt><br>之前我们通过左右（L，R）描述平截头体的近平面。<br>两个概念：</p><ol><li>长宽比</li><li>垂直可视角度<br>垂直可视角度越大越是广角,但是透视投影明显（鱼眼），垂直可视角度越小越是长焦，接近正交投影，透视小。<br>通过长宽比，我们可以推出垂直可视角度<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-18-29-26.png" alt><br>也就是说，只要给定宽高比和垂直可视角度，我们就可以创建一个视锥.<h4 id="什么是MVP"><a href="#什么是MVP" class="headerlink" title="什么是MVP"></a>什么是MVP</h4><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-19-07-00.png" alt></li></ol><ul><li>M<br>物体自身位移</li><li>V<br>把摄影机移动到0，0，0 看向-z 头朝正Y，其它物体也和摄影机保持不变，移动到相应位置</li><li>P<br>正交投影: 先定义一个boudingbox，再把boudingbox变换到（-1，1）3次方空间<br>透视投影: 平截头体变换到（-1，1）3次方空间</li></ul><h4 id="标准立方体空间到屏幕"><a href="#标准立方体空间到屏幕" class="headerlink" title="标准立方体空间到屏幕"></a>标准立方体空间到屏幕</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-19-38-56.png" alt></p><ul><li>什么是屏幕：<br>图形学上认为是一个数组，数组里面存储着像素。<br>数组的大小就是分辨率。<br>屏幕是一个典型的光栅成像设备。  </li><li>什么是光栅化:<br>raster == screen in german<br>rasterize == 再屏幕上绘制</li><li>什么是像素(一种说法：Pixel是picture element的缩写)<br>对于这门课简单的抽象理解带颜色的小方块，其实很复杂<br>RGB组成颜色  </li></ul><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-22-18-43-02.png" alt><br>定义屏幕空间<br>什么是屏幕空间：<br>相当于在屏幕上建立一个坐标系，左下角是（0,0）。<br>这样每一个像素都可以用（x,y）表示。<br>分辨率可以用（0，0）到（width-1，height-1）表示，<br>每个像素的中心坐标实际上是(x+0.5，y+0.5)<br>一个像素会覆盖（1，1）宽度，整个屏幕（0，0）到（width，height）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-22-19-01-28.png" alt></p><p>接下来就是把（-1，1）3这个标准空间映射到屏幕上，首先有一个问题就是 xyz 到xy，怎么处理z呢？<br>先不管它，那就是等于是把xy屏幕（-1，1）2 映射到（0，width）*（0，height），怎么做呢？<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-22-22-49-41.png" alt><br>注意这里注意变完之后,中心还在屏幕坐标的中心在左下角，我们要移动中心到屏幕的中心，所以最后一列是有内容的。   </p><h4 id="光栅化，三角形到像素"><a href="#光栅化，三角形到像素" class="headerlink" title="光栅化，三角形到像素"></a>光栅化，三角形到像素</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-04-35.png" alt></p><h6 id="几种光栅化显示设备："><a href="#几种光栅化显示设备：" class="headerlink" title="几种光栅化显示设备："></a>几种光栅化显示设备：</h6><ul><li>示波器<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-08-13.png" alt></li></ul><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-12-53.png" alt><br>为了使画面刷新快，利用视觉暂留技术，每次只画一半，画完奇数行画偶数行，这种技术叫隔行扫描。<br>现在在视频压缩里面还有应用。</p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-16-28.png" alt><br>给我一个显示器，我怎么知道他要显示什么呢？通过显存里面的一块区域，把这块区域映射到屏幕上，这里就是现在屏幕的显示方式，我们可以生成不同的图形，存储在不同的显存区域，告诉显示器到底显示哪一幅图。</p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-21-35.png" alt></p><ul><li>平板显示器<br>低分辨率：计算器<br>高分辨率：视网膜屏<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-23-13.png" alt><br>通过液晶的扭曲，改变通过它的光的扭曲水平。  </li></ul><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-25-13.png" alt></p><ul><li>发光二极管  </li></ul><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-26-41.png" alt></p><ul><li>电子墨水屏</li></ul><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-28-05.png" alt></p><h6 id="为什么是三角形"><a href="#为什么是三角形" class="headerlink" title="为什么是三角形"></a>为什么是三角形</h6><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-28-18.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-29-43.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-30-33.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-30-11.png" alt></p><ul><li>最基础的多边形,可以分解任何其它多边形</li><li>特殊的属性。<ul><li>给定任意三个点，练成三角形都是一个平面。</li><li>三角形内外定义非常清晰，可以通过向量的叉积判断一个点在不在三角形内。</li><li>三角形可以定义个插值从一个点到另外俩个点。<h6 id="如何判断一个像素和三角形的关系"><a href="#如何判断一个像素和三角形的关系" class="headerlink" title="如何判断一个像素和三角形的关系"></a>如何判断一个像素和三角形的关系</h6><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-40-16.png" alt><br>判断一个像素和三角形的位置关系，或者说通过像素的中心点判断和三角形的位置关系。<br>一个简单的做法：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-42-26.png" alt><br>通过采样，<br>什么是采样：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-42-56.png" alt><br>采样就是把一个函数给<strong>离散化</strong>的过程。比如定义一个函数 F(X) = sin（X），然后不停的带入x=1，到x=100，看对应的F(X)的值。<br>采样是一个非常重要的概念，在图像学里面涉及到各种各样的采样，这里说的采样是指利用像素中心对屏幕空间（（0，width）到（0，height））的采样。<br>后面还要采样 时间 位置 反射，<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-22-48-31.png" alt></li></ul></li></ul><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-22-49-07.png" alt><br>定义一个函数inside，给你一个三角形，给你屏幕空间的任意一点（x,y）我就知道点是不是在三角形内。</p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-22-52-40.png" alt><br>注意这里 inside 返回 0或者1 ，0代表在，1代表不在。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-22-59-55.png" alt></p><p>然后就是inside函数是怎么实现的，利用叉积。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-23-01-16.png" alt><br>P1P2叉乘P1Q，右手螺旋定则（顺时针），朝屏幕外得到Z正值，左。<br>P0P1叉乘P0Q，右手螺旋定则（顺时针），朝屏幕外得到Z正值，左。<br>p2p0叉乘P2Q，右手螺旋定则（逆时针），朝屏幕里得到Z负值，右。<br>只有全是正或者全是负才是三角形内部，所以Q所以不在三角形内部。</p><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-14-34-13.png" alt><br>如果碰巧在三角形的边界，该怎么处理呢？在图形学里面要么不做处理，要么特殊处理，这门课不做处理。自己定义一个标准即可。<br>在dx和opengl的api里面定义非常严格，点落在上边和左边算内部，落在右边和下边不算在内部。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-14-37-58.png" alt><br>一个三角形相对于屏幕上很多像素点其实很小，如果把全部的像素点都测试一下的话慢而且没必要，就像白色那条像素一样，可以只测试这个三角形Bounding Box内的像素（蓝色区域），怎么计算这个Bounding Box呢？取P2 P1 P0这三个点的X最大和最小，Y最大最小，有了这四个数就可以得到一个矩形空间。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-17-46.png" alt><br>还可以每一行都找一下Bounding Box。  </p><h6 id="实际屏幕的光栅化"><a href="#实际屏幕的光栅化" class="headerlink" title="实际屏幕的光栅化"></a>实际屏幕的光栅化</h6><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-41-35.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-44-59.png" alt><br>注意打印是减色模式。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-45-53.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-46-06.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-46-31.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-46-50.png" alt><br>锯齿是光栅化一直在致力解决的问题。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-47-13.png" alt><br>有锯齿就有抗锯齿。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-47-42.png" alt>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GAMES101-现代计算机图形学入门-闫令琪(1-5) 课程学习笔记&lt;/p&gt;
&lt;h2 id=&quot;第一节-引入&quot;&gt;&lt;a href=&quot;#第一节-引入&quot; class=&quot;headerlink&quot; title=&quot;第一节 引入&quot;&gt;&lt;/a&gt;第一节 引入&lt;/h2&gt;&lt;p&gt;怎么判断一个游戏画面的技术水平，有一个很简单的方法就是画面亮不亮。&lt;/p&gt;
&lt;h2 id=&quot;第二节-线性代数&quot;&gt;&lt;a href=&quot;#第二节-线性代数&quot; class=&quot;headerlink&quot; title=&quot;第二节 线性代数&quot;&gt;&lt;/a&gt;第二节 线性代数&lt;/h2&gt;&lt;h3 id=&quot;向量&quot;&gt;&lt;a href=&quot;#向量&quot; class=&quot;headerlink&quot; title=&quot;向量&quot;&gt;&lt;/a&gt;向量&lt;/h3&gt;&lt;p&gt;向量是带有方向的量&lt;br&gt;重要的两个量是方向和长度&lt;br&gt;&lt;img src=&quot;/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-49-03.png&quot; alt&gt;  &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="computer graphics" scheme="http://yoursite.com/tags/computer-graphics/"/>
    
  </entry>
  
  <entry>
    <title>Maya卡顿优化</title>
    <link href="http://yoursite.com/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</id>
    <published>2020-03-09T15:50:34.000Z</published>
    <updated>2020-03-15T14:57:22.743Z</updated>
    
    <content type="html"><![CDATA[<p>针对美术制作的 Maya 卡顿优化</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h3><ul><li>解释分析器</li><li>求值工具包</li></ul><h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><h3 id="信息获取-1"><a href="#信息获取-1" class="headerlink" title="信息获取"></a>信息获取</h3><ul><li><p>Viewport 2.0,必须拥有正确的图形配置和图形驱动程序版本。有关 Maya 认证显卡和最新驱动程序版本的信息：</p><p><a href="https://knowledge.autodesk.com/certified-graphics-hardware" target="_blank" rel="noopener">https://knowledge.autodesk.com/certified-graphics-hardware</a></p></li></ul><ul><li><p>GPU 内存</p><p>对于包含大量纹理、几何体或缓存动画的场景，请务必记下显卡上可用的 GPU RAM 量，如果 GPU RAM 使用量非常接近显卡的 GPU RAM 限制，纹理可能无法加载，并且场景可能显示为着色模式。此时将显示一条错误信息，指明已超出纹理 RAM 限制并建议您减小“最大纹理分辨率”(Max Texture Resolution)钳制。</p><p>查看 GPU 内存使用情况（以 MB 为单位），请使用Mel命令 </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ogs -gpu</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/1558686550786.png" alt="1558686550786"></p></li><li><p>查看卡的 GPU RAM 限制，请参见“Maya 的输出窗口”(Output Window of Maya)。</p><p><img src="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/1558686723618.png" alt="图片1"></p></li></ul><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><ul><li><p>尽量关闭屏幕空间环境光遮挡、多重采样抗锯齿、运动模糊。</p></li><li><p>不使用复杂的Shader（例如复杂的 ShaderFX 网络）或大量使用 DirectX 11 ubershader 的场景。</p></li><li><p>禁用灯光和灯光阴影。</p></li><li><p>GPU 实例化可减少 GPU 内存使用量。</p><p><img src="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/1558687101606.png" alt="图片2"></p></li><li><p>减小摄影机的远剪裁距离，以便在视口中显示较少的几何体</p></li><li><p>隐藏无需显示的对象</p></li><li><p>卸载引用文件</p></li><li><p>将对象更改为Bounding Box模式</p></li><li><p>关闭多个Maya，同时运行 Maya 和其他 3D 程序，需要额外的 GPU 内存。</p></li><li><p>可以考虑使用GPU缓存工作流程</p><p><img src="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/1558688555512.png" alt="图片3"></p><p>关于GPU缓存工作流程的更多内容：</p><p><a href="https://knowledge.autodesk.com/zh-hans/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/CHS/Maya-ManagingScenes/files/GUID-C893BE60-6E65-4F36-8005-FD4D1A0E9822-htm.html" target="_blank" rel="noopener">https://knowledge.autodesk.com/zh-hans/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/CHS/Maya-ManagingScenes/files/GUID-C893BE60-6E65-4F36-8005-FD4D1A0E9822-htm.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;针对美术制作的 Maya 卡顿优化&lt;/p&gt;
&lt;h2 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h2&gt;&lt;h3 id=&quot;信息获取&quot;&gt;&lt;a href=&quot;#信息获取&quot; class=&quot;headerlink&quot; title=&quot;信息获取&quot;&gt;&lt;/a&gt;信息获取&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;解释分析器&lt;/li&gt;
&lt;li&gt;求值工具包&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;GPU&quot;&gt;&lt;a href=&quot;#GPU&quot; class=&quot;headerlink&quot; title=&quot;GPU&quot;&gt;&lt;/a&gt;GPU&lt;/h2&gt;&lt;h3 id=&quot;信息获取-1&quot;&gt;&lt;a href=&quot;#信息获取-1&quot; class=&quot;headerlink&quot; title=&quot;信息获取&quot;&gt;&lt;/a&gt;信息获取&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Viewport 2.0,必须拥有正确的图形配置和图形驱动程序版本。有关 Maya 认证显卡和最新驱动程序版本的信息：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://knowledge.autodesk.com/certified-graphics-hardware&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://knowledge.autodesk.com/certified-graphics-hardware&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GPU 内存&lt;/p&gt;
&lt;p&gt;对于包含大量纹理、几何体或缓存动画的场景，请务必记下显卡上可用的 GPU RAM 量，如果 GPU RAM 使用量非常接近显卡的 GPU RAM 限制，纹理可能无法加载，并且场景可能显示为着色模式。此时将显示一条错误信息，指明已超出纹理 RAM 限制并建议您减小“最大纹理分辨率”(Max Texture Resolution)钳制。&lt;/p&gt;
&lt;p&gt;查看 GPU 内存使用情况（以 MB 为单位），请使用Mel命令 &lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Maya" scheme="http://yoursite.com/tags/Maya/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客如何插入图片</title>
    <link href="http://yoursite.com/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-09T14:47:30.000Z</published>
    <updated>2020-03-15T14:57:22.797Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>首先确认主页配置的_config.yml中：post_asset_folder:true.<br><img src="/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-07.png" alt="图片测试0"></p></li><li><p>在你的hexo目录下执行：<br><code>npm install hexo-asset-image --save</code><br>若出现错误则先执行：<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><a id="more"></a></li><li><p>等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。</p></li><li><p>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中。<br><img src="/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-25.png" alt="图片测试1"></p></li><li><p>在xxxx.md中按照markdown的格式引入图片.</p></li></ol><p>引用：<br><a href="https://www.jianshu.com/p/a2786cdb06e1" target="_blank" rel="noopener">系列4：总结别人hexo博客如何插图片方法（有自己实现的图片实例）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先确认主页配置的_config.yml中：post_asset_folder:true.&lt;br&gt;&lt;img src=&quot;/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-07.png&quot; alt=&quot;图片测试0&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在你的hexo目录下执行：&lt;br&gt;&lt;code&gt;npm install hexo-asset-image --save&lt;/code&gt;&lt;br&gt;若出现错误则先执行：&lt;br&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="http://yoursite.com/2019/12/03/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/03/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-03T03:32:35.000Z</published>
    <updated>2020-03-15T14:57:22.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="1-设置-Git-全局用户名和邮箱"><a href="#1-设置-Git-全局用户名和邮箱" class="headerlink" title="1. 设置 Git 全局用户名和邮箱"></a>1. 设置 Git 全局用户名和邮箱</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;gitaccount&quot; #设置用户名</span><br><span class="line">$ git config --global user.email &quot;gitaccount@example.com&quot; #设置用户名</span><br><span class="line">$ git config --global user.name #查看用户名</span><br><span class="line">$ git config --global user.email #查看邮箱</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-使用流程命令"><a href="#2-使用流程命令" class="headerlink" title="2. 使用流程命令"></a>2. 使用流程命令</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git init #初始化仓库</span><br><span class="line">$ git status # 查看git版本控制状态</span><br><span class="line">$ git add xxxxxx # 加入文件tracked</span><br><span class="line">$ git commit -m &quot;描述&quot; #提交文件到暂存区</span><br><span class="line">$ git log #查看日志</span><br><span class="line">$ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;sunyuxianggit&#x2F;sunyuxianggit.github.io.git #预提交到远端仓库（关联本地和远程仓库）</span><br><span class="line">$ git push -u origin master</span><br><span class="line">$ git reset --hard HEAD^^ #一个^就是前一个版本两个就是前两个版本</span><br></pre></td></tr></table></figure><h5 id="3-常见报错"><a href="#3-常见报错" class="headerlink" title="3. 常见报错"></a>3. 常见报错</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists.</span><br><span class="line">$ git remote rm origin #删除远程 URL</span><br><span class="line">ref:https:&#x2F;&#x2F;blog.csdn.net&#x2F;top_code&#x2F;article&#x2F;details&#x2F;50381432</span><br></pre></td></tr></table></figure><h5 id="4-速度问题"><a href="#4-速度问题" class="headerlink" title="4. 速度问题"></a>4. 速度问题</h5><ul><li><p>设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; </span><br><span class="line">git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy</span><br><span class="line">git config --global https.proxy</span><br></pre></td></tr></table></figure></li><li><p>取消设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;h5 id=&quot;1-设置-Git-全局用户名和邮箱&quot;&gt;&lt;a href=&quot;#1-设置-Git-全局用户名和邮箱&quot; class=&quot;headerlink&quot; title=&quot;1. 设置 Git 全局用户名和邮箱&quot;&gt;&lt;/a&gt;1. 设置 Git 全局用户名和邮箱&lt;/h5&gt;   &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name &amp;quot;gitaccount&amp;quot; #设置用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email &amp;quot;gitaccount@example.com&amp;quot; #设置用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name #查看用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email #查看邮箱&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Python 进程和线程学习笔记</title>
    <link href="http://yoursite.com/2019/12/01/Python%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/01/Python%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-15T14:57:22.747Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="进程和线程概述"><a href="#进程和线程概述" class="headerlink" title="进程和线程概述"></a>进程和线程概述</h3><p>进程：对于操作系统来说，一个任务就是一个进程（Process）</p><p>线程：在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p></li><li><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multprocessing # Python 中的 multiprocess 包提供了多进程支持</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#process multprocessing包中的一个类表示进程对象</span><br><span class="line"></span><br><span class="line">from multiprocessing import Process</span><br><span class="line">from tqdm import tqdm</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid())) #getpid()可以拿到进程的ID。</span><br><span class="line">    for i in tqdm(range(10000000)):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;: </span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">有化部分 ，这句代码以上的部分，可以被其它的调用，以下的部分只有这个文件自己可以看见，如果文件被调用了，其他人是无法看见私有化部分的</span><br><span class="line">也就是说你自己运行该模块的时候 这句话是执行的 因为自己运行时__name__就是__main__，而当别人调用你这个模块时，以下代码会被忽略，此时的__name__是模块名</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    print(&#39;Parent process %s.&#39; % os.getpid())</span><br><span class="line">    p &#x3D; Process(target&#x3D;run_proc, args&#x3D;(&#39;test1&#39;,))</span><br><span class="line">    d &#x3D; Process(target&#x3D;run_proc, args&#x3D;(&#39;test2&#39;,))</span><br><span class="line">    print(&#39;Child process will start.&#39;)</span><br><span class="line">    p.start()#调用进程</span><br><span class="line">    d.start()#调用进程</span><br><span class="line">    p.join()#join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步</span><br><span class="line">    d.join()</span><br><span class="line">    print(&#39;Child process end.&#39;)</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#Pool multprocessing包中的一个类，如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</span><br><span class="line"></span><br><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def long_time_task(name):</span><br><span class="line">    # for i in tqdm(range(10000000)):</span><br><span class="line">    #     pass</span><br><span class="line">    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end &#x3D; time.time()</span><br><span class="line">    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    print(&#39;Parent process %s.&#39; % os.getpid())</span><br><span class="line">    p &#x3D; Pool(4)</span><br><span class="line">    #创建子进程池</span><br><span class="line">    #参数数决定同时运行多少进程 如果是4 task4会等待 0 1 2 3 运行完在运行，如果是5 就0 1 2 3 4 一起运行</span><br><span class="line">    #如果你的参数大于你的CPU线程数还是要等待</span><br><span class="line">    #把参数去掉，就是按照操作系统的核数来</span><br><span class="line">    </span><br><span class="line">    for i in range(13):</span><br><span class="line">        p.apply_async(long_time_task, args&#x3D;(i,)) #注意这里，因为是类所有调用函数是 P.</span><br><span class="line">    print(&#39;Waiting for all subprocesses done...&#39;)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&#39;All subprocesses done.&#39;)</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#这种方法可以实现任意进程间的通信，这里写的是主、子进程间的通信</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def foo(aa):#必须要接收一个元祖</span><br><span class="line">    message &#x3D; aa.get()  # 管子的另一端放在子进程这里，子进程接收到了数据</span><br><span class="line">    print(&#39;子进程已收到数据...&#39;)</span><br><span class="line">    print(message)  # 子进程打印出了数据内容...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;: </span><br><span class="line"></span><br><span class="line">    xt &#x3D; multiprocessing.Queue()  # 创建进程通信的Queue，你可以理解为我拿了个管子来...</span><br><span class="line">    jc &#x3D; multiprocessing.Process(target&#x3D;foo, args&#x3D;(xt,))  # multiprocessing.Process创建子进程</span><br><span class="line">    jc.start()  # 启动子进程</span><br><span class="line">    print(&#39;主进程准备发送数据...&#39;)</span><br><span class="line">    xt.put(&#39;有内鬼，终止交易！&#39;)  # 将管子的一端放在主进程这里，主进程往管子里丢入数据</span><br><span class="line">    jc.join()</span><br></pre></td></tr></table></figure><ul><li><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：</span><br><span class="line">import time, threading</span><br><span class="line"># 新线程执行的代码:</span><br><span class="line">def loop():</span><br><span class="line">    print(&#39;thread %s is running...&#39; % threading.current_thread().name)</span><br><span class="line">    n &#x3D; 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&#39;thread %s ended.&#39; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(&#39;thread %s is running...&#39; % threading.current_thread().name)</span><br><span class="line">t &#x3D; threading.Thread(target&#x3D;loop, name&#x3D;&#39;LoopThread&#39;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(&#39;thread %s ended.&#39; % threading.current_thread().name)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;进程和线程概述&quot;&gt;&lt;a href=&quot;#进程和线程概述&quot; class=&quot;headerlink&quot; title=&quot;进程和线程概述&quot;&gt;&lt;/a&gt;进程和线程概述&lt;/h3&gt;&lt;p&gt;进程：对于操作系统来说，一个任务就是一个进程（Process）&lt;/p&gt;
&lt;p&gt;线程：在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;multprocessing # Python 中的 multiprocess 包提供了多进程支持&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Houdini 学习笔记</title>
    <link href="http://yoursite.com/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-15T14:57:22.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><p>我们可以看到，houdini是一个将各种独立的语境（context）融合在一起的操作系统。<br><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-04-14-02-15.png" alt></p><a id="more"></a><h2 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h2><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><p><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-03-19-00-29.png" alt></p><ol><li>Detail 最高层级的数据，对应整个Object；</li><li>Primitive 几何对象中的组成部件，比如一个三角面片，一张NURBS曲面，或Volume；</li><li>Point 几何对象上面的一个点；</li><li>Vertex 一个Point可能同时存在于多个相邻的Primitive上，因此共享同一个Point的 多个primitive会各自存一份对Point的引用，称为Vertex。</li></ol><h3 id="属性优先级"><a href="#属性优先级" class="headerlink" title="属性优先级"></a>属性优先级</h3><p><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-04-16-03-43.png" alt></p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="属性-Attribute"><a href="#属性-Attribute" class="headerlink" title="属性 Attribute"></a>属性 Attribute</h3><p>最重要的数据类型就数属性了</p><h4 id="读取-修改属性"><a href="#读取-修改属性" class="headerlink" title="读取/修改属性"></a>读取/修改属性</h4><ul><li>使用已经定义的同层级属性的方式为：@变量名<ul><li>v@Cd 颜色属性</li><li>@P 位置属性</li><li>@ptnum 点ID</li><li>@primnum 图元ID</li></ul></li><li>不同层级之间的属性读取<ul><li>point(…)</li><li>prim(…)</li><li>detail(…)</li></ul></li></ul><h4 id="增加属性"><a href="#增加属性" class="headerlink" title="增加属性"></a>增加属性</h4><ul><li>数据类型 @变量名<ul><li>i@name（赋予整型）</li><li>i[]@name（赋予数组）</li></ul></li><li>在定义一个新的属性时，等号右边（即我们赋予该属性的初始值）必须是常量，也就是说只能是具体的数值， 不能包含任何函数或运算。<ul><li>对：float@mass=1；</li><li>错：float@mass =1/area;</li><li>错：vector @up = set(0,1,1);</li></ul></li></ul><h4 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h4><ul><li>属性在整个节点网络中，一旦你创建了，在人为手动删除它之前，就是一直存在并且全局都可见的（就是任何时候，只有你想要就可以读取）。因此属性是非常消耗空间和性能的，应当尽可能节约使用，如果预计将来再也不需要这个属性时，就应当使用Attribute Delete删除掉。</li><li><a href="https://link.zhihu.com/?target=https%3A//www.sidefx.com/docs/houdini/nodes/sop/attribdelete.html">Attribute Delete</a></li></ul><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><p> <img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/entagma_attributes.png" alt></p><h3 id="变量-Variable"><a href="#变量-Variable" class="headerlink" title="变量 Variable"></a>变量 Variable</h3><ul><li><p>一些VEX代码中的变量，如果它们只会在该节点的代码里面用到，那么就没有必要设置为属性了，我们称之为局部变量，就是它只属于所在的这个节点，节点算完之后就把它所占用的空间释放了，生不带来，死不带去。</p><p><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-02-26-17-23-21.png" alt></p></li><li><p>数组创建 float array_name[] </p></li><li><p>变量转向量 vector pos = set(x_var,y_var,z_var)</p></li></ul><h3 id="参数-Parameter"><a href="#参数-Parameter" class="headerlink" title="参数 Parameter"></a>参数 Parameter</h3><ul><li>参数一般出现在节点的paramter窗口，我们可以通过参数这些对节点进行调整。<br>参数非常重要，所以这里详细讲它的几种使用方式：<ul><li>在窗口上，对参数进行自动链接；<br>右键点击源参数，选择”Copy parameter”。<br>右击你要粘贴到的那个参数，选择”Paste relative reference”。</li><li>在窗口上，对参数进行手动链接；<br>此处使用的并不是VEX，而是HScript表达式，但是由于太重要了，就也写在这里：<br>在目标参数处输入函数ch(“源参数路径”)，源参数路径的格式有3种情况：<br><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-03-19-30-55.png" alt></li><li>在窗口上，手动创建参数；流程见下图，注意在”Parameter Description”一栏，我们新创建的变量有2个名称：Name和Label，Name是参数“真正”的名字，我们在使用ch(“参数名”)或者VEX内引用该参数时，都用的是Name，注意，Name不能包含空格；但是Label可以包含空格，作为参数在用户界面上显示的名称。<br><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-03-19-31-43.png" alt></li><li>在Wrangle节点里，用VEX代码读取窗口上的参数；同上，使用chi, chf, chv, chs即可。</li></ul></li></ul><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li><p>printf 打印函数<br>  <code>printf(&quot;str&quot;);</code></p></li><li><p>addpoint 添加点函数</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addpoint</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="keyword">int</span> point_number)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addpoint</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">vector</span> pos)</span></span></span><br></pre></td></tr></table></figure></li><li><p>addprim 添加图元函数<br>  Adds a primitive to the geometry.</p><p>  <code>int  addprim(int geohandle, string type)</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addprim</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> type, <span class="keyword">int</span> pt0)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addprim</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> type, <span class="keyword">int</span> pt0, <span class="keyword">int</span> pt1)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addprim</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> type, <span class="keyword">int</span> pt0, <span class="keyword">int</span> pt1, <span class="keyword">int</span> pt2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addprim</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> type, <span class="keyword">int</span> pt0, <span class="keyword">int</span> pt1, <span class="keyword">int</span> pt2, <span class="keyword">int</span> pt3)</span></span></span><br></pre></td></tr></table></figure></li><li><p>addvertex 添加顶点函数<br>  Adds a vertex to a primitive in a geometry.<br>  <code>int  addvertex(int geohandle, int prim_num, int point_num)</code></p></li><li><p>rand 随机函数<br>  Creates a random number between 0 and 1 from a seed.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">float  rand(float seed)</span><br><span class="line">vector2  rand(float seed)</span><br><span class="line">vector  rand(float seed)</span><br><span class="line">vector4  rand(float seed)</span><br><span class="line">float  rand(float seed, float seed2)</span><br><span class="line">vector2  rand(float seed, float seed2)</span><br><span class="line">vector  rand(float seed, float seed2)</span><br><span class="line">vector4  rand(float seed, float seed2)</span><br><span class="line">float  rand(vector2 seed)</span><br><span class="line">vector2  rand(vector2 seed)</span><br><span class="line">vector  rand(vector2 seed)</span><br><span class="line">vector4  rand(vector2 seed)</span><br><span class="line">float  rand(vector seed)</span><br><span class="line">vector2  rand(vector seed)</span><br><span class="line">vector  rand(vector seed)</span><br><span class="line">vector4  rand(vector seed)</span><br><span class="line">float  rand(vector4 seed)</span><br><span class="line">vector2  rand(vector4 seed)</span><br><span class="line">vector  rand(vector4 seed)</span><br><span class="line">vector4  rand(vector4 seed)</span><br></pre></td></tr></table></figure></li><li><p>fit 重映射函数<br>  Takes the value in one range and shifts it to the corresponding value in a new range.<br>  <code>float  fit(float value, float omin, float omax, float nmin, float nmax)</code></p></li><li><p>ch 滑块函数<br>  Evaluates a channel (or parameter) and return its value.<br>  <code>ch(&quot;string&quot;);</code></p></li><li><p>curlnoise 卷曲噪点函数<br>  Computes divergence free noise based on Perlin noise.<br>  <code>vector  curlnoise(vector xyz);</code><br>  <code>vector  curlnoise(vector4 xyzt)</code></p></li><li><p>push 数组添加元素函数<br>  Adds an item to an array.<br>  <code>void  push(&lt;type&gt;&amp;array[], &lt;type&gt;value)</code><br>  <code>void  push(&lt;type&gt;&amp;array[], &lt;type&gt;values[])</code></p></li><li><p>pop 数组弹出函数<br>  Removes the last element of an array and returns it. <code>&lt;type&gt; pop(&lt;type&gt;&amp;array[])</code><br>  <code>&lt;type&gt; pop(&lt;type&gt;&amp;array[], int index)</code></p></li><li><p>removeindex 数组删除元素函数<br>  Removes an item at the given index from an array.<br>  <code>&lt;type&gt; removeindex(&lt;type&gt;&amp;array[], int index)</code></p></li><li><p>nearpoint 查找最近顶点函数<br>  Finds the closest point in a geometry. </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">nearpoint</span><span class="params">(&lt;geometry&gt;geometry, <span class="built_in">vector</span> pt)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">nearpoint</span><span class="params">(&lt;geometry&gt;geometry, <span class="built_in">vector</span> pt, <span class="keyword">float</span> maxdist)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">nearpoint</span><span class="params">(&lt;geometry&gt;geometry, <span class="built_in">string</span> ptgroup, <span class="built_in">vector</span> pt)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">nearpoint</span><span class="params">(&lt;geometry&gt;geometry, <span class="built_in">string</span> ptgroup, <span class="built_in">vector</span> pt, <span class="keyword">float</span> maxdist)</span></span></span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">    </span><br><span class="line">* nearpoints 查找最近顶点函数 </span><br><span class="line">    Finds the closest point in a geometry. </span><br><span class="line">​&#96;&#96;&#96;c</span><br><span class="line">    int [] nearpoints(&lt;geometry&gt;geometry, vector pt, float maxdist)</span><br><span class="line">    </span><br><span class="line">    int [] nearpoints(&lt;geometry&gt;geometry, vector pt, float maxdist, int maxpts)</span><br><span class="line">    </span><br><span class="line">    int [] nearpoints(&lt;geometry&gt;geometry, string ptgroup, vector pt, float maxdist)</span><br><span class="line">    </span><br><span class="line">    int [] nearpoints(&lt;geometry&gt;geometry, string ptgroup, vector pt, float maxdist, int maxpts)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>point 从几何体上读取点的某个属性的值函数<br>  Reads a point attribute value from a geometry.<br>  <code>point(&lt;geometry&gt;geometry, string attribute_name, int pointnumber)</code></p></li><li><p>primpoints 从几何体上读取点函数<br>  Returns the list of points on a primitive.<br>  <code>int [] primpoints(&lt;geometry&gt;geometry, int primnum)</code></p></li><li><p>distance 距离函数<br>  Returns the distance between two points.<br>  <code>float  distance(vector2 a, vector2 b)</code></p></li><li><p>removepoint 删除点函数<br>  Removes a point from the geometry.<br>  <code>int  removepoint(int geohandle, int point_number)</code></p></li><li><p>primpoint 将图元/顶点转换为点的ID函数.<br>  Converts a primitive/vertex pair into a point number.<br>  <code>int primpoint(&lt;geometry&gt;, int primnum, int vertex)</code></p></li><li><p>itoa 整型转字符串函数<br>  Converts an integer to a string.<br>  <code>string  itoa(int number)</code></p></li><li><p>getbbox_max 计算几何的边界框的最小值函数<br>  Returns the maximum of the bounding box for the geometry..<br>  <code>vector  getbbox_max(geometry)</code></p></li><li><p>getbbox_max 计算几何的边界框的最大值函数<br>  Computes the minimum of the bounding box for the geometry.<br>  <code>vector  getbbox_max(&lt;geometry&gt;geometry, string primgroup)</code></p></li><li><p>getbbox_size 返回边界框的尺寸函数<br>  Returns the size of the bounding box for the geometry.<br>  <code>vector  getbbox_size(&lt;geometry&gt;geometry)</code><br>  <code>vector  getbbox_size(&lt;geometry&gt;geometry, string primgroup)</code></p></li><li><p>lerp 在值之间执行双线性插值函数</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Performs bilinear interpolation between the values.</span><br><span class="line"><span class="function"><span class="keyword">float</span>  <span class="title">lerp</span><span class="params">(<span class="keyword">float</span> value1, <span class="keyword">float</span> value2, <span class="keyword">float</span> amount)</span></span></span><br><span class="line">Performs bilinear interpolation between corresponding components.</span><br><span class="line">&lt;<span class="built_in">vector</span>&gt; lerp(&lt;<span class="built_in">vector</span>&gt;value1, &lt;<span class="built_in">vector</span>&gt;value2, <span class="keyword">float</span> amount)</span><br></pre></td></tr></table></figure></li><li><p>removeprim 删除图元函数<br>  Removes a primitive from the geometry.<br>  <code>int  removeprim(int geohandle, int prim_number, int andpoints)</code></p></li><li><p>pow 冪函數<br>  Raises the first argument to the power of the second argument.</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span>  <span class="title">pow</span><span class="params">(<span class="keyword">float</span> n, <span class="keyword">float</span> exponent)</span></span></span><br><span class="line">&lt;vector&gt; pow(&lt;vector&gt;v, float exponent)</span><br></pre></td></tr></table></figure></li><li><p>setpointattrib设置顶点属性函数<br>  Sets a point attribute in a geometry.</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">setpointattrib</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> name, <span class="keyword">int</span> point_num, &lt;type&gt;value, <span class="built_in">string</span> mode=<span class="string">"set"</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">setpointattrib</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> name, <span class="keyword">int</span> point_num, &lt;type&gt;value[], <span class="built_in">string</span> mode=<span class="string">"set"</span>)</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>npoints 得到几何体的点数函数<br>  Returns the number of points in the input or geometry file.<br>  <code>int  npoints(&lt;geometry&gt;geometry)</code></p></li><li><p>resize 设置数组长度函数<br>  Sets the length of an array.<br>  <code>void  resize(&lt;type&gt;&amp;array[], int size)</code></p></li><li><p>argsort 数组排序函数<br>  Returns the indices of a sorted version of an array.<br>  <code>int [] argsort(&lt;type&gt;value[])</code></p></li><li><p>setpointgroup 添加点组函数<br>  Adds or removes a point to/from a group in a geometry.<br>  <code>int  setpointgroup(int geohandle, string name, int point_num, int value, string mode=&quot;set&quot;)</code><br>  geohandle</p><p>  A handle to the geometry to write to. Currently the only valid value is 0 or geoself, which means the current geometry in a node. (This argument may be used in the future to allow writing to other geometries.)</p><p>  name</p><p>  The name of the group to modify.</p><p>  point_num</p><p>  The point number to add or remove from the group.</p><p>  value</p><p>  1 to put the point in the group, 0 to remove the point from the group. This is ignored if mode is “toggle”.</p><p>  mode</p><p>  Use “set” to set the point’s membership according to the value. Use “toggle” to toggle the point’s membership, regardless of the value.</p></li><li><p>pointprims 返回一个图元包含的点函数<br>  pointprims<br>  Returns the list of primitives containing a point.<br>  <code>int [] pointprims(&lt;geometry&gt;geometry, int ptnum)</code></p></li></ul><ul><li>intersect 计算射线与几何的交叉函数<br>  This function computes the first intersection of a ray with geometry.</li></ul><ul><li><p>detail 从几何读取详细信息属性值的函数</p><p>  Reads the value of a detail attribute value from a geometry.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type&gt; detail(&lt;geometry&gt;geometry, string attribute_name, int ignored&#x3D;0)</span><br><span class="line"></span><br><span class="line">&lt;type&gt;[] detail(&lt;geometry&gt;geometry, string attribute_name, int ignored&#x3D;0)</span><br></pre></td></tr></table></figure></li><li><p>radians 弧度函数<br>  Converts the argument from degrees into radians.<br>  从度数转弧度<br>  <code>float  radians(float num_in_degs)</code></p></li><li><p>rotate  旋转函数<br>  Applies a rotation to the given matrix.</p>  <figure class="highlight plain"><figcaption><span>rotate(matrix2 &m, float amount)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void  rotate(matrix3 &amp;m, float amount, vector axis)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix &amp;m, float amount, vector axis)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix3 &amp;m, vector angles, int xyz)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix &amp;m, vector angles, int xyz)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix3 &amp;m, float angle, int axis)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix &amp;m, float angle, int axis)</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* scale 缩放函数</span><br><span class="line">    Scales the given matrix in three directions simultaneously (X, Y, Z - given by the components of the scale_vector)</span><br></pre></td></tr></table></figure><p>  void  scale(matrix2 &amp;m, vector2 scale_vector)</p><p>  void  scale(matrix &amp;m, vector scale_vector)</p><p>  void  scale(matrix3 &amp;m, vector scale_vector)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* translate 位移函数</span><br><span class="line">    Translates a matrix by a vector.</span><br></pre></td></tr></table></figure><p>  void  translate(matrix &amp;m, vector amount)</p><p>  void  translate(matrix &amp;m, vector4 amount)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* quaternion  四元数函数</span><br><span class="line">    Creates a vector4 representing a quaternion.</span><br><span class="line">    创建一个表示四元数的vector4</span><br></pre></td></tr></table></figure><p>  vector4  quaternion(matrix3 rotations)</p><p>  Creates a vector4 representing a quaternion from a 3×3 rotational matrix.</p><p>  vector4  quaternion(float angle, vector axis)</p><p>  Creates a vector4 representing a quaternion from an angle and axis. The angle is specified in radians.</p><p>  vector4  quaternion(vector angleaxis)</p><p>  Creates a vector4 representing a quaternion from a combined angle/axis. This is the normalized rotation axis multiplied by the rotation angle in radians.</p><p>  There used to be a fourth form that took a rotation vector. It has been renamed to eulertoquaternion and now takes radians.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* qrotate 四元数旋转函数</span><br><span class="line"></span><br><span class="line">    Rotates a vector by a quaternion.</span><br><span class="line">    通过四元数旋转向量。</span><br><span class="line">    &#96;vector  qrotate(vector4 quaternion, vector v)&#96;</span><br><span class="line"></span><br><span class="line">* slerp 四元数基于偏差的融和函数</span><br><span class="line"></span><br><span class="line">    Quaternion blend between q1 and q2 based on the bias.</span><br><span class="line">    &#96;vector4  slerp(vector4 q1, vector4 q2, float bias)&#96;</span><br><span class="line"></span><br><span class="line">* primintrinsic  从几何读取基本图元函数</span><br><span class="line"></span><br><span class="line">    Reads a primitive intrinsic from a geometry.</span><br><span class="line">    从几何读取基本图元</span><br></pre></td></tr></table></figure><p>  <type> primintrinsic(<geometry>geometry, string intrinsic_name, int prim_num)</geometry></type></p><p>  <type>[] primintrinsic(<geometry>geometry, string intrinsic_name, int prim_num)</geometry></type></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 常用表达式</span><br><span class="line">* $FF 帧变量</span><br><span class="line"></span><br><span class="line">## 节点</span><br><span class="line"></span><br><span class="line">* scatter</span><br><span class="line">撒点 散布节点</span><br><span class="line"></span><br><span class="line">* isooffset</span><br><span class="line">配合散布节点使用 可以散布到物体内部并且在位置上有一定随机</span><br><span class="line"></span><br><span class="line">* attribute randomize</span><br><span class="line">随机某个属性</span><br><span class="line"></span><br><span class="line">* attribute paint</span><br><span class="line">绘制变量属性,结合scatter可以实现局部撒点</span><br><span class="line"></span><br><span class="line">* relax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 快捷键</span><br><span class="line">* 弹出代码框 ALT+E</span><br><span class="line">* 弹出当前选中的功能区 ALT + SHIFT+ C</span><br><span class="line">* 调整焦点 选中相机视口 回车（Show handle）+ Z</span><br><span class="line"></span><br><span class="line">## vex语法</span><br><span class="line"></span><br><span class="line">* for 循环</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;c</span><br><span class="line">    for(int i &#x3D; 0 ; i&gt;num;i++)&#123;</span><br><span class="line">        something;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>foreach循环</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach(<span class="keyword">int</span> npt;npts)&#123;</span><br><span class="line">    something;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>条件判断</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if()&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if()&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br><span class="line">else if()&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="外部函数导入和外部编辑器设置"><a href="#外部函数导入和外部编辑器设置" class="headerlink" title="外部函数导入和外部编辑器设置"></a>外部函数导入和外部编辑器设置</h2><ul><li>外部编辑器设置<ol><li>找到 C:\Users\username\Documents\houdini18.0 下找到** houdini.env **</li><li>加入这一行代码  注意路径和路径反斜线写法<br><code>Editor = &quot;C:/Users/username/AppData/Local/Programs/Microsoft VS Code/Code.exe&quot;</code></li><li>然后重启houdini</li></ol></li><li>外部函数导入<ol><li>找到 C:\Users\username\Documents\houdini18.0 下找到** houdini.env **</li><li>加入这一行代码  注意路径反斜线写法和结尾字符<br><code>HOUDINI_VEX_PATH = &quot;C:/Users/sunyuxiang/Documents/houdini18.0/Custom_VEX;&amp;&quot;</code></li><li>然后把函数放到这里即可C:\Users\sunyuxiang\Documents\houdini18.0\Custom_VEX</li><li>然后重启houdini</li><li>调用方法 #include “你的函数文件夹名”</li></ol></li><li>打开代码窗口<ol><li>Alt+E</li></ol></li></ul><h2 id="每节例子总结"><a href="#每节例子总结" class="headerlink" title="每节例子总结"></a>每节例子总结</h2><ul><li><p>给顶点的法线信息指认随机生成的向量，通过滑块调整随机种子</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> seed = chf(<span class="string">"seed"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set random scale (0 ... 0.1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> pscale = rand(@ptnum+seed);<span class="comment">//定义一个 浮点变量</span></span><br><span class="line">pscale *= <span class="number">.1</span>; <span class="comment">//浮点变量缩小十分之1</span></span><br><span class="line">f@pscale = pscale; <span class="comment">//设置属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set random orientation using N(&#123;-1,-1,-1&#125; ... &#123;1,1,1&#125;)</span></span><br><span class="line"><span class="built_in">vector</span> randdir = rand(@ptnum+seed);</span><br><span class="line"></span><br><span class="line"><span class="comment">//randdir = fit(randdir,&#123;0,0,0&#125;,&#123;1,1,1&#125;,&#123;-1,-1,-1&#125;,&#123;1,1,1&#125;);</span></span><br><span class="line"><span class="comment">// 因为@ptnum是正轴递增，所以random的结果太相似 所以重新映射一下</span></span><br><span class="line">randdir = fit01(randdir,&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">//给顶点的法线信息指认随机生成的向量</span></span><br><span class="line">v@N = randdir;</span><br></pre></td></tr></table></figure></li><li><p>所有点的向量实时指向某个点<br>  为了得到指向某个点的向量，我们需要用目标点减去基点如图：<br>  <img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-02-18-20-23-42.png" alt></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//拿到接口1的 第0个顶点的属性名"P"的值</span></span><br><span class="line"><span class="built_in">vector</span> tgtpos = <span class="built_in">point</span>(<span class="number">1</span>,<span class="string">"P"</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 目标点减去 模板点 得到向量</span></span><br><span class="line"><span class="built_in">vector</span> dir = tgtpos - v@P;</span><br><span class="line"><span class="comment">//归一化向量</span></span><br><span class="line"><span class="comment">//v@N =dir;</span></span><br><span class="line">v@N =normalize(dir);</span><br></pre></td></tr></table></figure></li><li><p>使用卷积化随机函数创建向量赋予点</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> f = chv(<span class="string">"Frequency"</span>);</span><br><span class="line"><span class="built_in">vector</span> o = chv(<span class="string">"offset"</span>);</span><br><span class="line"><span class="comment">//这里是卷积化随机向量</span></span><br><span class="line"><span class="built_in">vector</span> dir = curlnoise((v@P * f)+ o);</span><br><span class="line"><span class="comment">//归一化向量</span></span><br><span class="line">v@N =normalize(dir);</span><br></pre></td></tr></table></figure></li></ul><ul><li>使用nearpoints函数查找最近的点并创建线  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">float</span> maxdist = chf(<span class="string">"max_Dist"</span>);</span><br><span class="line"><span class="keyword">float</span> mindist = chf(<span class="string">"Min_Dist"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到函数</span></span><br><span class="line"><span class="keyword">int</span> npts[] = nearpoints(<span class="number">0</span>,v@P,maxdist);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除找到的自己</span></span><br><span class="line">removeindex(npts,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋予属性给点</span></span><br><span class="line">i[]@npts = npts;</span><br><span class="line"></span><br><span class="line">foreach(<span class="keyword">int</span> npt;npts)&#123;</span><br><span class="line">    <span class="built_in">vector</span> npos = <span class="built_in">point</span>(<span class="number">0</span>,<span class="string">"p"</span>,npt);</span><br><span class="line">    <span class="keyword">float</span> dist = distance(v@P,npos);</span><br><span class="line">    <span class="keyword">if</span>(dist &gt; mindist)&#123;</span><br><span class="line">        addprim(<span class="number">0</span>,<span class="string">"polyline"</span>,@ptnum,npt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="理解矩阵很好的教程"><a href="#理解矩阵很好的教程" class="headerlink" title="理解矩阵很好的教程"></a>理解矩阵很好的教程</h2><p> <img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/entagma_martrix.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;软件结构&quot;&gt;&lt;a href=&quot;#软件结构&quot; class=&quot;headerlink&quot; title=&quot;软件结构&quot;&gt;&lt;/a&gt;软件结构&lt;/h2&gt;&lt;p&gt;我们可以看到，houdini是一个将各种独立的语境（context）融合在一起的操作系统。&lt;br&gt;&lt;img src=&quot;/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-04-14-02-15.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Houdini" scheme="http://yoursite.com/tags/Houdini/"/>
    
  </entry>
  
  <entry>
    <title>Top 10 ways to make Maya go FASTER</title>
    <link href="http://yoursite.com/2019/12/01/Top%2010%20ways%20to%20make%20Maya%20go%20FASTER/"/>
    <id>http://yoursite.com/2019/12/01/Top%2010%20ways%20to%20make%20Maya%20go%20FASTER/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-15T14:57:22.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1关闭一些显示设置："><a href="#1关闭一些显示设置：" class="headerlink" title="1关闭一些显示设置："></a>1关闭一些显示设置：</h2><p>首先是阴影，然后OCC，然后运动模糊然后抗锯齿</p><h2 id="2关闭材质球实时预览"><a href="#2关闭材质球实时预览" class="headerlink" title="2关闭材质球实时预览"></a>2关闭材质球实时预览</h2><p>可以改用右键单个refresh swatch</p><h2 id="3选择暂停viewport"><a href="#3选择暂停viewport" class="headerlink" title="3选择暂停viewport"></a>3选择暂停viewport</h2><a id="more"></a><h2 id="4确保不实用的插件不加载"><a href="#4确保不实用的插件不加载" class="headerlink" title="4确保不实用的插件不加载"></a>4确保不实用的插件不加载</h2><p>还可以导入的时候不自动载入ref，选择手动载入</p><h2 id="5关闭模型的Adaptive-open-Subdiv"><a href="#5关闭模型的Adaptive-open-Subdiv" class="headerlink" title="5关闭模型的Adaptive open Subdiv"></a>5关闭模型的Adaptive open Subdiv</h2><h2 id="6设置Viewport2-0"><a href="#6设置Viewport2-0" class="headerlink" title="6设置Viewport2.0"></a>6设置Viewport2.0</h2><p>1浮点渲染目标，此设置与色彩管理有关系，代价是CPU的RAM</p><p>推荐，R32G32B32A32_Float &gt; R16G16B16A16_Float</p><p>也可以完全禁用</p><p>2性能下把透明贴图算法改成 Alpha Cut</p><p>代价是牺牲了半透明的效果，但是提高了速度</p><h2 id="7使用贴图时，最轻量的贴图是JPEG"><a href="#7使用贴图时，最轻量的贴图是JPEG" class="headerlink" title="7使用贴图时，最轻量的贴图是JPEG"></a>7使用贴图时，最轻量的贴图是JPEG</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1关闭一些显示设置：&quot;&gt;&lt;a href=&quot;#1关闭一些显示设置：&quot; class=&quot;headerlink&quot; title=&quot;1关闭一些显示设置：&quot;&gt;&lt;/a&gt;1关闭一些显示设置：&lt;/h2&gt;&lt;p&gt;首先是阴影，然后OCC，然后运动模糊然后抗锯齿&lt;/p&gt;
&lt;h2 id=&quot;2关闭材质球实时预览&quot;&gt;&lt;a href=&quot;#2关闭材质球实时预览&quot; class=&quot;headerlink&quot; title=&quot;2关闭材质球实时预览&quot;&gt;&lt;/a&gt;2关闭材质球实时预览&lt;/h2&gt;&lt;p&gt;可以改用右键单个refresh swatch&lt;/p&gt;
&lt;h2 id=&quot;3选择暂停viewport&quot;&gt;&lt;a href=&quot;#3选择暂停viewport&quot; class=&quot;headerlink&quot; title=&quot;3选择暂停viewport&quot;&gt;&lt;/a&gt;3选择暂停viewport&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="maya" scheme="http://yoursite.com/tags/maya/"/>
    
  </entry>
  
  <entry>
    <title>Python文件打包成可执行文件</title>
    <link href="http://yoursite.com/2019/12/01/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/12/01/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-15T14:57:22.754Z</updated>
    
    <content type="html"><![CDATA[<p>Python是一个脚本语言，被解释器解释执行。它的发布方式：</p><h2 id="py-文件"><a href="#py-文件" class="headerlink" title=".py 文件"></a>.py 文件</h2><p>没什么好讲的，开源项目或者个人练习，直接提供源码最简单粗暴，需要使用者自行安装Python并且安装依赖的各种库。</p><h2 id="pyc-文件"><a href="#pyc-文件" class="headerlink" title=".pyc 文件"></a>.pyc 文件</h2><p>如果觉得源码写的差劲不好意思被别人看到，或者出于保密等不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#代码</span><br><span class="line">import py_compile</span><br><span class="line">py_compile.compile(&quot;D:\Python\main.py&quot;)            # 相对路径或绝对路径</span><br><span class="line"></span><br><span class="line">#命令行下</span><br><span class="line">python -m py_compile test.py</span><br><span class="line">#会在相同路径里面创建__pycache__文件夹，编译过的pyc文件就在里面</span><br><span class="line"></span><br><span class="line">#多个文件</span><br><span class="line">import compileall</span><br><span class="line">compileall.compile_dir(&quot;存放海量py的目录&quot;)</span><br></pre></td></tr></table></figure><h2 id="可执行exe文件"><a href="#可执行exe文件" class="headerlink" title="可执行exe文件"></a>可执行exe文件</h2><ul><li><p>pyInstaller</p><pre><code>1.安装pyInstaller</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pyinstaller #安装</span><br><span class="line">$ pyinstaller --version #查看版本</span><br></pre></td></tr></table></figure><p>  2.如果查看版本报错</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;pyinstall&#39; is not recognized as an internal or external command,operable program or batch file.#需要系统变量里的Path变量下添加其所在目录，然后重启命令行即可.</span><br></pre></td></tr></table></figure><p>  3.使用pyInstaller：</p><figure class="highlight plain"><figcaption><span>-F helloworld.py```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">- py2exe</span><br><span class="line"></span><br><span class="line">1. 命令行&#96;&#96;pip install py2exe&#96;&#96;安装</span><br><span class="line"></span><br><span class="line">1. 在命令行内测试你的程序确定可以运行</span><br><span class="line"></span><br><span class="line">   &#96;&#96;python helloworld.py&#96;&#96;</span><br><span class="line"></span><br><span class="line">2. 创建你自己的执行脚本 (setup.py)</span><br></pre></td></tr></table></figure><pre><code>from distutils.core import setupimport py2exe</code></pre></li></ul><pre><code>   setup(console=[&quot;helloworld.py&quot;]) #这里helloworld.py替换成你的脚本   ``` 3. 在命令行Run your setup script    ``python setup.py py2exe`` 4. 然后再dist文件夹下就会看到生成的.exe 文件了5. 如果出现``IndexError: tuple index out of range``的话是因为py2exe停止支持3.4以上版本，可以换用这个地方的py2exe, 但是好像也是有问题   ref：https://stackoverflow.com/questions/41578808/python-indexerror-tuple-index-out-of-range-when-using-py2exe   ref：https://github.com/albertosottile/py2exe</code></pre><ul><li><p>cx_Freeze</p><ol><li><p><code>$ pip install cx_Freeze</code>安装</p></li><li><p><code>$ cxfreeze hello.py --target-dir dist</code>生成执行文件，如果报错无法识别就参考这个解决</p><p>ref:<a href="https://stackoverflow.com/questions/25242860/cxfreeze-command-not-found-in-windows/25243419#25243419" target="_blank" rel="noopener">https://stackoverflow.com/questions/25242860/cxfreeze-command-not-found-in-windows/25243419#25243419</a> </p></li></ol></li><li><p>auto-py-to-exe 2.6.6</p><ol><li><code>$ pip install auto-py-to-exe</code> 安装</li><li>````$ auto-py-to-exe`` 使用</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python是一个脚本语言，被解释器解释执行。它的发布方式：&lt;/p&gt;
&lt;h2 id=&quot;py-文件&quot;&gt;&lt;a href=&quot;#py-文件&quot; class=&quot;headerlink&quot; title=&quot;.py 文件&quot;&gt;&lt;/a&gt;.py 文件&lt;/h2&gt;&lt;p&gt;没什么好讲的，开源项目或者个人练习，直接提供源码最简单粗暴，需要使用者自行安装Python并且安装依赖的各种库。&lt;/p&gt;
&lt;h2 id=&quot;pyc-文件&quot;&gt;&lt;a href=&quot;#pyc-文件&quot; class=&quot;headerlink&quot; title=&quot;.pyc 文件&quot;&gt;&lt;/a&gt;.pyc 文件&lt;/h2&gt;&lt;p&gt;如果觉得源码写的差劲不好意思被别人看到，或者出于保密等不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo创建个人blog网页的笔记</title>
    <link href="http://yoursite.com/2019/12/01/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E7%BD%91%E9%A1%B5%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/01/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E7%BD%91%E9%A1%B5%E7%9A%84%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-15T14:57:22.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装支持软件"><a href="#安装支持软件" class="headerlink" title="安装支持软件"></a>安装支持软件</h2><ol><li><p>下载并安装node.js.<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p></li><li><p>下载好可以在cmd里面通过查看版本号来确认安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v #参看node版本号</span><br><span class="line">$ npm -v # 查看npm包管理器版本号</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>由于npm国内下载包速度太慢，所以可以里面npm安装一个cnpm（使用淘宝源）加快速度，不需要可以跳过，同理可以通过查看版本号确认安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry&#x3D;&quot;https:&#x2F;&#x2F;registry.npm.taobao.org&quot; #-g表示全局安装</span><br><span class="line">$ cnpm -v#参看cnpm 版本号</span><br></pre></td></tr></table></figure></li><li><p>使用cnpm 安装hexo，同理可以通过查看版本号确认安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g hexo-cli #全局安装hexo</span><br><span class="line">$ hexo -v #参看hexo版本号</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用hexo搭建博客"><a href="#使用hexo搭建博客" class="headerlink" title="使用hexo搭建博客"></a>使用hexo搭建博客</h2><ol><li><p>首先建立一个空的文件夹blog</p></li><li><p>命令行进入blog文件夹</p></li><li><p>使用hexo生成博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init #生成博客</span><br></pre></td></tr></table></figure></li><li><p>使用hexo server进行本地预览博客，预览完成后Ctrl+C退出预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s#本地预览博客</span><br></pre></td></tr></table></figure></li><li><p>使用hexo new 新建文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n &quot;文章名&quot;</span><br></pre></td></tr></table></figure></li><li><p>先使用hexo clean 清除已经创建的页面，在使用hexo generated生成页面，建议生成先进行本地预览。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean #清除</span><br><span class="line">$ hexo g #生成</span><br></pre></td></tr></table></figure></li></ol><h2 id="如何把博客布置到github上"><a href="#如何把博客布置到github上" class="headerlink" title="如何把博客布置到github上"></a>如何把博客布置到github上</h2><ol><li><p>首先在github自己的账号内新建仓库，注意仓库名就是你的域名。仓库名必须是 [账户名.github.io]</p></li><li><p>安装git并在git下设置用户名和邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name [username]</span><br><span class="line">git config --global user.email [email]</span><br></pre></td></tr></table></figure></li><li><p>在bolg文件夹下安装git部署插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>设置一下bolg文件夹的_config.yml，注意每个冒号后面有空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git </span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;sunyuxianggit&#x2F;sunyuxianggit.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>部署到github，中间需要输入github的账号密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo doploy#部署到GitHub</span><br></pre></td></tr></table></figure></li><li><p>常见错误：</p><ul><li><p>fatal: in unpopulated submodule ‘.deploy_git’</p><p> 这种情况可以先安装下相关的依赖：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git –save</span><br><span class="line">$ rm -rf .deploy_git#删掉</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d#重新生成和部署</span><br></pre></td></tr></table></figure></li><li><p>执行hexo inint 命令报错hexo:无法加载文件…..\npm\hexo.psl，因为在此系统中禁止运行脚本<br><a href="https://blog.csdn.net/JONE_WUQINGJIANG/article/details/103044919" target="_blank" rel="noopener">https://blog.csdn.net/JONE_WUQINGJIANG/article/details/103044919</a></p></li><li><p>安装hexo后，初始化博客，出现bash: hexo: command not found<br>找到C:\Users\Administrator\AppData\Roaming\npm\node_modules\hexo\bin\，将此目录新增到path环境变量中(注：Administrator改成你自己的账户名)</p></li><li><p>重新安装hexo <code>npm install -g hexo-cli</code>如果出现如下错误<br><a href="https://blog.csdn.net/liting1996/article/details/79612248" target="_blank" rel="noopener">https://blog.csdn.net/liting1996/article/details/79612248</a></p></li><li><p>重新安装npm <code>npm install -g npm</code></p></li></ul></li></ol><h2 id="日常更新文章"><a href="#日常更新文章" class="headerlink" title="日常更新文章"></a>日常更新文章</h2><ol><li>命令行进入blog文件夹使用<code>$ hexo new</code> 新建文章</li><li>使用<code>$ hexo clean</code>清除老页面，然后在使用<code>$ hexo generated</code>生成页面</li><li>使用<code>$ hexo server</code>本地预览没有问题后，使用 <code>$ hexo deploy</code>部署到Github</li></ol><h2 id="如何更换主题"><a href="#如何更换主题" class="headerlink" title="如何更换主题"></a>如何更换主题</h2><ol><li><p>命令行进入blog</p></li><li><p>使用git clone 功能 clone喜欢的主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;Molunerfinn&#x2F;hexo-theme-melody.git</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: yilia#这里</span><br></pre></td></tr></table></figure></li></ol><h2 id="多台设备同步管理"><a href="#多台设备同步管理" class="headerlink" title="多台设备同步管理"></a>多台设备同步管理</h2><ol><li>原创建博客设备把源文件上传到GitHub，上传时注意检查所有.gitignore文件忽略情况和把node_modules文件夹删掉（因为内部文件名太长，上传的话git报错）.</li><li>另一台电脑上将源代码clone下来之后，直接执行 <code>cnpm install</code>把node_modules安装回来.</li><li>然后<code>hexo s</code>正常使用.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装支持软件&quot;&gt;&lt;a href=&quot;#安装支持软件&quot; class=&quot;headerlink&quot; title=&quot;安装支持软件&quot;&gt;&lt;/a&gt;安装支持软件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载并安装node.js.&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载好可以在cmd里面通过查看版本号来确认安装成功。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ node -v #参看node版本号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm -v # 查看npm包管理器版本号&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>

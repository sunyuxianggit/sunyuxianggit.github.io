<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Sun Yuxiang"><meta name="copyright" content="Sun Yuxiang"><title>好记性,不如烂笔头.今天你要写点什么？ | SunYuxiangのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="SunYuxiangのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Sun Yuxiang</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/sunyuxianggit" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SunYuxiangのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">文章</a><a class="site-page" href="/archives">归档</a></span></div><div id="site-info"><div id="site-title">SunYuxiangのBlog</div><div id="site-sub-title">好记性,不如烂笔头.今天你要写点什么？</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/10/Effective-Python/">Effective Python</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/python/">python</a></span><div class="content"><h1 id="Effective-Python"><a href="#Effective-Python" class="headerlink" title="Effective Python"></a>Effective Python</h1><h1 id="编写高质量代码的59-91个建议读书笔记"><a href="#编写高质量代码的59-91个建议读书笔记" class="headerlink" title="编写高质量代码的59+91个建议读书笔记"></a>编写高质量代码的59+91个建议读书笔记</h1><h3 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h3><ul>
<li>确认自己所用的python版本。</li>
<li>确保该版本与你想使用的python版本相符。</li>
<li>优先使用python3</li>
</ul>
<h5 id="Windows下："><a href="#Windows下：" class="headerlink" title="Windows下："></a>Windows下：</h5><p><code>$python --version</code><br><img src="/2020/03/10/Effective-Python/2020-03-07-11-15-23.png" alt="a"></p>
<h5 id="其他程序内："><a href="#其他程序内：" class="headerlink" title="其他程序内："></a>其他程序内：</h5><ul>
<li><p>Autodesk Maya:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-18-24.png" alt="b"></p>
</li>
<li><p>Substance Designer:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-19-36.png" alt="c"><br>注：SD里sys.version_info报错，原因未知</p>
</li>
<li><p>Houdini：<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-22-33.png" alt="d"></p>
</li>
</ul>
<p>Tips： Python中sys模块还有一个常用功能：<br><code>sys.path</code>可以用来找到应用程序内的python编译器位置.</p>
<h3 id="第二条"><a href="#第二条" class="headerlink" title="第二条"></a>第二条</h3><p>遵循PEP8 风格指南<br>《Python Enhancement Proposal #8》（8号Python增强法案）又叫PEP8,它是针对Python代码格式而编订的风格指南。</p>
<ul>
<li>使用空格来表示缩进，而不要用制表符（tab）。</li>
<li>和语法相关的每一层缩进都用四个空格表示。</li>
<li>每行的字符数不应超过79。</li>
<li>对于占据多行的长表达式，除了首行之外的其余各行都应该在通常的缩进级别之上再加四个空格。</li>
<li>文件中的代码与函数和类之间应该用两个空行隔开。</li>
<li>在同一个类中，各方法之间应该用一个空行隔开。</li>
<li>在使用下标来获取列表元素、调用函数或给关键字参数赋值的时候，不要再两边添加空格。</li>
<li>为变量赋值的时候，赋值符号的左侧和右侧应该各自写上一个空格，而且只写一个。</li>
</ul>
<p>命名：PEP8 提倡采用不同的命名风格来编写Python代码中的各个部分,以便再阅读代码时可以根据这些名称看出它们的角色。</p>
<ul>
<li>函数、变量名及属性应该用小写字母，各单词之间用下划线相连，例如，lowercase_underscore。</li>
<li>受保护的实例属性，应该以单个下划线开头，例如，_leading_underscore.</li>
<li>私有的实例属性，应该以两个下划线开头，例如__double_leading_underscore.</li>
<li>类与异常， 应该以每个单词首字母均大写的形式来命名，例如，CapitalizedWord。</li>
<li>模块级别的常量，应该全部采用大写字母来拼写，各单词之间以下划线连接，例如，ALL_CAPS。</li>
<li>类中的实例方法（instance method），应该把首个参数命名self，以表示该对象自身.</li>
<li>类方法（class method）的首个参数，应该命名cls，以表示该类自身。</li>
</ul>
<p>表达式和语句《The Zen of Python》（python之禅）中说，每件事都应该有直白的做法，而且最好只有一种。</p>
<ul>
<li>采用内联形式的否定词 ，而不要把否定词放在整个表达式的前面，例如，应该写 if a is not b 而不是 if not a is b。</li>
<li>不要通过检测长度的方法来判断列表是否为空，而是应该采用if not somelist来判定。</li>
<li>同上条，如果判断列表不为空也是一样的， </li>
<li>不要编写单行的if语句、for循环、while循环及except复合语句，而是应该把这些语句分成多行来书写，以示清晰。</li>
<li>import语句应该重视放在文件开头.</li>
<li>引入模块的时候，总是应该使用绝对名称，而不应该根据当前模块的路径来使用相对名称，例如，引入bar包中的foo模块时，应该完成的写出 from bar import foo，而不应该简写为import foo。</li>
<li>如果一定要以相对的名称来编写import语句，那就采用明确的写法:from.import foo。</li>
<li>文件中的那些import语句应该按照顺序划分为三个部分，分别为标准库模块、第三方模块以及自用模块。各import语句应该按照模块的字母顺序来排列。</li>
</ul>
<p>Tips： vscode可以采用pylint来自动检测受测代码是否符合pep8。<br><a href="https://www.pylint.org/" target="_blank" rel="noopener">https://www.pylint.org/</a></p>
<h3 id="第三条"><a href="#第三条" class="headerlink" title="第三条"></a>第三条</h3><h5 id="了解bytes、str、和unicode的区别"><a href="#了解bytes、str、和unicode的区别" class="headerlink" title="了解bytes、str、和unicode的区别"></a>了解bytes、str、和unicode的区别</h5><ul>
<li>python3有两种表示字符序列的类型，bytes和str，前者的实例中包含原始的8位值，后者的实例中包含Unicode字符。</li>
<li>python2中也有两种表示字符序列的类型，str和Unicode. 前者包含原始的八位值，后者的实例着包含unicode字符。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-29-10.png" alt="e"></li>
<li>bytes 类型，是指一堆字节的集合，十六进制表现形式，两个十六进制数构成一个 byte ，以 b 开头的字符串是 bytes 类型。计算机只能存储二进制，字符、图片、视频、音乐等想存到硬盘上，必须以正确的方式编码成二进制后再存，但是转成二进制后不是直接以 0101010 的形式表示的，而是用bytes() 的类型来表示的。</li>
<li>把Unicode字符表示为二进制数据（原始八位值）有很多办法，常见且推荐的编码方式就是UTF-8。</li>
<li>但是python3 的str实例和python2的Unicode实例都没有和特定的二进制编码形式相关联，想要把Unicode字符转换为二进制数据，就必须使用encode方法，想要把二进制数据转化成为Unicode字符，则必须使用decode 方法。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-34-59.png" alt="f"></li>
<li>在 Python3 中内存里的字符串是以 Unicode 编码的，Unicode 的其中一个特性就是跟所有语言编码都有映射关系，所以 UTF-8 格式的文件，在 Windows 电脑上若是不能看，就可以把 UTF-8 先解码成 Unicode ，再由 Unicode 编码成 GBK 就可以了。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-32-20.png" alt="g"><h5 id="字符串的转换"><a href="#字符串的转换" class="headerlink" title="字符串的转换"></a>字符串的转换</h5></li>
<li>在Python3中，接受str或byts，并总是返回str的方法:  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, bytes):<span class="comment">#注意这个函数</span></span><br><span class="line">        value = bytes_or_str.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li>
<li>接受str或bytes，并总是返回bytes的方法：  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li>
<li>在Python2中，接受str或unicode，并总是返回unicode的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_unicode(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, str):</span><br><span class="line">        value &#x3D; unicode_or_str.decode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure></li>
<li>接受str或unicode，并总是返回str的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_str(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, unicode):</span><br><span class="line">        value &#x3D; unicode_or_str.encode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure>
<h5 id="推荐的文件操作符"><a href="#推荐的文件操作符" class="headerlink" title="推荐的文件操作符"></a>推荐的文件操作符</h5>如果通过open函数获取文件句柄，该句柄会采用UTF-8编码格式来操作文件。<br>而在Python2中，文件操作的默认编码格式则是二进制形式。这可能会导致程序出现奇怪的错误。<br>例如，向文件中随机写入一些二进制数据。下面这种方法Python2中可以正常运行，但是在Python3中则不行：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TypeError: must be str, <span class="keyword">not</span> bytes</span><br></pre></td></tr></table></figure>
上述情况是因为Python3给open函数添加了名为encoding的新参数，而这个新参数默认值是’utf-8′。这样在文件句柄上进行read和write操作时，系统就要求开发者必须传入包含unicode字符的str实例，而不接受包含二进制数据的bytes实例。</li>
</ul>
<p>解决这个问题，可以用二进制写入模式(‘wb’)来开启待操作的文件，按照这种方式可同时适配Python2和Python3：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>(读取文件也同理，可使用’rb’模式)</p>
<h3 id="第四条"><a href="#第四条" class="headerlink" title="第四条"></a>第四条</h3><p>用辅助函数来取代复杂的表达式</p>
<ul>
<li>开发者很容易过度运用Python的语法特性，从而写出那种特别复杂并且难以理解的单行表达式。</li>
<li>请把复杂的表达式移入辅助函数中。如果要反复使用相同的逻辑，那就更应该那么做。</li>
<li>使用if/esle表达式，要比用or或者and 这样的Boolean操作符写出的表达式更清晰。</li>
</ul>
<h3 id="第五条"><a href="#第五条" class="headerlink" title="第五条"></a>第五条</h3><p>了解切割序列的方法<br>python提供了一种把序列切成小块的写法，这种切片操作很容易四开发者轻易的访问序列中的某些元素所构成的子集。<br>最简单的用法，就是对内置list和bytes进行切割。<br>切割操作还可以延伸到实现了<strong>getitem</strong>和<strong>setitem</strong>这两个特殊方法的python类上，参见28条。</p>
<ul>
<li>不要写多余的代码。但start索引为零或者end索引为序列长度时，应该将其忽略</li>
<li>切片操作不会计较start或者end索引是否越界，这样我们很容易从前端或者后端开始。</li>
<li>对list赋值时，如果使用切片操作，就会把原列表中处在相关范围内的值替换成新值，即便它们的长度不同也依然可以替换。</li>
</ul>
<h3 id="第六条"><a href="#第六条" class="headerlink" title="第六条"></a>第六条</h3><p>在单词切片操作内，不要同时指定start、 end 和 stride </p>
<ul>
<li>问题在于采用stride方式进行切片时，经常会出现不符合预期的结果</li>
<li>切割列表时，如果制定了stride，代码就会变得费解。尤其是stride为负值的时候更是如此.</li>
<li>在同一个切片操作内，不要同时使用start、end和stride. 如果确实需要执行这种操作，那就考虑将其拆解为两条赋值语句，其中一条做范围切割，另一条做步进，或者考虑使用内置itertools模块中的islice.</li>
</ul>
<p>tips：<br><code>mystring[::-1]#反转字符串</code></p>
<h3 id="第七条"><a href="#第七条" class="headerlink" title="第七条"></a>第七条</h3><p>用列表推导来取代map和filter<br>python提供了一种精炼的写法，可以根据一个列表来制作另外一个列表.这种表达式称为list comprehension （列表推导）</p>
<ul>
<li>列表推导要比内置的map和filter函数清晰</li>
<li>列表推导可以很跳过输入列表中的某些元素</li>
<li>字典与集也支持推导表达式</li>
</ul>
<h3 id="第八条"><a href="#第八条" class="headerlink" title="第八条"></a>第八条</h3><p>不要使用含有两个以上表达式的列表推导</p>
<ul>
<li>列表推导支持多级循环，每一级循环也支持多项条件</li>
<li>超过两个表达式的列表推导难以理解，应该尽量避免<br>Tips：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br><span class="line">print(flat)</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="comment">#下面两种写法是等效的</span></span><br><span class="line"><span class="comment">#要从列表中取出大于4的偶数</span></span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">if</span> x %<span class="number">2</span> ==<span class="number">0</span>]</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">and</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="第九条"><a href="#第九条" class="headerlink" title="第九条"></a>第九条</h3><p>用生成器表达式来改写数据量较大的列表推导<br>列表推导的缺点是，对于输入序列中的每个值来说，都要创建一项仅含一项元素的全新列表，但输入数据较大时，可能会消耗大量内存，并导致程序崩溃。<br>为了解决此问题，python 提供了生成式表达式</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt))</span><br><span class="line">print(it)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x101b81480</span>&gt;</span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">57</span></span><br></pre></td></tr></table></figure>

<p>Tips：<br>获取文件每行的字符数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt)]</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure>

<ul>
<li>当输入的数据量较大时，列表推导可能会因为占用太对内存而出问题。</li>
<li>由生成表达式所返回的迭代器，可以逐次产生输出值，从而避免了内存用量问题。</li>
<li>把某个生成器表达式说返回的迭代器，放在另一个生成器表达式的for子表达式中，即可将二者组合起来。</li>
<li>串在一起的生成器表达式执行速度很快。 </li>
</ul>
<h3 id="第十条"><a href="#第十条" class="headerlink" title="第十条"></a>第十条</h3><p>尽量用enumerate取代range<br>在一些列的整数上面迭代，内置的range函数很有用，<br>当迭代列表的时候，通常还想知道当前元素在列表中的索引。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(flavor_list)):</span><br><span class="line">    flavor = flavor_lsit[i]</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure>
<p>这种代码不利于理解，python提供了enumerate来解决此问题。enumerate可以把各种迭代器包装为生成器，以便稍后产生输出值，生成器每次产生一对输出值，前者为循环下标，后者表示从迭代器中获取到的下一个序列元素，这样写出来的代码会非常整洁。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure>

<ul>
<li>enumerate函数提供了一种精简的写法，可以在遍历迭代器时获知每个元素的索引</li>
<li>尽量用enumerate来改写那种将range与下标访问相结合的序列遍历代码</li>
<li>可以给enumerate 提供第二个参数，已指定开始计数时所用的值（默认为0）</li>
</ul>
<p>Tips:<br>还可以直接指定enumerate开始计数所用的值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list，<span class="number">1</span>):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i,flavor))</span><br></pre></td></tr></table></figure>

<h3 id="第十一条"><a href="#第十一条" class="headerlink" title="第十一条"></a>第十一条</h3><p>用zip函数同时遍历两个迭代器</p>
<ul>
<li><p>使用for循环</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Cecilia</span><br></pre></td></tr></table></figure>
<p>上面这段代码问题在一，整个循环语句看上去很乱，用下标来访问names和letters会使代码不易阅读。<br>改用enumerate可以稍稍缓解这个问题，但仍然不够理想。</p>
</li>
<li><p>使用for循环加enumerate</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names)：</span><br><span class="line">    count =letters[i]</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure></li>
<li><p>使用zip</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letter):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置的zip函数可以平行的遍历多个迭代器</p>
</li>
<li><p>Python3中的zip相当于生成器，会在遍历过程中逐次产生元组，而Python2中的zip则是直接把这些元组完全生成号，并一次性的返回给整份列表。</p>
</li>
<li><p>如果提供的迭代器长度不等，那么zip就会自动提前终止。</p>
</li>
<li><p>itertools 内置模块中的zip_longest函数可以平行的遍历多个迭代器，而不用在乎它们的长度是否相等。</p>
</li>
</ul>
<h3 id="不要在for和while循环后面写else语块"><a href="#不要在for和while循环后面写else语块" class="headerlink" title="不要在for和while循环后面写else语块"></a>不要在for和while循环后面写else语块</h3><ul>
<li>python 有种特殊语法，可在 for及 while 循环的内部语句块之后紧跟一个else块。</li>
<li>只有当整个循环主体都没遇到break语句时，循环后面的else块才会执行。</li>
<li>不要再循环后面使用else块，因为在这种写法即不直观，又容易引人误解。</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/lipandeng/p/11162039.html" target="_blank" rel="noopener">https://www.cnblogs.com/lipandeng/p/11162039.html</a><br><a href="https://lingyunfx.com/?page_id=152" target="_blank" rel="noopener">https://lingyunfx.com/?page_id=152</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/10/GameCourse101/">GameCourse101</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/computer-graphics/">computer graphics</a></span><div class="content"><h1 id="GameCourse101"><a href="#GameCourse101" class="headerlink" title="GameCourse101"></a>GameCourse101</h1><p>计算机图形学入门 课程学习笔记</p>
<h2 id="第一节-引入"><a href="#第一节-引入" class="headerlink" title="第一节 引入"></a>第一节 引入</h2><h2 id="第二节-线性代数"><a href="#第二节-线性代数" class="headerlink" title="第二节 线性代数"></a>第二节 线性代数</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量是带有方向的量<br>重要的两个量是方向和长度<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-49-03.png" alt><br>数学： 向量<br>物理： 矢量<br>向量长度：<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-49-24.png" alt><br>向量加法（求和）：<br>几何上<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-49-38.png" alt><br>数学上<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-49-58.png" alt><br>我们把向量表示成直角坐标系这种形式是有助于计算向量的长度的。  </p>
<h4 id="向量的点乘和叉乘"><a href="#向量的点乘和叉乘" class="headerlink" title="向量的点乘和叉乘"></a>向量的点乘和叉乘</h4><p>向量更广泛的用法<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-50-12.png" alt>  </p>
<h5 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-12-50-25.png" alt><br>左边是两个向量，右边是一个数字。<br>如果两个向量都是单位向量，那么它们点乘的结果就是余弦的值。  </p>
<p><img src="/2020/03/10/GameCourse101/2020-03-08-12-58-31.png" alt><br>点乘既然是一种运算，运算法则都会满足一些性质。<br>交换律 结合律 分配律  </p>
<p><img src="/2020/03/10/GameCourse101/2020-03-08-13-08-11.png" alt><br>如果是在坐标系下，就跟简单。  </p>
<p><img src="/2020/03/10/GameCourse101/2020-03-08-13-02-30.png" alt>  </p>
<ol>
<li>点乘在图形学最重要的作用就是找到两个向量的夹角。<br>比如 光从哪个地方射过来（向量）物体表面法线是什么样的（向量）我们从哪里看（向量）</li>
<li>第二个重要作用就是找到一个向量的投影到另一个向量是长什么样的。<br>投影算出来有什么好处呢？ 我们可以把一个向量分解成两个向量，一个平行一个垂直。这样可以帮助我们把任意向量分解到任意坐标轴。<br> <img src="/2020/03/10/GameCourse101/2020-03-08-13-17-01.png" alt></li>
<li>在图形学里，我们还可以根据点乘的结果判定两个向量是否接近是否远离。</li>
<li>向量点乘还可以告诉大家一个前与后的信息，如图（向量a和向量b点乘为正值且接近1，向量a和向量c点乘为负值，如果有一个向量跟向量a一样，那点乘结果为1，如果有一个向量正好在虚线上，那点乘的值为0，如果跟向量a正好相反，那点乘结果为-1）<br><img src="/2020/03/10/GameCourse101/2020-03-08-13-44-08.png" alt>  </li>
</ol>
<h5 id="叉乘（叉积）"><a href="#叉乘（叉积）" class="headerlink" title="叉乘（叉积）"></a>叉乘（叉积）</h5><p>叉乘是给定两个向量计算出同时垂直与这两个向量的新的向量，另外同时垂直这两个向量也就是必然垂直这两个向量形成的平面<br><img src="/2020/03/10/GameCourse101/2020-03-08-13-57-13.png" alt><br>右手螺旋定则（DirectX是右手，openGL是左手），伸出右手，除了拇指以外的四个手指比作向量a，向内握紧比作向量a向向量b运动，那么大拇指就是叉乘的结果。xy，<br>向量的叉乘并不满足交换律<br>向量的叉积还有一个作用是我们利用它来建立一个三维空间中的直角坐标系<br><img src="/2020/03/10/GameCourse101/2020-03-08-14-04-16.png" alt><br>几何：<br><img src="/2020/03/10/GameCourse101/2020-03-08-14-36-32.png" alt>  </p>
<p>叉积怎么算，有什么用处：<br><img src="/2020/03/10/GameCourse101/2020-03-08-14-37-55.png" alt><br>特别重要 </p>
<p><img src="/2020/03/10/GameCourse101/2020-03-08-14-38-58.png" alt></p>
<ol>
<li>判定左和右<br>如图左侧，XY为平面，通过右手螺旋定则，Z为朝向我们自身的向量，如果想判断向量b在向量a左侧还是右侧（什么是左侧右侧? 从向量a顺时针旋转到达向量b为左侧，逆时针为右侧），在这里根据图示很容易看出来向量b是在向量a的左侧，如果用数字表示就是 向量a叉乘向量b得到的结果是正值（指向身体）就说明向量b在向量a的左侧，如果向量b叉乘向量a得到的结果是负值（指向身体外侧），那就说明向量a在向量b右侧，</li>
<li>判定内与外<br>如图右侧，先判断向量AP是否在向量AB的左侧，在判断向量BP是否在向量BC的左侧，在判断向量AP是否在ac的左侧，如果都是在左侧就说明点P在三角形内部，否则肯定有一个判断是在右侧。<br>这里假设了ABC三个点是逆时针排布，如果换成顺时针也没有问题，只不过是都在左侧。<br>所以我们可以忽略三角形的排布顺序，只要三个边左或者右保持一致就说明点在三角形内部。这点非常重要，是光栅化的基础（用来判断像素是否在三角形的内部）。</li>
</ol>
<h4 id="向量定义坐标系"><a href="#向量定义坐标系" class="headerlink" title="向量定义坐标系"></a>向量定义坐标系</h4><p><img src="/2020/03/10/GameCourse101/2020-03-08-15-51-31.png" alt><br>向量叉乘可以定义一些互相垂直的轴，就会形成坐标系如图。<br><img src="/2020/03/10/GameCourse101/2020-03-08-15-52-25.png" alt><br>这里顶一个uvw坐标系，三个向量单位长度都为1，互相垂直，给你u和v 叉乘得到w。<br>我们可以利用投影把任意一个向量分解到三个轴上去，利用点乘，因为什么呢？向量P点乘向量U，等于是向量P的长度乘以向量U的长度在乘以cosθ，向量U又恰好是单位向量为1，等于是向量P的长度乘以cosθ，根据下图三角函数，就会得出向量P在向量U上的投影，同理获得向量P在向量V和向量W上的投影，有了这三个投影就可以获得坐标系下的这个向量。<br><img src="/2020/03/10/GameCourse101/2020-03-08-16-07-00.png" alt><br>cosA = c/b  </p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><img src="/2020/03/10/GameCourse101/2020-03-08-16-47-04.png" alt><br><strong>在图像学里，变换就是矩阵的最大应用。</strong><br><img src="/2020/03/10/GameCourse101/2020-03-08-20-44-32.png" alt>  </p>
<h5 id="矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量"><a href="#矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量" class="headerlink" title="矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量."></a>矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量.</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-20-53-06.png" alt><br>矩阵乘矩阵必须要符合条件才能乘，如图必须第一个矩阵的列数和第二个矩阵的行数相同相乘才有意义。<br>关于新得到的矩阵每一个元素都是什么，有不同的数学定义，这个地方比较不容易记住，这里给大家提供一个容易记得方法，比如左下角这个8，他的坐标是三行一列，这里三行对应第一个矩阵（0，4），一列对应第二个矩阵（3，2），这两个向量点乘。<br><img src="/2020/03/10/GameCourse101/2020-03-08-21-50-50.png" alt><br>矩阵乘法是没有交换律的，但是矩阵是由结合律和分配律。  </p>
<h5 id="矩阵乘向量"><a href="#矩阵乘向量" class="headerlink" title="矩阵乘向量"></a>矩阵乘向量</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-21-53-53.png" alt></p>
<blockquote>
<p>一个矩阵如何和一个向量乘？当我们认为向量是列向量就有意义了（也就是说M永远为1）。    </p>
</blockquote>
<p><em>这是最重要的核心。</em><br>下面表示一个2D向量按Y轴镜像的操作。</p>
<h5 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-22-01-06.png" alt><br>性质： 如果要乘两个矩阵在转置好比相对后一个矩阵做装置在乘以前一个矩阵做转置的结果。</p>
<h5 id="特殊的矩阵，单位矩阵"><a href="#特殊的矩阵，单位矩阵" class="headerlink" title="特殊的矩阵，单位矩阵"></a>特殊的矩阵，单位矩阵</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-22-07-51.png" alt><br>对角阵，只有对角线上有非零的元素，<br>矩阵的逆：如果你能找到一个矩阵，和原来的矩阵相乘，不管乘得顺序，得到的结果都是I，那么我们就认为这两个矩阵是互逆的。<br>逆矩阵的计算和转置的矩阵很相似。</p>
<h5 id="向量点乘和叉乘的矩阵形式"><a href="#向量点乘和叉乘的矩阵形式" class="headerlink" title="向量点乘和叉乘的矩阵形式"></a>向量点乘和叉乘的矩阵形式</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-22-12-11.png" alt><br>点乘：向量a点乘向量b 等于向量a转置和向量b的乘法。<br>叉乘：相对点乘困难一些，相当于把向量a转换成一个矩阵（dual matrix）乘以向量b</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/10/Top%2010%20ways%20to%20make%20Maya%20go%20FASTER/">Top 10 ways to make Maya go FASTER</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time><div class="content"><h1 id="Top-10-ways-to-make-Maya-go-FASTER"><a href="#Top-10-ways-to-make-Maya-go-FASTER" class="headerlink" title="Top 10 ways to make Maya go FASTER"></a>Top 10 ways to make Maya go FASTER</h1><h2 id="1关闭一些显示设置："><a href="#1关闭一些显示设置：" class="headerlink" title="1关闭一些显示设置："></a>1关闭一些显示设置：</h2><p>首先是阴影，然后OCC，然后运动模糊然后抗锯齿</p>
<h2 id="2关闭材质球实时预览"><a href="#2关闭材质球实时预览" class="headerlink" title="2关闭材质球实时预览"></a>2关闭材质球实时预览</h2><p>可以改用右键单个refresh swatch</p>
<h2 id="3选择暂停viewport"><a href="#3选择暂停viewport" class="headerlink" title="3选择暂停viewport"></a>3选择暂停viewport</h2></div><a class="more" href="/2020/03/10/Top%2010%20ways%20to%20make%20Maya%20go%20FASTER/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/10/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/">Python文件打包成可执行文件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time><div class="content"><h1 id="Python文件打包成可执行文件"><a href="#Python文件打包成可执行文件" class="headerlink" title="Python文件打包成可执行文件"></a>Python文件打包成可执行文件</h1><p>Python是一个脚本语言，被解释器解释执行。它的发布方式：</p>
<h2 id="py-文件"><a href="#py-文件" class="headerlink" title=".py 文件"></a>.py 文件</h2><p>没什么好讲的，开源项目或者个人练习，直接提供源码最简单粗暴，需要使用者自行安装Python并且安装依赖的各种库。</p>
<h2 id="pyc-文件"><a href="#pyc-文件" class="headerlink" title=".pyc 文件"></a>.pyc 文件</h2><p>如果觉得源码写的差劲不好意思被别人看到，或者出于保密等不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。</p></div><a class="more" href="/2020/03/10/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/10/Python%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Python 进程和线程学习笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time><div class="content"><h1 id="Python-进程和线程学习笔记"><a href="#Python-进程和线程学习笔记" class="headerlink" title="Python 进程和线程学习笔记"></a>Python 进程和线程学习笔记</h1><ul>
<li><h3 id="进程和线程概述"><a href="#进程和线程概述" class="headerlink" title="进程和线程概述"></a>进程和线程概述</h3><p>进程：对于操作系统来说，一个任务就是一个进程（Process）</p>
<p>线程：在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>
</li>
<li><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multprocessing # Python 中的 multiprocess 包提供了多进程支持</span><br></pre></td></tr></table></figure></li></ul></div><a class="more" href="/2020/03/10/Python%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/10/Blender%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Blender脚本学习笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time><div class="content"><h1 id="Blender脚本学习笔记"><a href="#Blender脚本学习笔记" class="headerlink" title="Blender脚本学习笔记"></a>Blender脚本学习笔记</h1><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul>
<li><p>安装python3.0以上(Blender 2.8是 python3.x)</p>
</li>
<li><p>Vscode 安装python 和 blender Development 插件</p>
</li>
<li><p>终端安装 fake-bpy 包<code>pip install fake-bpy-module-2.80</code></p>
<p> <a href="https://github.com/nutti/fake-bpy-module" target="_blank" rel="noopener">https://github.com/nutti/fake-bpy-module</a></p>
<p>安装完上面这些，vscode里面就会有自动补全</p>
<p>Debug</p>
</li>
<li><p>ctrl + shift + P, select “Blender: Start”</p>
</li>
<li><p>选择你的blender安装路径, vscode会连接到blender</p>
</li>
<li><p>ctrl + shift + P, “Blender: Run script” 并且可以使用断点调试</p></li></ul></div><a class="more" href="/2020/03/10/Blender%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/">Maya卡顿优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-09</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Maya/">Maya</a></span><div class="content"><h1 id="针对美术制作的-Maya-卡顿优化"><a href="#针对美术制作的-Maya-卡顿优化" class="headerlink" title="针对美术制作的 Maya 卡顿优化"></a>针对美术制作的 Maya 卡顿优化</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h3><ul>
<li>解释分析器</li>
<li>求值工具包</li>
</ul>
<h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><h3 id="信息获取-1"><a href="#信息获取-1" class="headerlink" title="信息获取"></a>信息获取</h3><ul>
<li><p>Viewport 2.0,必须拥有正确的图形配置和图形驱动程序版本。有关 Maya 认证显卡和最新驱动程序版本的信息：</p>
<p><a href="https://knowledge.autodesk.com/certified-graphics-hardware" target="_blank" rel="noopener">https://knowledge.autodesk.com/certified-graphics-hardware</a></p>
</li>
</ul>
<ul>
<li><p>GPU 内存</p>
<p>对于包含大量纹理、几何体或缓存动画的场景，请务必记下显卡上可用的 GPU RAM 量，如果 GPU RAM 使用量非常接近显卡的 GPU RAM 限制，纹理可能无法加载，并且场景可能显示为着色模式。此时将显示一条错误信息，指明已超出纹理 RAM 限制并建议您减小“最大纹理分辨率”(Max Texture Resolution)钳制。</p>
<p>查看 GPU 内存使用情况（以 MB 为单位），请使用Mel命令 </p></li></ul></div><a class="more" href="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/">Hexo博客如何插入图片</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-09</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/misc/">misc</a></span><div class="content"><h1 id="Hexo博客如何插入图片"><a href="#Hexo博客如何插入图片" class="headerlink" title="Hexo博客如何插入图片"></a>Hexo博客如何插入图片</h1><ol>
<li><p>首先确认主页配置的_config.yml中：post_asset_folder:true.<br><img src="/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-07.png" alt="图片测试0"></p>
</li>
<li><p>在你的hexo目录下执行：<br><code>npm install hexo-asset-image --save</code><br>若出现错误则先执行：<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
</li>
<li><p>等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。</p>
</li>
<li><p>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中。<br><img src="/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-25.png" alt="图片测试1"></p>
</li>
<li><p>在xxxx.md中按照markdown的格式引入图片.</p>
</li>
</ol>
<p>引用：<br><a href="https://www.jianshu.com/p/a2786cdb06e1" target="_blank" rel="noopener">系列4：总结别人hexo博客如何插图片方法（有自己实现的图片实例）</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/03/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Git 学习笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-03</time><div class="content"><h1 id="Git-学习笔记"><a href="#Git-学习笔记" class="headerlink" title="Git 学习笔记"></a>Git 学习笔记</h1><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="1-设置-Git-全局用户名和邮箱"><a href="#1-设置-Git-全局用户名和邮箱" class="headerlink" title="1. 设置 Git 全局用户名和邮箱"></a>1. 设置 Git 全局用户名和邮箱</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;gitaccount&quot; #设置用户名</span><br><span class="line">$ git config --global user.email &quot;gitaccount@example.com&quot; #设置用户名</span><br><span class="line">$ git config --global user.name #查看用户名</span><br><span class="line">$ git config --global user.email #查看邮箱</span><br></pre></td></tr></table></figure></div><a class="more" href="/2019/12/03/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/01/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E7%BD%91%E9%A1%B5%E7%9A%84%E7%AC%94%E8%AE%B0/">使用hexo创建个人blog网页的笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/">个人笔记</a></span><div class="content"><h2 id="安装支持软件"><a href="#安装支持软件" class="headerlink" title="安装支持软件"></a>安装支持软件</h2><ol>
<li><p>下载并安装node.js.<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
</li>
<li><p>下载好可以在cmd里面通过查看版本号来确认安装成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v #参看node版本号</span><br><span class="line">$ npm -v # 查看npm包管理器版本号</span><br></pre></td></tr></table></figure></li></ol></div><a class="more" href="/2019/12/01/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E7%BD%91%E9%A1%B5%E7%9A%84%E7%AC%94%E8%AE%B0/#more">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Sun Yuxiang</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://sunyuxianggit.github.io/" target="_blank" rel="noopener">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>
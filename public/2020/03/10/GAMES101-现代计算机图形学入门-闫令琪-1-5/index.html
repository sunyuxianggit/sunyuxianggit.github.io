<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="GAMES101-现代计算机图形学入门-闫令琪(1-5)"><meta name="keywords" content="computer graphics"><meta name="author" content="Sun Yuxiang"><meta name="copyright" content="Sun Yuxiang"><title>GAMES101-现代计算机图形学入门-闫令琪(1-5) | SunYuxiangのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="SunYuxiangのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一节-引入"><span class="toc-number">1.</span> <span class="toc-text">第一节 引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二节-线性代数"><span class="toc-number">2.</span> <span class="toc-text">第二节 线性代数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#向量"><span class="toc-number">2.1.</span> <span class="toc-text">向量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#向量的点乘和叉乘"><span class="toc-number">2.1.1.</span> <span class="toc-text">向量的点乘和叉乘</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#点乘"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">点乘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#叉乘（叉积）"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">叉乘（叉积）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向量定义坐标系"><span class="toc-number">2.1.2.</span> <span class="toc-text">向量定义坐标系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩阵"><span class="toc-number">2.2.</span> <span class="toc-text">矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#矩阵相乘"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">矩阵相乘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#矩阵乘向量"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">矩阵乘向量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#矩阵转置"><span class="toc-number">2.2.0.4.</span> <span class="toc-text">矩阵转置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特殊的矩阵，单位矩阵"><span class="toc-number">2.2.0.5.</span> <span class="toc-text">特殊的矩阵，单位矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#向量点乘和叉乘的矩阵形式"><span class="toc-number">2.2.0.6.</span> <span class="toc-text">向量点乘和叉乘的矩阵形式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三节-变换"><span class="toc-number">3.</span> <span class="toc-text">第三节 变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#我们为什么要学习变换："><span class="toc-number">3.0.1.</span> <span class="toc-text">我们为什么要学习变换：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变换"><span class="toc-number">3.0.2.</span> <span class="toc-text">变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子"><span class="toc-number">3.0.3.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#标准缩放"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">标准缩放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如果XY的缩放各不相同"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">如果XY的缩放各不相同:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如果是反射（对称）的操作："><span class="toc-number">3.0.3.3.</span> <span class="toc-text">如果是反射（对称）的操作：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如果是切变的操作："><span class="toc-number">3.0.3.4.</span> <span class="toc-text">如果是切变的操作：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如果是旋转的操作："><span class="toc-number">3.0.3.5.</span> <span class="toc-text">如果是旋转的操作：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#变换的共同点"><span class="toc-number">3.0.3.6.</span> <span class="toc-text">变换的共同点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#齐次坐标"><span class="toc-number">3.0.4.</span> <span class="toc-text">齐次坐标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么要学习齐次坐标，为什么要引入这个复杂的东西。"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">为什么要学习齐次坐标，为什么要引入这个复杂的东西。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#齐次坐标-1"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">齐次坐标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#仿射变换"><span class="toc-number">3.0.4.3.</span> <span class="toc-text">仿射变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#逆变换"><span class="toc-number">3.0.4.4.</span> <span class="toc-text">逆变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#变换组合-分解"><span class="toc-number">3.0.4.5.</span> <span class="toc-text">变换组合&#x2F;分解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三维变换"><span class="toc-number">3.0.4.6.</span> <span class="toc-text">三维变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#问题"><span class="toc-number">3.0.4.7.</span> <span class="toc-text">问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四节-变换续"><span class="toc-number">4.</span> <span class="toc-text">第四节 变换续</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#上节的补充"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">上节的补充</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#上节的复习"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">上节的复习</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#本节"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">本节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三维变换-1"><span class="toc-number">4.0.0.4.</span> <span class="toc-text">三维变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Viewing变换"><span class="toc-number">4.0.0.5.</span> <span class="toc-text">Viewing变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Projection-transforamtion投影变换"><span class="toc-number">4.0.0.6.</span> <span class="toc-text">Projection transforamtion投影变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#正交投影"><span class="toc-number">4.0.0.7.</span> <span class="toc-text">正交投影</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#透视投影"><span class="toc-number">4.0.0.8.</span> <span class="toc-text">透视投影</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五节-光栅化"><span class="toc-number">5.</span> <span class="toc-text">第五节 光栅化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#上节课内容复习"><span class="toc-number">5.0.1.</span> <span class="toc-text">上节课内容复习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#透视投影近平面推导"><span class="toc-number">5.0.2.</span> <span class="toc-text">透视投影近平面推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是MVP"><span class="toc-number">5.0.3.</span> <span class="toc-text">什么是MVP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标准立方体空间到屏幕"><span class="toc-number">5.0.4.</span> <span class="toc-text">标准立方体空间到屏幕</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#光栅化，三角形到像素"><span class="toc-number">5.0.5.</span> <span class="toc-text">光栅化，三角形到像素</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#几种光栅化显示设备："><span class="toc-number">5.0.5.0.1.</span> <span class="toc-text">几种光栅化显示设备：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#为什么是三角形"><span class="toc-number">5.0.5.0.2.</span> <span class="toc-text">为什么是三角形</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#如何判断一个像素和三角形的关系"><span class="toc-number">5.0.5.0.3.</span> <span class="toc-text">如何判断一个像素和三角形的关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#实际屏幕的光栅化"><span class="toc-number">5.0.5.0.4.</span> <span class="toc-text">实际屏幕的光栅化</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Sun Yuxiang</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/sunyuxianggit" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SunYuxiangのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">文章</a><a class="site-page" href="/archives">归档</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">GAMES101-现代计算机图形学入门-闫令琪(1-5)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-10</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>GAMES101-现代计算机图形学入门-闫令琪(1-5) 课程学习笔记</p>
<h2 id="第一节-引入"><a href="#第一节-引入" class="headerlink" title="第一节 引入"></a>第一节 引入</h2><p>怎么判断一个游戏画面的技术水平，有一个很简单的方法就是画面亮不亮。</p>
<h2 id="第二节-线性代数"><a href="#第二节-线性代数" class="headerlink" title="第二节 线性代数"></a>第二节 线性代数</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量是带有方向的量<br>重要的两个量是方向和长度<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-49-03.png" alt>  </p>
<a id="more"></a>
<p>数学： 向量<br>物理： 矢量<br>向量长度：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-49-24.png" alt><br>向量加法（求和）：<br>几何上<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-49-38.png" alt><br>数学上<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-49-58.png" alt><br>我们把向量表示成直角坐标系这种形式是有助于计算向量的长度的。  </p>
<h4 id="向量的点乘和叉乘"><a href="#向量的点乘和叉乘" class="headerlink" title="向量的点乘和叉乘"></a>向量的点乘和叉乘</h4><p>向量更广泛的用法<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-50-12.png" alt>  </p>
<h5 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-50-25.png" alt><br>左边是两个向量，右边是一个数字。<br>如果两个向量都是单位向量，那么它们点乘的结果就是余弦的值。  </p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-12-58-31.png" alt><br>点乘既然是一种运算，运算法则都会满足一些性质。<br>交换律 结合律 分配律  </p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-08-11.png" alt><br>如果是在坐标系下，就跟简单。  </p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-02-30.png" alt>  </p>
<ol>
<li>点乘在图形学最重要的作用就是找到两个向量的夹角。<br>比如 光从哪个地方射过来（向量）物体表面法线是什么样的（向量）我们从哪里看（向量）</li>
<li>第二个重要作用就是找到一个向量的投影到另一个向量是长什么样的。<br>投影算出来有什么好处呢？ 我们可以把一个向量分解成两个向量，一个平行一个垂直。这样可以帮助我们把任意向量分解到任意坐标轴。<br> <img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-17-01.png" alt></li>
<li>在图形学里，我们还可以根据点乘的结果判定两个向量是否接近是否远离。</li>
<li>向量点乘还可以告诉大家一个前与后的信息，如图（向量a和向量b点乘为正值且接近1，向量a和向量c点乘为负值，如果有一个向量跟向量a一样，那点乘结果为1，如果有一个向量正好在虚线上，那点乘的值为0，如果跟向量a正好相反，那点乘结果为-1）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-44-08.png" alt>  </li>
</ol>
<h5 id="叉乘（叉积）"><a href="#叉乘（叉积）" class="headerlink" title="叉乘（叉积）"></a>叉乘（叉积）</h5><p>叉乘是给定两个向量计算出同时垂直与这两个向量的新的向量，另外同时垂直这两个向量也就是必然垂直这两个向量形成的平面<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-13-57-13.png" alt><br><strong>右手螺旋定则</strong>（DirectX是右手，openGL是左手）。<br>定义，右手伸值大拇指向天空，四个拇指朝向手心握（逆时针运动），如果大拇指向大地，四个拇指朝向手心握（顺时针运动）。这里右手指向天空为正，所以逆时针运动为正。</p>
<p>例子：</p>
<ol>
<li>Z叉乘X,XYZXYZ,Z到X就是顺时针，所以得到正Y。</li>
<li>Y叉乘X，XYZXYZ,Y到X就是逆时针，所以得到负Z。</li>
</ol>
<p>向量的叉乘并不满足交换律（如果要交换需要加一个负号）<br>向量的叉积还有一个作用是我们利用它来建立一个三维空间中的直角坐标系<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-14-04-16.png" alt><br>几何：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-14-36-32.png" alt>  </p>
<p>叉积怎么算，有什么用处：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-14-37-55.png" alt><br>特别重要 </p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-14-38-58.png" alt></p>
<ol>
<li>判定左和右<br>如图左侧，XY为平面，通过右手螺旋定则，Z为朝向我们自身的向量，如果想判断向量b在向量a左侧还是右侧（什么是左侧右侧? 从向量a顺时针旋转到达向量b为左侧，逆时针为右侧），在这里根据图示很容易看出来向量b是在向量a的左侧，如果用数字表示就是 向量a叉乘向量b得到的结果是正值（指向身体）就说明向量b在向量a的左侧，如果向量b叉乘向量a得到的结果是负值（指向身体外侧），那就说明向量a在向量b右侧，</li>
<li>判定内与外<br>如图右侧，先判断向量AP是否在向量AB的左侧，在判断向量BP是否在向量BC的左侧，在判断向量AP是否在ac的左侧，如果都是在左侧就说明点P在三角形内部，否则肯定有一个判断是在右侧。<br>这里假设了ABC三个点是逆时针排布，如果换成顺时针也没有问题，只不过是都在左侧。<br>所以我们可以忽略三角形的排布顺序，只要三个边左或者右保持一致就说明点在三角形内部。这点非常重要，是光栅化的基础（用来判断像素是否在三角形的内部）。</li>
</ol>
<h4 id="向量定义坐标系"><a href="#向量定义坐标系" class="headerlink" title="向量定义坐标系"></a>向量定义坐标系</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-15-51-31.png" alt><br>向量叉乘可以定义一些互相垂直的轴，就会形成坐标系如图。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-15-52-25.png" alt><br>这里顶一个uvw坐标系，三个向量单位长度都为1，互相垂直，给你u和v 叉乘得到w。<br>我们可以利用投影把任意一个向量分解到三个轴上去，利用点乘，因为什么呢？向量P点乘向量U，等于是向量P的长度乘以向量U的长度在乘以cosθ，向量U又恰好是单位向量为1，等于是向量P的长度乘以cosθ，根据下图三角函数，就会得出向量P在向量U上的投影，同理获得向量P在向量V和向量W上的投影，有了这三个投影就可以获得坐标系下的这个向量。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-16-07-00.png" alt><br>cosA = c/b  </p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-16-47-04.png" alt><br><strong>在图像学里，变换就是矩阵的最大应用。</strong><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-20-44-32.png" alt>  </p>
<h5 id="矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量"><a href="#矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量" class="headerlink" title="矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量."></a>矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量.</h5><h5 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-20-53-06.png" alt><br>矩阵乘矩阵必须要符合条件才能乘，如图必须第一个矩阵的列数和第二个矩阵的行数相同相乘才有意义。<br><strong>关于新得到的矩阵每一个元素都是什么，有不同的数学定义，这个地方比较不容易记住，这里给大家提供一个容易记得方法，比如左下角这个8，他的坐标是三行一列，这里三行对应第一个矩阵（0，4），一列对应第二个矩阵（3，2），这两个向量点乘。</strong><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-21-50-50.png" alt><br>矩阵乘法是没有交换律的，但是矩阵是由结合律和分配律。  </p>
<h5 id="矩阵乘向量"><a href="#矩阵乘向量" class="headerlink" title="矩阵乘向量"></a>矩阵乘向量</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-21-53-53.png" alt></p>
<blockquote>
<p>一个矩阵如何和一个向量乘？当我们认为向量是列向量就有意义了（也就是说M永远为1）。    </p>
</blockquote>
<p><em>这是最重要的核心。</em><br>下面表示一个2D向量按Y轴镜像的操作。</p>
<h5 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-22-01-06.png" alt><br>性质： 如果要乘两个矩阵在转置好比相对后一个矩阵做装置在乘以前一个矩阵做转置的结果。</p>
<h5 id="特殊的矩阵，单位矩阵"><a href="#特殊的矩阵，单位矩阵" class="headerlink" title="特殊的矩阵，单位矩阵"></a>特殊的矩阵，单位矩阵</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-22-07-51.png" alt><br>对角阵，只有对角线上有非零的元素，<br>矩阵的逆：如果你能找到一个矩阵，和原来的矩阵相乘，不管乘得顺序，得到的结果都是I，那么我们就认为这两个矩阵是互逆的。<br>逆矩阵的计算和转置的矩阵很相似。</p>
<h5 id="向量点乘和叉乘的矩阵形式"><a href="#向量点乘和叉乘的矩阵形式" class="headerlink" title="向量点乘和叉乘的矩阵形式"></a>向量点乘和叉乘的矩阵形式</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-08-22-12-11.png" alt><br>点乘：向量a点乘向量b 等于向量a转置和向量b的乘法。<br>叉乘：相对点乘困难一些，相当于把向量a转换成一个矩阵（dual matrix）乘以向量b</p>
<h2 id="第三节-变换"><a href="#第三节-变换" class="headerlink" title="第三节 变换"></a>第三节 变换</h2><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-16-48-49.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-16-53-27.png" alt></p>
<h4 id="我们为什么要学习变换："><a href="#我们为什么要学习变换：" class="headerlink" title="我们为什么要学习变换："></a>我们为什么要学习变换：</h4><ul>
<li>Modeling：<br>位移 旋转 缩放<br>很多动画就是由各种不同的变换合成在一起形成的。</li>
<li>Viewing：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-16-58-58.png" alt><br>光栅化成像涉及到大量的变换。<br>3D -&gt; 2D 从三维到二维的变换我们叫做投影，这个投影也是一种非常重要的变换，之后会学到。<h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-01-01.png" alt><br>今天我们的目标就是，把矩阵和变换联系起来。<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="标准缩放"><a href="#标准缩放" class="headerlink" title="标准缩放"></a>标准缩放</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-02-15.png" alt><br>横轴和纵轴都缩放了0.5，也就是说把任何一个点坐标(X,Y)进行缩放操作0.5倍。<br>如果用数学形式表示, 可以表示为<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-06-00.png" alt><br>如果用矩阵形式表示可以表示为对角矩阵。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-06-36.png" alt><br>是不是这样的，我们可以验证一下。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-32-25.png" alt><h5 id="如果XY的缩放各不相同"><a href="#如果XY的缩放各不相同" class="headerlink" title="如果XY的缩放各不相同:"></a>如果XY的缩放各不相同:</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-34-39.png" alt><h5 id="如果是反射（对称）的操作："><a href="#如果是反射（对称）的操作：" class="headerlink" title="如果是反射（对称）的操作："></a>如果是反射（对称）的操作：</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-36-36.png" alt><br>等于是Y轴不变，X轴反过来。<h5 id="如果是切变的操作："><a href="#如果是切变的操作：" class="headerlink" title="如果是切变的操作："></a>如果是切变的操作：</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-17-39-12.png" alt><br>注意这里可以通过一个点的变换前到变换后的变化推导出,Y是不变的，X是变成了X+ay，由x+ay倒推出矩阵.<h5 id="如果是旋转的操作："><a href="#如果是旋转的操作：" class="headerlink" title="如果是旋转的操作："></a>如果是旋转的操作：</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-00-56.png" alt><br>默认是绕(0,0)点旋转，逆时针旋转.<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-00-15.png" alt><br>简单的推导：</li>
<li>不管再复杂的操作，先找到一个一一对应的关系点，再倒推。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-13-23.png" alt><br>通过（1，0）点的对应关系点配合三角函数可以得到矩阵AC值，那么通过（0，1）点的对应关系点可以找到BC.<h5 id="变换的共同点"><a href="#变换的共同点" class="headerlink" title="变换的共同点"></a>变换的共同点</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-33-00.png" alt><br>X pu ruai mu = 变换矩阵*X<br>这样变换和矩阵的联系就建立起来了，对于一个变换就可以用矩阵来表示。<br>概念区分： 我们要用一个相同维度的矩阵来乘以向量。<h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4></li>
</ul>
<h5 id="为什么要学习齐次坐标，为什么要引入这个复杂的东西。"><a href="#为什么要学习齐次坐标，为什么要引入这个复杂的东西。" class="headerlink" title="为什么要学习齐次坐标，为什么要引入这个复杂的东西。"></a>为什么要学习齐次坐标，为什么要引入这个复杂的东西。</h5><p>因为平移变换特别特殊。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-40-34.png" alt><br>如果简单的写出来，是挺简单的，但是没有办法转换成矩阵:<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-41-24.png" alt><br>所以无奈之下必须要用齐次坐标。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-18-42-38.png" alt><br>平移操作并不属于一个线性变换（因为线性变换必须等于一个向量等于一个矩阵乘以另外一个向量），但是我们不希望把平移当作一个特殊的情况处理，因为人类总是懒的。所以有没有办法可以把我们提到的所有变换归纳成一个最简单的变换来表示。<br>tradeoff：权衡.</p>
<h5 id="齐次坐标-1"><a href="#齐次坐标-1" class="headerlink" title="齐次坐标"></a>齐次坐标</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-19-26-18.png" alt><br>如果XY表示点的坐标那就加上1，如果是向量加上0。为什么区别对待?<br>因为向量具有<strong>平移不变性</strong>：<br>如果有一个向量经过一个表示平移的矩阵，我们希望它的结果还是XY0.</p>
<blockquote>
<p>向量是个所谓的“过程量”，不依赖于本身的位置。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-19-39-25.png" alt></p>
</blockquote>
<ol>
<li>如果两个向量相加，结果是新的向量（x1+x2，y1+y2，0+0）有意义。</li>
<li>如果两个点相减（形成一个从被减数指向减数向量）（x1-x2，y1-y2，1-1=0）点减点等于向量，有意义。</li>
<li>如果是点加向量，一个点沿着向量移动到一个新的点上，<br>（x1+x2，y1+y2，1+0=1）有意义。</li>
<li>一个点加一个点，没意义，扩充的定义。</li>
<li>对于任何的二维点，我们认为，(x/w,y/2,w/w),w!=0(0就是向量了。)</li>
<li>一个点加一个点，表示这两个点的中点。为什么？因为一个点加一个点w会变成2，这个w变成1的过程就是在求中点。</li>
</ol>
<p>最重要的不是这些变换，而是目的，我们的目的是就是为了把所有的变换写出一个矩阵乘以一个向量的形式。</p>
<h5 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-20-00-24.png" alt><br>线性变换+位移，对于类似的变换就叫仿射变换。<br>所有的仿射变换都可以写成齐次坐标这种形式。<br>验证：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-14-20-03-21.png" alt><br>只要表示<strong>仿射变换</strong>最后一行都是001，理论上只用存储上面的部分就行了。</p>
<h5 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h5><p>逆变换是指把一个变换的操作反过来。<br>在数学对应的正好是乘以这个变换的逆矩阵（一个矩阵乘以它自己的逆矩阵一定等于单位矩阵）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-31-02.png" alt></p>
<h5 id="变换组合-分解"><a href="#变换组合-分解" class="headerlink" title="变换组合/分解"></a>变换组合/分解</h5><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-38-30.png" alt><br>对于这样一个变换我们可以把它看成先平移在旋转，如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-39-04.png" alt><br>但是结果不对，因为旋转还是绕(0,0)点。怎么操作对呢？如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-40-32.png" alt></p>
<p>如此可以得到两个信息：</p>
<ol>
<li>复杂的变换可以通过简单的变化得到。</li>
<li>变换的顺序非常重要。(对应矩阵乘法不满足交换律{变换就是在某一个向量前面乘以一个矩阵，再变换一次就是再在前面乘以一个矩阵，矩阵的乘的顺序变换那结果就会发生变化})<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-45-44.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-46-04.png" alt><br>先乘旋转矩阵再乘平移矩阵，也就是等号左边逐个变换逐个向左写，等会右边乘的时候也是从右往左乘（跟整数乘法正好相反），推广概念如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-51-43.png" alt><br>Tips：矩阵没有交换律，但是有结合律。可以把A1到An乘完得到一个矩阵在和向量相乘，也就是说，<strong>一个矩阵就可以表示非常复杂的变换</strong></li>
</ol>
<p>同样道理，变换既然可以合成也就可以分解。如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-13-57-30.png" alt><br>如果我们想已给定点为中心进行旋转，可以分解如图，先把这个点移到（0,0）点{移动一个-C}，然后旋转，再移动回去{移动一个C}</p>
<h5 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h5><p>三维的变换就是把二维的变换拿过去做类比就可以（包括齐次坐标表示）。<br>三维空间也会有线性变换，三维空间也会有平移。也不希望三维空间的平移变成特殊现学，也就再次用齐次坐标，再加一个数。四维数表示三维空间的点和向量。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-06-16.png" alt><br>4X4矩阵<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-15-08.png" alt><br>三维空间中 仿射变换的情况下， 最后一行肯定是（0，0，0，1）</p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如上图的变换，是先表示的线性变换还是先表示的位移？<br>是先进行的线性变换，再进行的位移。遇到此类问题可以考虑不用齐次坐标的表示。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-20-14.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-21-42.png" alt></p>
<h2 id="第四节-变换续"><a href="#第四节-变换续" class="headerlink" title="第四节 变换续"></a>第四节 变换续</h2><h5 id="上节的补充"><a href="#上节的补充" class="headerlink" title="上节的补充"></a>上节的补充</h5><p>二维情况下，如果不考虑齐次坐标，变换可以用2x2的矩阵来表示，<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-14-46-17.png" alt><br>注意这里:<br>cos -θ 等于cosθ<br>sin -θ 等于-sinθ</p>
<p>这里有两个情况：</p>
<ol>
<li>和上面的矩阵相比这样我们就发现，旋转θ角和旋转-θ角就是把这个矩阵做了一个转置（行列对换）。  </li>
<li>从定义上来看，旋转θ角和旋转-θ角，应该是一个互逆的关系，旋转-θ角应该就是旋转θ角的到的矩阵的逆。<br>由此可以得出，如下图：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-04-08.png" alt><br>旋转矩阵的转置等于旋转矩阵的逆<br>tips：<br>在数学上如果一个矩阵的逆等于这个矩阵的转置，那么这个矩阵叫做正交矩阵。<h5 id="上节的复习"><a href="#上节的复习" class="headerlink" title="上节的复习"></a>上节的复习</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-08-03.png" alt><h5 id="本节"><a href="#本节" class="headerlink" title="本节"></a>本节</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-37-29.png" alt><br>把三维变换结束掉之后，重点是viewing变换。<h5 id="三维变换-1"><a href="#三维变换-1" class="headerlink" title="三维变换"></a>三维变换</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-39-20.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-43-42.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-43-58.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-15-44-37.png" alt><br>对于三维空间的旋转变换，如果直接考虑绕任意一个轴旋转是很复杂的，但是如果绕XYZ的话就会相对简单，比如绕X轴移动的平面，其X坐标是不会发生任何改变的，发生改变的是Y，Z两个轴的数值。所以Rx和Rz都是有一个轴是不发生任何改变。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-16-48-58.png" alt><br>注意RxRz的符号是一致的，但是Ry是反的为什么呢，图上如果要的到Y就是Z叉乘X（xyzxyz循环对称性质），因为是反着的，所以结果符号是反的。<blockquote>
<p>这是因为二维平面定义时，逆时针实际是在三维从Z正向看，因此三维绕Y旋转，逆时针实际上是从Z向X运动，但是旋转矩阵的行列对应关系是X向Z转,取逆（转置）就得到了。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-16-48-21.png" alt><br>对于任意一个旋转，我们可以把它分解为绕X绕Y绕Z旋转。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-17-07-40.png" alt></p>
</blockquote>
</li>
</ol>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-17-11-12.png" alt><br>默认向量n的起点在原点，如果不是的话，可以用上一节的方法，先把它移动到原点，变换完再挪回去。  </p>
<h5 id="Viewing变换"><a href="#Viewing变换" class="headerlink" title="Viewing变换"></a>Viewing变换</h5><p>最终目的，是把三维空间里面的东西变成二维的。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-17-31-42.png" alt><br>|现实生活里拍照片动作|viewing变换动作|<br>|——————|————–|<br>|找好位置摆好pos|模型变换 model transformation|<br>|找到一个好的角度|视图变换 view transformation|<br>|茄子|投影变换 projection transformation|<br>简称MVP变换<br>怎么做view变换呢？<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-17-56-38.png" alt></p>
<ol>
<li>位置 往哪看 </li>
<li>往哪看</li>
<li>相机本身的向上方向</li>
</ol>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-18-00-49.png" alt></p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-21-13-05.png" alt></p>
<p>注意这里还是右手坐标系，可以使用右手螺旋定则判定。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-21-24-36.png" alt></p>
<p>怎么把这种变换表示成矩阵呢？<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-21-26-48.png" alt></p>
<ol>
<li>位移： 注意应该先做线性变换在做平移，但是为了理解方便这里先做了平移，后做线性变换，但是接下来往左写，是一样的。</li>
<li>旋转：这里把某个向量旋转成标准轴不好实现，但是反过来把某个标准轴旋转成某个向量好实现，所以我们就等于先求出逆变换，（这里的矩阵逆用的很巧妙），怎么对一个旋转矩阵求逆呢？利用旋转矩阵是正交矩阵，正交矩阵的逆就是它的转置（本节课开始证明的）。</li>
<li>这个Mview矩阵就可以把摄影机移动到零点，同理也可以把其他所有东西移动到相对位置上。视图变换  </li>
</ol>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-15-22-04-47.png" alt><br>总结：</p>
<ol>
<li>任何时候只要相机和物体应用同样的变换或者位移，结果不变。</li>
<li>视图变换操作的是相机，其他物体跟着变换。<h5 id="Projection-transforamtion投影变换"><a href="#Projection-transforamtion投影变换" class="headerlink" title="Projection transforamtion投影变换"></a>Projection transforamtion投影变换</h5></li>
<li>Orthographic projection 正交投影</li>
<li>Perspective projection 透视投影<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-43-42.png" alt><br>左边的正交投影，平行线永远平行（多用于工程制图）<br>右边透视投影近大远小，平行线延长终会相交（人眼）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-45-52.png" alt><br>左边透视投影，我们认为某个位置上的摄影机是一个点，去连出空间中的一个四棱锥。<br>右边正交投影，假设摄影机离得无限远，直到近和远的平面一样大。<h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5>正交投影相对好理解。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-51-04.png" alt><br>理解：</li>
<li>定义摄影机在原点，看向-Z，顶部朝Y</li>
<li>把Z轴坐标丢掉</li>
<li>把结果都挪到-1,1<br>实际操作：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-57-00.png" alt></li>
<li>首先定义空间中的一个立方体,</li>
<li>在xyz三轴找到对应的坐标 left，right，bottom，top，far，near，有了这六个数就可以定义这个立方体</li>
<li>映射到canonical cube -1,1，</li>
</ol>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-14-59-32.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-11-13.png" alt></p>
<p>把这个变换写成矩阵的形式：</p>
<ol>
<li>注意这里是先做平移，后面在做缩放</li>
<li>平移X值是指先求出矩形的长r+l除以2得到长的中心，在移动负中心的位置就是移动到x轴的中心，其它轴以此类推。</li>
<li>缩放X值，是先求出x的覆盖范围也就是长度r-l，跟比2的倍数也就是2/r-l，为什么是2，因为canonical的x长度是-1到1长度2。有了这个倍数，在对其进行缩放就把元素匹配到canonical cube里了。其它轴以此类推。</li>
</ol>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-27-18.png" alt></p>
<ol>
<li>因为摄影机看向-Z，所以这里的far是小于near的(-10小于-1)**</li>
<li>这里opengl 左手系就是far大于near，但是左手系会带来别的问题，x叉乘Y不等于Z等。<h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-28-56.png" alt></li>
<li>用的最广泛的投影</li>
<li>进大远小</li>
<li>平行线不平行，相交与一点<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-37-47.png" alt></li>
</ol>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-40-21.png" alt><br>在继续学习之前<br>这里复习了一下齐次坐标，当一个点（xyz1）的每个数都乘以任意一个数，表示的点不变。<br>例如（1，0，0，1）和（2，0，0，2）都代表（1，0，0）<br>简单，但是有用。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-15-49-43.png" alt><br>先定义个Frustum（平截头体），跟右边的Cuboid（长方体）对比，我们会发现只有远端的平面不一样，假如我们把远端的平面缩放到跟近端的平面一样，那就是跟正交投影一样了。<br>也就是我们把投射投影拆成了两步：  </p>
<ol>
<li>把远端的平面挤压到跟近端的平面一样，也就是把frustum变成cuboid。也就是求一个矩阵MPersp-&gt;Ortho</li>
<li>做一下正交投影</li>
</ol>
<p>规定：  </p>
<ol>
<li>近平面任何一点都不变。</li>
<li>远处的平面 Z值是f，操作完之后 远处的平面Z值仍然是F,同理，近平面的Z也不变。</li>
<li>远平面的中心点，缩放完之后还是中心点，坐标也是完全不变的。</li>
</ol>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-16-41-56.png" alt><br>挤压这步怎么做，也就是怎么求一个矩阵MPersp？<br>假设我们从侧面望Frustum上看，这里最左边是摄影机，朝-Z看，如上图。<br>看到两个相似三角形，根据相似三角形定理，Y’比上Y等于N比上Z<br>所以我们可以得到  y’ = （n/z）<em>y<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-17-48-02.png" alt><br>同理我们可以得到  X’ = （n/z）</em>x<br>现在我们知道XY在变换之后的结果，我们可以利用齐次坐标的属性共同乘以Z。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-17-59-58.png" alt><br>跟我们知道的结果，我们可以反推出矩阵：<br>如上图上方4<em>4矩阵乘以向量（x，y，z，1），得到（nx，ny，unknow，z）。<br>我们知道矩阵乘法是，一行乘一列，X是第一行第一列，也就是4</em>4矩阵的第一行点乘向量（x，y，z，1）一列，<br>得到nx，所以矩阵的第一行就只能是 （n,0,0,0）.</p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-17-30.png" alt><br>两个观察发现：</p>
<ol>
<li>任何点在近平面上是完全不变的。</li>
<li>任何点的z坐标值在远平面也是完全不变的。远平面的中心点，缩放完之后还是中心点，坐标也是完全不变的<br>根据这两个发现：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-21-41.png" alt><br>这里利用了齐次坐标的特性，把（x,y,n,1）四个数同时乘以n变成（nx，ny，n平方，n）<br>在利用任何点在近平面完全不变可以列出等式：<br>第三行的n平方 等于 矩阵M的第三行乘以向量第一列（x,y,n,1）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-47-46.png" alt><br>远平面的中心点，缩放完之后还是中心点，坐标也是完全不变的，利用了齐次坐标的特性，把（0,0,f,1）四个数同时乘以f变成（0，0，f平方，f）<br>为啥必须乘以f，是因为我们希望最后以为是Z也就是远平面的z也就是f值：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-52-45.png" alt><br>得到两个等式：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-17-18-54-15.png" alt><br>根据这两个等式，我们可以解出A和B。<br>这里利用了完全平方公式。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-18-14-33-16.png" alt><br>课后问题：<br>对于Frustum，我们知道变换完之后远平面和近平面的z是不变的，那中间任意一点的z呢？是会被推向近平面还是推向远平面？<br>变远。<br>很奇怪的是数值变的异常大，比如我指认n是-3 f是-5，得到矩阵之后，给定一个中间点（0，1，-4，1）（这里必须是点，也就是w是1，因为向量平移不变），结果是(0,-3,17,-4) ，由于齐次坐标（x/w，y/w，z/w，w/w），所以结果是（0，0.75，-4.25，1），所以变远了。</li>
</ol>
<h2 id="第五节-光栅化"><a href="#第五节-光栅化" class="headerlink" title="第五节 光栅化"></a>第五节 光栅化</h2><h4 id="上节课内容复习"><a href="#上节课内容复习" class="headerlink" title="上节课内容复习"></a>上节课内容复习</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-18-15-18-16.png" alt><br>观测变换</p>
<ul>
<li>视图变换：利用摄影机和物体相对位置不变，摄影机视口内容不变的原理，把摄影机移动到原点 向上+Y，看向-Z，把其它所有内容都和相机一样运动。</li>
<li>从三维投影的二维，提到了两类变换，正交和透视。<br>做完经典的观测变换（把物体都移动到-1，1这个立方体里面）之后，我们需要把物体画在屏幕上。这步叫做光栅化。</li>
</ul>
<p>透视投影转换正交投影<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-10-11-54.png" alt><br>遮挡和可见性</p>
<h4 id="透视投影近平面推导"><a href="#透视投影近平面推导" class="headerlink" title="透视投影近平面推导"></a>透视投影近平面推导</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-17-32-24.png" alt><br>之前我们通过左右（L，R）描述平截头体的近平面。<br>两个概念：</p>
<ol>
<li>长宽比</li>
<li>垂直可视角度<br>垂直可视角度越大越是广角,但是透视投影明显（鱼眼），垂直可视角度越小越是长焦，接近正交投影，透视小。<br>通过长宽比，我们可以推出垂直可视角度<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-18-29-26.png" alt><br>也就是说，只要给定宽高比和垂直可视角度，我们就可以创建一个视锥.<h4 id="什么是MVP"><a href="#什么是MVP" class="headerlink" title="什么是MVP"></a>什么是MVP</h4><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-19-07-00.png" alt></li>
</ol>
<ul>
<li>M<br>物体自身位移</li>
<li>V<br>把摄影机移动到0，0，0 看向-z 头朝正Y，其它物体也和摄影机保持不变，移动到相应位置</li>
<li>P<br>正交投影: 先定义一个boudingbox，再把boudingbox变换到（-1，1）3次方空间<br>透视投影: 平截头体变换到（-1，1）3次方空间</li>
</ul>
<h4 id="标准立方体空间到屏幕"><a href="#标准立方体空间到屏幕" class="headerlink" title="标准立方体空间到屏幕"></a>标准立方体空间到屏幕</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-20-19-38-56.png" alt></p>
<ul>
<li>什么是屏幕：<br>图形学上认为是一个数组，数组里面存储着像素。<br>数组的大小就是分辨率。<br>屏幕是一个典型的光栅成像设备。  </li>
<li>什么是光栅化:<br>raster == screen in german<br>rasterize == 再屏幕上绘制</li>
<li>什么是像素(一种说法：Pixel是picture element的缩写)<br>对于这门课简单的抽象理解带颜色的小方块，其实很复杂<br>RGB组成颜色  </li>
</ul>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-22-18-43-02.png" alt><br>定义屏幕空间<br>什么是屏幕空间：<br>相当于在屏幕上建立一个坐标系，左下角是（0,0）。<br>这样每一个像素都可以用（x,y）表示。<br>分辨率可以用（0，0）到（width-1，height-1）表示，<br>每个像素的中心坐标实际上是(x+0.5，y+0.5)<br>一个像素会覆盖（1，1）宽度，整个屏幕（0，0）到（width，height）<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-22-19-01-28.png" alt></p>
<p>接下来就是把（-1，1）3这个标准空间映射到屏幕上，首先有一个问题就是 xyz 到xy，怎么处理z呢？<br>先不管它，那就是等于是把xy屏幕（-1，1）2 映射到（0，width）*（0，height），怎么做呢？<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-22-22-49-41.png" alt><br>注意这里注意变完之后,中心还在屏幕坐标的中心在左下角，我们要移动中心到屏幕的中心，所以最后一列是有内容的。   </p>
<h4 id="光栅化，三角形到像素"><a href="#光栅化，三角形到像素" class="headerlink" title="光栅化，三角形到像素"></a>光栅化，三角形到像素</h4><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-04-35.png" alt></p>
<h6 id="几种光栅化显示设备："><a href="#几种光栅化显示设备：" class="headerlink" title="几种光栅化显示设备："></a>几种光栅化显示设备：</h6><ul>
<li>示波器<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-08-13.png" alt></li>
</ul>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-12-53.png" alt><br>为了使画面刷新快，利用视觉暂留技术，每次只画一半，画完奇数行画偶数行，这种技术叫隔行扫描。<br>现在在视频压缩里面还有应用。</p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-16-28.png" alt><br>给我一个显示器，我怎么知道他要显示什么呢？通过显存里面的一块区域，把这块区域映射到屏幕上，这里就是现在屏幕的显示方式，我们可以生成不同的图形，存储在不同的显存区域，告诉显示器到底显示哪一幅图。</p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-21-35.png" alt></p>
<ul>
<li>平板显示器<br>低分辨率：计算器<br>高分辨率：视网膜屏<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-23-13.png" alt><br>通过液晶的扭曲，改变通过它的光的扭曲水平。  </li>
</ul>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-25-13.png" alt></p>
<ul>
<li>发光二极管  </li>
</ul>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-26-41.png" alt></p>
<ul>
<li>电子墨水屏</li>
</ul>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-28-05.png" alt></p>
<h6 id="为什么是三角形"><a href="#为什么是三角形" class="headerlink" title="为什么是三角形"></a>为什么是三角形</h6><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-28-18.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-29-43.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-30-33.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-30-11.png" alt></p>
<ul>
<li>最基础的多边形,可以分解任何其它多边形</li>
<li>特殊的属性。<ul>
<li>给定任意三个点，练成三角形都是一个平面。</li>
<li>三角形内外定义非常清晰，可以通过向量的叉积判断一个点在不在三角形内。</li>
<li>三角形可以定义个插值从一个点到另外俩个点。<h6 id="如何判断一个像素和三角形的关系"><a href="#如何判断一个像素和三角形的关系" class="headerlink" title="如何判断一个像素和三角形的关系"></a>如何判断一个像素和三角形的关系</h6><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-40-16.png" alt><br>判断一个像素和三角形的位置关系，或者说通过像素的中心点判断和三角形的位置关系。<br>一个简单的做法：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-42-26.png" alt><br>通过采样，<br>什么是采样：<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-17-42-56.png" alt><br>采样就是把一个函数给<strong>离散化</strong>的过程。比如定义一个函数 F(X) = sin（X），然后不停的带入x=1，到x=100，看对应的F(X)的值。<br>采样是一个非常重要的概念，在图像学里面涉及到各种各样的采样，这里说的采样是指利用像素中心对屏幕空间（（0，width）到（0，height））的采样。<br>后面还要采样 时间 位置 反射，<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-22-48-31.png" alt></li>
</ul>
</li>
</ul>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-22-49-07.png" alt><br>定义一个函数inside，给你一个三角形，给你屏幕空间的任意一点（x,y）我就知道点是不是在三角形内。</p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-22-52-40.png" alt><br>注意这里 inside 返回 0或者1 ，0代表在，1代表不在。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-22-59-55.png" alt></p>
<p>然后就是inside函数是怎么实现的，利用叉积。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-23-23-01-16.png" alt><br>P1P2叉乘P1Q，右手螺旋定则（顺时针），朝屏幕外得到Z正值，左。<br>P0P1叉乘P0Q，右手螺旋定则（顺时针），朝屏幕外得到Z正值，左。<br>p2p0叉乘P2Q，右手螺旋定则（逆时针），朝屏幕里得到Z负值，右。<br>只有全是正或者全是负才是三角形内部，所以Q所以不在三角形内部。</p>
<p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-14-34-13.png" alt><br>如果碰巧在三角形的边界，该怎么处理呢？在图形学里面要么不做处理，要么特殊处理，这门课不做处理。自己定义一个标准即可。<br>在dx和opengl的api里面定义非常严格，点落在上边和左边算内部，落在右边和下边不算在内部。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-14-37-58.png" alt><br>一个三角形相对于屏幕上很多像素点其实很小，如果把全部的像素点都测试一下的话慢而且没必要，就像白色那条像素一样，可以只测试这个三角形Bounding Box内的像素（蓝色区域），怎么计算这个Bounding Box呢？取P2 P1 P0这三个点的X最大和最小，Y最大最小，有了这四个数就可以得到一个矩形空间。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-17-46.png" alt><br>还可以每一行都找一下Bounding Box。  </p>
<h6 id="实际屏幕的光栅化"><a href="#实际屏幕的光栅化" class="headerlink" title="实际屏幕的光栅化"></a>实际屏幕的光栅化</h6><p><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-41-35.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-44-59.png" alt><br>注意打印是减色模式。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-45-53.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-46-06.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-46-31.png" alt><br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-46-50.png" alt><br>锯齿是光栅化一直在致力解决的问题。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-47-13.png" alt><br>有锯齿就有抗锯齿。<br><img src="/2020/03/10/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E9%97%AB%E4%BB%A4%E7%90%AA-1-5/2020-03-24-18-47-42.png" alt>  </p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/computer-graphics/">computer graphics</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/10/Effective-Python/"><i class="fa fa-chevron-left">  </i><span>Effective Python</span></a></div><div class="next-post pull-right"><a href="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/"><span>Maya卡顿优化</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Sun Yuxiang</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://sunyuxianggit.github.io/" target="_blank" rel="noopener">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SunYuxiangのBlog</title>
  
  <subtitle>好记性,不如烂笔头.今天你要写点什么？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-15T03:38:03.921Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sun Yuxiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SubstancePainter_Plugin_Study_Notes</title>
    <link href="http://yoursite.com/2020/03/14/SubstancePainter-Plugin-Study-Notes/"/>
    <id>http://yoursite.com/2020/03/14/SubstancePainter-Plugin-Study-Notes/</id>
    <published>2020-03-14T08:08:52.000Z</published>
    <updated>2020-03-15T03:38:03.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Substance-Painter-Plugin-学习笔记"><a href="#Substance-Painter-Plugin-学习笔记" class="headerlink" title="Substance Painter Plugin 学习笔记"></a>Substance Painter Plugin 学习笔记</h1><h2 id="First-steps"><a href="#First-steps" class="headerlink" title="First steps"></a>First steps</h2><p>核心思路：<br><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-13-21-25-23.png" alt></p><a id="more"></a><h3 id="Plugin-skeleton"><a href="#Plugin-skeleton" class="headerlink" title="Plugin skeleton"></a>Plugin skeleton</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin &#123;</span><br><span class="line">        <span class="comment">// starts a timer that will trigger the 'onTick' callback at regular interval</span></span><br><span class="line">        <span class="comment">// 启动一个计时器，该计时器将定期触发“ on tick”回调</span></span><br><span class="line">        tickIntervalMS: <span class="number">-1</span> <span class="comment">// -1 禁用（默认值）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// starts a JSON server on the given port:</span></span><br><span class="line">        <span class="comment">// 在给定的端口上启动json服务器</span></span><br><span class="line">        <span class="comment">// you send javascript that will be evaluated and you get the result in JSON format</span></span><br><span class="line">        <span class="comment">//您发送将被评估的javascript，并以json格式获取结果</span></span><br><span class="line">        jsonServerPort: <span class="number">-1</span> <span class="comment">// -1 禁用（默认值）</span></span><br><span class="line"></span><br><span class="line">        Component.onCompleted: &#123;</span><br><span class="line">                <span class="comment">// Called after the object has been instantiated.</span></span><br><span class="line">                <span class="comment">// 在实例化对象之后调用。</span></span><br><span class="line">                <span class="comment">// This can be used to execute script code at startup,</span></span><br><span class="line">                <span class="comment">// 可用于在启动时执行脚本代码，</span></span><br><span class="line">                <span class="comment">// once the full QML environment has been established.</span></span><br><span class="line">                <span class="comment">// 现已建立完整的qml环境</span></span><br><span class="line">                alg.log.info(<span class="string">"Component.onCompleted"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onTick: &#123;</span><br><span class="line">                <span class="comment">// Do something at each tick, depending on tickIntervalMS value</span></span><br><span class="line">                <span class="comment">// 在每个滴答声中有一些东西，具体取决于滴答间隔ms值</span></span><br><span class="line">                alg.log.info(<span class="string">"onTick"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onConfigure: &#123;</span><br><span class="line">                <span class="comment">// Do something when the user request the plugin configuration panel</span></span><br><span class="line">                <span class="comment">// 当用户请求插件配置面板时执行某些操作</span></span><br><span class="line">                alg.log.info(<span class="string">"onConfigure"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onApplicationStarted: &#123;</span><br><span class="line">                <span class="comment">// Called when the application is started</span></span><br><span class="line">                <span class="comment">// 启动应用程序时调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onApplicationStarted"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onNewProjectCreated: &#123;</span><br><span class="line">                <span class="comment">// Called when a new project is created, before the onProjectOpened callback</span></span><br><span class="line">                <span class="comment">// 在创建新项目时调用，在on project打开回调之前调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onNewProjectCreated"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onProjectOpened: &#123;</span><br><span class="line">                <span class="comment">// Called when the project is fully loaded</span></span><br><span class="line">                <span class="comment">// 在项目完全加载时调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onProjectOpened"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onProjectAboutToClose: &#123;</span><br><span class="line">                <span class="comment">// Called before project unload</span></span><br><span class="line">                <span class="comment">// 在项目卸载之前调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onProjectAboutToClose"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onProjectAboutToSave: <span class="function"><span class="keyword">function</span>(<span class="params">destinationUrl</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Called before a save, 'destination_url' parameter contains the save destination</span></span><br><span class="line">                <span class="comment">// 在保存之前调用，“目标网址”参数包含保存目标</span></span><br><span class="line">                alg.log.info(<span class="string">"onProjectAboutToSave: "</span>+destinationUrl)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onProjectSaved: &#123;</span><br><span class="line">                <span class="comment">// Called after the project was saved</span></span><br><span class="line">                <span class="comment">// 项目保存后调用</span></span><br><span class="line">                alg.log.info(<span class="string">"onProjectSaved"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onComputationStatusChanged: <span class="function"><span class="keyword">function</span>(<span class="params">isComputing</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Called when the state of the engine computing stacks content change.</span></span><br><span class="line">                <span class="comment">// 当引擎计算堆栈的状态更改内容时调用。</span></span><br><span class="line">                <span class="comment">// If the stack content is computed, 'isComputing' parameter will be false</span></span><br><span class="line">                <span class="comment">// 如果计算堆栈内容，则“正在计算”参数为false</span></span><br><span class="line">                alg.log.info(<span class="string">"onComputationStatusChanged: "</span>+isComputing)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onExportAboutToStart: <span class="function"><span class="keyword">function</span>(<span class="params">maps</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Called just before the export process starts.</span></span><br><span class="line">                <span class="comment">// 在导出过程开始之前调用。</span></span><br><span class="line">                <span class="comment">// 'maps' is the list of filepaths expected to be written.</span></span><br><span class="line">                <span class="comment">// “映射”是预期要写入的文件路径的列表。</span></span><br><span class="line">                alg.log.info(<span class="string">"onExportAboutToStart: "</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> stackName <span class="keyword">in</span> maps) &#123;</span><br><span class="line">                    alg.log.info(stackName);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> filePath <span class="keyword">in</span> maps[stackName]) &#123;</span><br><span class="line">                        alg.log.info(maps[stackName][filePath]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Example:</span></span><br><span class="line">                <span class="comment">// Open the 'PreviewSphere' sample, set 'C:/tmp' as export path, choose 'png' as export</span></span><br><span class="line">                <span class="comment">// 打开“预览球”示例，将“ c：/ tmp”设置为导出路径，选择“ png”作为导出</span></span><br><span class="line">                <span class="comment">// format and select the 'PBR MetalRough' config, the example above will output:</span></span><br><span class="line">                <span class="comment">// 格式化并选择“ pbr metal raw”配置，以上示例将输出：</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// onExportAboutToStart:</span></span><br><span class="line">                <span class="comment">// Sphere</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_BaseColor.png</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_Roughness.png</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_Metallic.png</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_Normal.png</span></span><br><span class="line">                <span class="comment">// c:/tmp/Sphere_Sphere_Height.png</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Please note the 'Opacity' and 'Emissive' maps are not listed here because they</span></span><br><span class="line">                <span class="comment">// 请注意，此处未列出“不透明”和“发射”地图，因为它们</span></span><br><span class="line">                <span class="comment">// can not be exported with this sample while the actual export will warn about it.</span></span><br><span class="line">                <span class="comment">// 不能与该样品一起出口，但实际出口会发出警告。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onExportFinished: <span class="function"><span class="keyword">function</span>(<span class="params">status, maps</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Called right after the export process ends.</span></span><br><span class="line">                <span class="comment">// 在导出过程结束后立即调用</span></span><br><span class="line">                <span class="comment">// 'status' is the error status returned by the process. Available values are:</span></span><br><span class="line">                <span class="comment">// “状态”是进程返回的错误状态。,可用值为：</span></span><br><span class="line">                <span class="comment">// - Export.Status_Ok</span></span><br><span class="line">                <span class="comment">// - Export.Status_Warn</span></span><br><span class="line">                <span class="comment">// - Export.Status_Error</span></span><br><span class="line">                <span class="comment">// - Export.Status_Canceled</span></span><br><span class="line">                <span class="comment">// 'maps' is the list of filepaths effectively exported.</span></span><br><span class="line">                <span class="comment">// “映射”是有效导出的文件路径的列表。</span></span><br><span class="line">                alg.log.info(<span class="string">"onExportFinished: "</span>)</span><br><span class="line">                <span class="keyword">if</span> (status != Export.Status_Ok) &#123;</span><br><span class="line">                    alg.log.error(<span class="string">"Export failed."</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> stackName <span class="keyword">in</span> maps) &#123;</span><br><span class="line">                        alg.log.info(stackName);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> filePath <span class="keyword">in</span> maps[stackName]) &#123;</span><br><span class="line">                            alg.log.info(maps[stackName][filePath]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Plugin meta data:<br>Information about the plugin can be provided by creating a plugin.json file in the plugin directory. Available properties are:<br>可以通过在plugin目录中创建一个plugin.json文件来提供有关该插件的信息。,可用属性为：<br>description: plugin description, displayed in the plugin about dialog.<br>url: project homepage, displayed in the plugin about dialog. Warning, the scheme is mandatory to create a clickable link.<br>version: plugin version.<br>license: plugin license.<br>min_api_version: required minimal scripting API version.<br>Example:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">"description"</span>: <span class="string">"This is a sample plugin"</span>,</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"https://www.allegorithmic.com"</span>,</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">        <span class="string">"license"</span>: <span class="string">"&lt;a href=\"https://opensource.org/licenses/MIT\"&gt;MIT&lt;/a&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Custom-UI"><a href="#Custom-UI" class="headerlink" title="Custom UI"></a>Custom UI</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin &#123;</span><br><span class="line">        <span class="comment">// 在实例化对象之后调用。</span></span><br><span class="line">        <span class="comment">// 可用于在启动时执行脚本代码，</span></span><br><span class="line">        <span class="comment">// 建立环境</span></span><br><span class="line">        Component.onCompleted: &#123;</span><br><span class="line">                <span class="comment">// 创建一个toolbar 按钮</span></span><br><span class="line">                <span class="keyword">var</span> t = alg.ui.addToolBarWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">                t.rectangle.color = <span class="string">"blue"</span></span><br><span class="line">                t = alg.ui.addToolBarWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">                t.rectangle.color = <span class="string">"green"</span></span><br><span class="line">                t = alg.ui.addToolBarWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">                t.rectangle.color = <span class="string">"yellow"</span></span><br><span class="line">                t = alg.ui.addToolBarWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">                t.rectangle.color = <span class="string">"purple"</span></span><br><span class="line">                <span class="comment">// 创建停靠小部件</span></span><br><span class="line">                alg.ui.addDockWidget(<span class="string">"dock.qml"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.3</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">Item &#123;</span><br><span class="line">        width: <span class="number">24</span></span><br><span class="line">        height: <span class="number">24</span></span><br><span class="line">        objectName: <span class="string">"My plugin UI"</span></span><br><span class="line">        property alias rectangle: rect</span><br><span class="line"></span><br><span class="line">        Rectangle &#123;</span><br><span class="line">                id: rect</span><br><span class="line">                anchors.fill: parent</span><br><span class="line">                color: <span class="string">"red"</span></span><br><span class="line">                MouseArea &#123;</span><br><span class="line">                        id: mouseArea</span><br><span class="line">                        anchors.fill: parent</span><br><span class="line">                        onClicked: &#123;</span><br><span class="line">                                <span class="keyword">var</span> ok = alg.mapexport.showExportDialog();<span class="comment">//打开导出窗口  alg是指Javascript API</span></span><br><span class="line">                                <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                                        alg.log.info(<span class="string">"Export successful!"</span>)</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        alg.log.warn(<span class="string">"Export cancelled!"</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Javascript-API"><a href="#Javascript-API" class="headerlink" title="Javascript API"></a>Javascript API</h2><p>Namespace: alg</p><h3 id="alg-Members"><a href="#alg-Members" class="headerlink" title="alg.Members"></a>alg.Members</h3><p><static> documents_directory 当前substance 文件所在文件夹路径<br>Properties:<br>Name                Type    Description<br>documents_directory string  Path to Substance Painter documents folder</static></p><p><static> plugin_root_directory 当前插件所在文件夹路径<br>Properties:<br>Name                    Type    Description<br>plugin_root_directory   string  Root directory of the plugin</static></p><p><static> version<br>Properties:<br>Name            Type    Description<br>version.api     string  JavaScript api version 当前javascript api 版本<br>version.painter string  Substance Painter version 当前substance painter 版本</static></p><h3 id="alg-baking"><a href="#alg-baking" class="headerlink" title="alg. baking"></a>alg. baking</h3><p>管理已打开项目的烘培</p><p><static> bake(textureSetName)<br>烘焙具有当前烘焙参数的纹理集的贴图<br>Parameters:<br>Name            Type    Description<br>textureSetName  string  The texture set name</static></p><p>Throws:<br>alg.baking.BakingError</p><p><static> commonBakingParameters()<br>从当前的项目里获得通用烘培设置<br>Throws:<br>alg.baking.BakingError<br>Returns:<br>The baking parameters as a JSON object<br>Type<br>object<br>Example</static></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Form of the common baking parameters</span></span><br><span class="line">     &#123;</span><br><span class="line">        commonParameters: &#123;</span><br><span class="line">          Apply_Diffusion: <span class="literal">true</span>,</span><br><span class="line">          Dilation_width: <span class="number">1</span>,</span><br><span class="line">          Output_Size: [<span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        detailParameters: &#123;</span><br><span class="line">          Antialiasing: <span class="string">"None"</span>,</span><br><span class="line">          Average_Normals: <span class="literal">true</span>,</span><br><span class="line">          Cage_File: <span class="string">""</span>,</span><br><span class="line">          High_Definition_Meshes: [],</span><br><span class="line">          High_poly_mesh_suffix: <span class="string">"_high"</span>,</span><br><span class="line">          Ignore_Backface: <span class="literal">true</span>,</span><br><span class="line">          Low_poly_mesh_suffix: <span class="string">"_low"</span>,</span><br><span class="line">          Match: <span class="string">"Always"</span>,</span><br><span class="line">          Max_Frontal_Distance: <span class="number">0.01</span>,</span><br><span class="line">          Max_Rear_Distance: <span class="number">0.01</span>,</span><br><span class="line">          Relative_to_Bounding_Box: <span class="literal">true</span>,</span><br><span class="line">          Use_Cage: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>待续</p><h3 id="alg-display"><a href="#alg-display" class="headerlink" title="alg.display"></a>alg.display</h3><p>管理项目的显示设置</p><p><static> getColorLutResource()<br>获得当前项目的色彩配置LUT的URL</static></p><p><static> getEnvironmentResource()<br>获得当前项目的environment map的URL</static></p><p><static> setColorLutResource(newUrl)<br>设置当前项目的颜色配置文件lut的URL</static></p><p><static> setEnvironmentResource(newUrl)<br>设置当前项目的环境图的URL</static></p><h3 id="alg-ui"><a href="#alg-ui" class="headerlink" title="alg.ui"></a>alg.ui</h3><p>Ui 实用程序</p><p><static> addDockWidget(qmlFileUrl)<br>从qml文件创建小部件，然后将其作为“停靠小部件”添加到主窗口<br>Name        Type    Description<br>qmlFileUrl  string  qml file to be loaded. Can be an absolute url or a path relative to the plugin directory.</static></p><p><static> addToolBarWidget(qmlFileUrl)<br>从qml文件创建小部件，然后将其作为“工具栏”添加到主窗口。<br>Name        Type    Description<br>qmlFileUrl  string  qml file to be loaded. Can be an absolute url or a path relative to the plugin directory.</static></p><p><static> addWidgetToPluginToolBar(qmlFileUrl)<br>从qml文件创建小部件，然后将其添加到插件工具栏。<br>Name        Type    Description<br>qmlFileUrl  string  qml file to be loaded. Can be an absolute url or a path relative to the plugin directory.</static></p><p><static> clickButton(name)<br>Simulate a click on a button.</static></p><p>Name    Type    Description<br>name    string  the object name of the button</p><h3 id="alg-subprocess"><a href="#alg-subprocess" class="headerlink" title="alg. subprocess"></a>alg. subprocess</h3><p>Spawn new processes. All processes are started from the plugin root directory.<br>产生新进程。,所有进程均从插件的根目录启动。</p><p><static> call(command)<br>Run command. Wait for command to complete, then return the returncode.<br>运行命令,等待命令完成，然后返回返回码</static></p><p>Name    Type    Description<br>command    string | Array.<string>    The command to be launched</string></p><p><static> check_call(command)<br>Run command. Wait for command to complete. If the return code was zero then return, otherwise raise an error.<br>运行命令,等待命令完成。,如果返回码为零，则返回，否则返回错误。</static></p><p>Name    Type    Description<br>command    string | Array.<string>    The command to be launched</string></p><p><static> check_output(command)<br>Run command. Wait for command to complete and return its standard output as a string. Raise an error if the return code is non-zero.<br>运行命令。,等待命令完成并以字符串形式返回其标准输出。,如果返回码不为零，则会引发错误</static></p><p>Name    Type    Description<br>command    string | Array.<string>    The command to be launched</string></p><p><static> start(command [, callback])<br>Start the given command asynchronously.<br>异步启动给定命令。<br>command    string | Array.<string>        The command to be launched<br>callback    alg.subprocess~processEndedCallback    <optional><br>Callback called when the command terminates</optional></string></static></p><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><p>substance painter  hello world 窗口</p><ul><li>首先需要有一个定义主入口点的qml文件main. </li></ul><ol><li>C:\Users\sunyuxiang\Documents\Allegorithmic\Substance Painter\plugins</li><li>在此处创建一个名为“ HelloPlugin”的文件夹 </li><li>在插件内，创建两个文件  <pre><code>* plugin.json * main.qml </code></pre></li><li>打开main.qml文件写入</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin </span><br><span class="line">&#123;</span><br><span class="line">        Component.onCompleted: </span><br><span class="line">        &#123;</span><br><span class="line">                alg.log.info(<span class="string">"hello world!"</span>)<span class="comment">//注意这里，alg.log.info()等于python里面的print()</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>填写JSON文件：</li></ul><ol><li>JSON文件包含插件的元数据，在这里显示.<br><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-06-10-45-09.png" alt><br><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-06-10-43-52.png" alt></li><li>我们知道json文件是键值对,观察一下现有插件的json文件,然后修改一后面的值改为.<br><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-06-10-47-53.png" alt></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"This is a sample plugin to print hello world"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"https://test"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="string">"license"</span>: <span class="string">"&lt;a href=\"https://opensource.org/licenses/MIT\"&gt;MIT&lt;/a&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后打开substance painter</li></ul><ol><li>可以看到log文件已经打印出了hello world<br><img src="/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-06-10-56-41.png" alt></li><li>plugins下的对应插件名字下面的about也可以正常工作</li><li>现在 我们可以看到插件的加载，还可以看到plugin.json文件的关于窗口信息.</li></ol><ul><li>添加一个窗口</li></ul><ol><li>在我们的HelloPlugin目录中创建一个HelloWorldWindow.qml.</li><li>编辑文件，添加代码来定义一个简单的窗口。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import AlgWidgets 1.0 &#x2F;&#x2F;窗口类导入</span><br><span class="line"></span><br><span class="line">AlgWindow</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 属性就像对象类型上的变量</span><br><span class="line">    id: window&#x2F;&#x2F;对应 main.qml的id 这个id很有用，因为它允许我们在插件的其他位置引用该对象，访问其可见性之类的属性。  </span><br><span class="line">    title: &quot;hello world window&quot;</span><br><span class="line">    visible: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在，我们有一个简单的窗口，但是在看到窗口之前，我们需要在main.qml文件中实例化它。 </li></ul><ol><li>编辑main.qml<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin </span><br><span class="line">&#123;       </span><br><span class="line">        HelloWorldWindow<span class="comment">// 在这里声明一个window，HelloWorldWindow指向HelloWorldWindow.qml</span></span><br><span class="line">        &#123;</span><br><span class="line">                id: <span class="built_in">window</span><span class="comment">//对应 HelloWorldWindow.qml的id</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Component.onCompleted: </span><br><span class="line">        &#123;</span><br><span class="line">                alg.log.info(<span class="string">"hello world!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>现在打开substance painter 禁用插件在启用插件就会看到该窗口弹出，这是因为在加载插件时首先实例化该窗口（？），我们稍后将解决此问题。 </li></ol><ul><li>创建一个按钮：</li></ul><ol><li>接下来创建一个按钮来替代禁用/启用</li><li>打开“ HelloWorldWindow.qml”文件。</li><li>我们将添加三件事： <pre><code>* 一系列的布局元素。 * 一个标签。 * 一个按钮</code></pre></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AlgWidgets <span class="number">1.0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这些模块是UI布局需要的</span></span><br><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.7</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.3</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"."</span></span><br><span class="line"></span><br><span class="line">AlgWindow</span><br><span class="line">&#123;</span><br><span class="line">    id: <span class="built_in">window</span><span class="comment">//对应 main.qml的id</span></span><br><span class="line">    title: <span class="string">"hello world window"</span></span><br><span class="line">    visible: <span class="literal">true</span><span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">    ColumnLayout <span class="comment">//也可以用 RowLayout这里定义了一系列的布局元素 </span></span><br><span class="line">    &#123;</span><br><span class="line">        id: horizontalLayout</span><br><span class="line">        anchors.fill: parent</span><br><span class="line"></span><br><span class="line">        Rectangle <span class="comment">//这里定义了一系列的布局元素 </span></span><br><span class="line">        &#123;</span><br><span class="line">            id: buttonBar</span><br><span class="line">            anchors.left: parent.left</span><br><span class="line">            anchors.right: parent.right</span><br><span class="line"></span><br><span class="line">            ColumnLayout<span class="comment">//也可以用 RowLayout这里定义了一系列的布局元素 </span></span><br><span class="line">            &#123;</span><br><span class="line">                anchors.fill:parent</span><br><span class="line"></span><br><span class="line">                AlgLabel<span class="comment">//一个标签</span></span><br><span class="line">                &#123;</span><br><span class="line">                    id: buttonLabel</span><br><span class="line">                    font.pixelSize: <span class="number">14</span></span><br><span class="line">                    font.bold: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">                    text: <span class="string">"Press Me"</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                AlgButton<span class="comment">//一个按钮</span></span><br><span class="line">                &#123;</span><br><span class="line">                    text: <span class="string">"Say Hello!"</span></span><br><span class="line">                    <span class="comment">//Layout.preferredWidth: Style.widgets.buttonWidth</span></span><br><span class="line"></span><br><span class="line">                    onClicked:</span><br><span class="line">                    &#123;</span><br><span class="line">                        alg.log.info(<span class="string">"hello World"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. QML窗口是使用一系列嵌套的布局对象创建的-为了达到我们的目的，我们将使用列，矩形和行。 2. 我们需要添加其他导入语句来访问这些对象类型-QtQuick和QtQuick.Layouts。3. 该列表示总体布局-元素将按照添加顺序堆叠在此形状中。 4. 矩形允许我们使用子布局填充此列的分区。 5. 最后，行布局允许我们添加将按照添加顺序从左到右呈现的元素。 6. 在行布局中添加AlgLabel和AlgButton将两个新元素添加到我们的窗口中。 7. 最后，为按钮定义“ onClicked”事件将替换启动时登录main.qml的位置。 </code></pre><ul><li><p>重新加载脚本：<br>可以使用painter中的Plugins-&gt; HelloPlugin-&gt; Reload  菜单即时重新加载脚本。在后面debug和尝试过程中这个超级有用，避免了我们要重新开关软件。</p></li><li><p>将插件添加到工具栏：</p></li></ul><ol><li>现在如果关闭插件窗口，则必须通过reload插件才能再次打开插件窗口。 </li><li>让我们在工具栏上添加一个按钮，来替代每次reload调用窗口。</li><li>工具栏中的按钮将非常简单，要做的就是在按下插件窗口时切换可见性。 </li><li>首先，我们将通过改变visible值的true改为false,让插件窗口不会加载自动弹出。</li><li>创建一个名为“ toolbar.qml ” 的新文件，并且与我们之前所做的类似,仅一排，带有一个按钮。<br>比较重要的是-插件加载时，属性变量“ windowReference”将由我们的插件填充。<br>由于windowReference在本地以null开头，因此我们稍后将对其的调用包装在try / catch块中。<br>如果脚本中其他地方的内容使我们无法创建窗口，那么这将阻止崩溃，我们可以将信息打印到控制台。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.7</span><br><span class="line">import QtQuick.controls 2.0</span><br><span class="line">import AlgWidgets 1.0</span><br><span class="line"></span><br><span class="line">Row &#x2F;&#x2F;现在是横向的如果需要侧边的话就是AlgToolBarButton</span><br><span class="line">&#123;</span><br><span class="line">    property var windowReference : null</span><br><span class="line"></span><br><span class="line">    Button</span><br><span class="line">    &#123;</span><br><span class="line">        id: rect</span><br><span class="line">        width: 30</span><br><span class="line">        height: 30</span><br><span class="line"></span><br><span class="line">        onClicked:</span><br><span class="line">        &#123;</span><br><span class="line">            try </span><br><span class="line">            &#123;</span><br><span class="line">                windowReference.visible &#x3D; true</span><br><span class="line">            &#125;</span><br><span class="line">            catch(err) </span><br><span class="line">            &#123;</span><br><span class="line">                alg.log.exception(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>最后，在“ main.qml”文件中，我们将添加一个新的工具栏小部件，该小部件将把“ toolbar.qml”实例化为工具栏上的按钮。<br>我们还使用其ID将HelloWorldWindow实例分配给工具栏按钮中的windowReference变量。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.2</span></span><br><span class="line"><span class="keyword">import</span> Painter <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">PainterPlugin </span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 在这里声明一个window，HelloWorldWindow指向HelloWorldWindow.qml</span></span><br><span class="line">        HelloWorldWindow</span><br><span class="line">        &#123;</span><br><span class="line">                id: <span class="built_in">window</span><span class="comment">//对应 HelloWorldWindow.qml的id</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Component.onCompleted: </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">var</span> qmToolbar = alg.ui.addWidgetToPluginToolBar(<span class="string">"toolbar.qml"</span>)</span><br><span class="line">                qmToolbar.windowReference = <span class="built_in">window</span><span class="comment">//这里调用了window</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这就是向Substance Painter添加基本插件的小例子.</li><li>ref：<a href="http://peterhanshawart.blogspot.com/2017/11/making-hello-world-substance-painter.html" target="_blank" rel="noopener">http://peterhanshawart.blogspot.com/2017/11/making-hello-world-substance-painter.html</a></li></ul><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">AlgWindow</span><br><span class="line">&#123;</span><br><span class="line">    Item</span><br><span class="line">    &#123;</span><br><span class="line">        Item </span><br><span class="line">        &#123;</span><br><span class="line">            Row</span><br><span class="line">            &#123;</span><br><span class="line">                Alglabel &#123;&#125;</span><br><span class="line">                AlgTextInput &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Row</span><br><span class="line">            &#123;</span><br><span class="line">                AlgComboBox &#123;&#125;</span><br><span class="line">                AlgLabel &#123;&#125;</span><br><span class="line">                AlgComboBox &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Row</span><br><span class="line">            &#123;</span><br><span class="line">                AlgCheckBox &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        GridView</span><br><span class="line">        &#123;</span><br><span class="line">            ListElement &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Item </span><br><span class="line">        &#123;</span><br><span class="line">            Row </span><br><span class="line">            &#123;</span><br><span class="line">                Rectangle &#123;&#125;</span><br><span class="line">                FileDialog &#123;&#125;</span><br><span class="line">                AlgButton &#123;&#125;</span><br><span class="line">                AlgButton &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Substance-Painter-Plugin-学习笔记&quot;&gt;&lt;a href=&quot;#Substance-Painter-Plugin-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Substance Painter Plugin 学习笔记&quot;&gt;&lt;/a&gt;Substance Painter Plugin 学习笔记&lt;/h1&gt;&lt;h2 id=&quot;First-steps&quot;&gt;&lt;a href=&quot;#First-steps&quot; class=&quot;headerlink&quot; title=&quot;First steps&quot;&gt;&lt;/a&gt;First steps&lt;/h2&gt;&lt;p&gt;核心思路：&lt;br&gt;&lt;img src=&quot;/2020/03/14/SubstancePainter-Plugin-Study-Notes/2020-03-13-21-25-23.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SubstancePainter" scheme="http://yoursite.com/tags/SubstancePainter/"/>
    
  </entry>
  
  <entry>
    <title>Blender脚本学习笔记</title>
    <link href="http://yoursite.com/2020/03/10/Blender%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/10/Blender%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-10T11:14:04.000Z</published>
    <updated>2020-03-11T02:28:29.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><p>安装python3.0以上(Blender 2.8是 python3.x)</p></li><li><p>Vscode 安装python 和 blender Development 插件</p></li><li><p>终端安装 fake-bpy 包<code>pip install fake-bpy-module-2.80</code></p><p> <a href="https://github.com/nutti/fake-bpy-module" target="_blank" rel="noopener">https://github.com/nutti/fake-bpy-module</a></p><p>安装完上面这些，vscode里面就会有自动补全</p><p>Debug</p></li><li><p>ctrl + shift + P, select “Blender: Start”</p></li><li><p>选择你的blender安装路径, vscode会连接到blender</p></li><li><p>ctrl + shift + P, “Blender: Run script” 并且可以使用断点调试</p> <a id="more"></a></li></ul><h3 id="插件路径"><a href="#插件路径" class="headerlink" title="插件路径"></a>插件路径</h3><ul><li><p>目录：user\AppData\Roaming\Blender Foundation\Blender\scripts\addons,代表非系统原生的用户插件,blender所有安装的外部插件都会被解压放置到这个文件夹下。</p><p>安装插件可以在blender的addon界面直接选择zip文件安装，也可以把插件文件夹直接拖入此目录。</p></li><li><p>目录：D:\blender-2.81a\2.81\scripts\addons</p><p>第二个是软件原生插件路径，不建议将自己写的插件放入此地，此地不少系统插件的代码可在以后做参考用，值得了解。</p></li></ul><h3 id="如何查看命令"><a href="#如何查看命令" class="headerlink" title="如何查看命令"></a>如何查看命令</h3><ul><li>类似maya 直接执行某个功能，看info输出命令（A+X    清空nfo）</li><li>选中命令直接 Copy Data Path.</li><li>鼠标悬停在某个命令上看提示，如果没有提示，要去perfence里面的interface下勾选Python Tooltips.</li><li>控制台直接输入<code>dir（某个模块名）</code>查看输出</li><li>打开blender的text editor，很多模板文件可供使用：</li><li>用python console中的.后代码提示快捷键自动补全查看方法（ctrl+space）</li><li>查询api</li><li>全球最大爱好者论坛<a href="https://blender.stackexchange.com/" target="_blank" rel="noopener">https://blender.stackexchange.com/</a></li><li>查看各类开源插件</li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li><p>bpy 意思是 blender python</p></li><li><p>常规得到某个物体信息流程 </p><p>1 viewport选中物体 </p><p>2 查看Transform的提示 </p><p>3 调用各种信息 类似 .location</p></li></ul><p>常用命令</p><p><code>bpy.context.</code> 正文，当前环境的所有内容的意思</p><p><code>bpy.context.object</code> 物体</p><p><code>mesh = bpy.data.objects[&quot;mesh&quot;]</code> Mesh变量存储物体mesh</p><p><code>bpy.ops.object.select_all(action=&#39;SELECT&#39;)</code>全选命令</p><p><code>bpy.ops.object.select_all(action=&#39;DESELECT&#39;)</code>全不选命令</p><p><code>bpy.context.view_layer.objects.active = mesh</code>大纲选中，激活物体</p><p><code>bpy.context.object.location</code> 拿到选中物体的世界坐标</p><p><code>bpy.context.object.location.z</code>拿到选中物体的世界坐标中的Z坐标数值</p><p><code>bpy.context.object.location.z += random()</code> 选中物体的世界坐标中的Z坐标数值随机加一个数</p><p><code>bpy.context.object.name</code>查看选中物体的名字</p><p><code>bpy.ops.object.duplicate(linked=False,mode=&#39;TRANSLATION&#39;)</code>复制模型</p><p><code>bpy.ops.object.modifier_add(type=&#39;DECIMATE&#39;)</code>添加编辑器</p><p><code>bpy.context.object.modifiers[&quot;Decimate&quot;].ratio = 0.1</code>设置编辑器参数</p><p><code>bpy.ops.object.modifier_apply(apply_as=&#39;DATA&#39;, modifier=&quot;Decimate&quot;)</code>#应用编辑器</p><p><code>bpy.context.object.name = &quot;要改的名字&quot;</code> 选中物体的名字</p><p><code>bpy.ops.mesh.primitive_cube_add()</code>创建box</p><p><code>bpy.context.object.active_material</code>返回当前选择物体的材质球</p><p><code>bpy.data.materials.get(材质球名称字符串)</code>拿到当前场景的某个材质</p><p><code>bpy.context.view_layer.objects.active.material_slots.data.active_material= 某个材质</code> 给当前激活的物体材质球插槽赋予某个材质</p><p><code>bpy.ops.wm.save_mainfile(filepath=&quot;E:\\Test\\testsave.blend&quot;)</code>存储当前文件</p><p><code>bpy.ops.wm.open_mainfile(filepath=BlendFilePath)</code> 打开文件</p><p>得到当前版本的blender文件夹路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">argv &#x3D; sys.argv #当前blender的路径例：[&#39;D:\\blender-2.81a\\blender.exe&#39;]</span><br></pre></td></tr></table></figure><p>遍历列表选中物体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in bpy.context.visible_objects:#迭代所有可见物体</span><br><span class="line">if i.name &#x3D;&#x3D; &quot;要选物体的名字&quot;:</span><br><span class="line">i.select_set(state&#x3D;True)</span><br><span class="line">for i in bpy.context.visible_objects:</span><br><span class="line">    if i.type &#x3D;&#x3D; &quot;MESH&quot;:#判断物体类型是模型</span><br><span class="line">        bpy.context.view_layer.objects.active &#x3D; i #当前激活物体定义为i</span><br><span class="line">        bpy.ops.object.mode_set(mode&#x3D;&#39;EDIT&#39;) #编辑模式</span><br><span class="line">        bpy.context.tool_settings.mesh_select_mode &#x3D; (False, True, False)#编辑模式的（点线面）</span><br><span class="line">        bpy.ops.mesh.select_all(action&#x3D;&#39;SELECT&#39;)#全选命令</span><br><span class="line">        bpy.ops.object.mode_set(mode&#x3D;&#39;OBJECT&#39;)#关闭编辑模式</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编辑器&quot;&gt;&lt;a href=&quot;#编辑器&quot; class=&quot;headerlink&quot; title=&quot;编辑器&quot;&gt;&lt;/a&gt;编辑器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装python3.0以上(Blender 2.8是 python3.x)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vscode 安装python 和 blender Development 插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;终端安装 fake-bpy 包&lt;code&gt;pip install fake-bpy-module-2.80&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/nutti/fake-bpy-module&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/nutti/fake-bpy-module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完上面这些，vscode里面就会有自动补全&lt;/p&gt;
&lt;p&gt;Debug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ctrl + shift + P, select “Blender: Start”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择你的blender安装路径, vscode会连接到blender&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ctrl + shift + P, “Blender: Run script” 并且可以使用断点调试&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="blender" scheme="http://yoursite.com/tags/blender/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python</title>
    <link href="http://yoursite.com/2020/03/10/Effective-Python/"/>
    <id>http://yoursite.com/2020/03/10/Effective-Python/</id>
    <published>2020-03-10T11:14:04.000Z</published>
    <updated>2020-03-15T01:43:09.288Z</updated>
    
    <content type="html"><![CDATA[<p>编写高质量代码的59+91个建议读书笔记</p><h3 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h3><ul><li>确认自己所用的python版本。</li><li>确保该版本与你想使用的python版本相符。</li><li>优先使用python3</li></ul><h5 id="Windows平台下："><a href="#Windows平台下：" class="headerlink" title="Windows平台下："></a>Windows平台下：</h5><p><code>$python --version</code><br><img src="/2020/03/10/Effective-Python/2020-03-07-11-15-23.png" alt="a"></p><a id="more"></a><h5 id="其他程序内："><a href="#其他程序内：" class="headerlink" title="其他程序内："></a>其他程序内：</h5><ul><li><p>Autodesk Maya:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-18-24.png" alt="b"></p></li><li><p>Substance Designer:<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-19-36.png" alt="c"><br>注：SD里sys.version_info报错，原因未知</p></li><li><p>Houdini：<br><img src="/2020/03/10/Effective-Python/2020-03-07-11-22-33.png" alt="d"></p></li></ul><p>Tips： Python中sys模块还有一个常用功能：<br><code>sys.path</code>可以用来找到应用程序内的python编译器位置.</p><h3 id="第二条"><a href="#第二条" class="headerlink" title="第二条"></a>第二条</h3><p>遵循PEP8 风格指南<br>《Python Enhancement Proposal #8》（8号Python增强法案）又叫PEP8,它是针对Python代码格式而编订的风格指南。</p><ul><li>使用空格来表示缩进，而不要用制表符（tab）。</li><li>和语法相关的每一层缩进都用四个空格表示。</li><li>每行的字符数不应超过79。</li><li>对于占据多行的长表达式，除了首行之外的其余各行都应该在通常的缩进级别之上再加四个空格。</li><li>文件中的代码与函数和类之间应该用两个空行隔开。</li><li>在同一个类中，各方法之间应该用一个空行隔开。</li><li>在使用下标来获取列表元素、调用函数或给关键字参数赋值的时候，不要再两边添加空格。</li><li>为变量赋值的时候，赋值符号的左侧和右侧应该各自写上一个空格，而且只写一个。</li></ul><p>命名：PEP8 提倡采用不同的命名风格来编写Python代码中的各个部分,以便再阅读代码时可以根据这些名称看出它们的角色。</p><ul><li>函数、变量名及属性应该用小写字母，各单词之间用下划线相连，例如，lowercase_underscore。</li><li>受保护的实例属性，应该以单个下划线开头，例如，_leading_underscore.</li><li>私有的实例属性，应该以两个下划线开头，例如__double_leading_underscore.</li><li>类与异常， 应该以每个单词首字母均大写的形式来命名，例如，CapitalizedWord。</li><li>模块级别的常量，应该全部采用大写字母来拼写，各单词之间以下划线连接，例如，ALL_CAPS。</li><li>类中的实例方法（instance method），应该把首个参数命名self，以表示该对象自身.</li><li>类方法（class method）的首个参数，应该命名cls，以表示该类自身。</li></ul><p>表达式和语句《The Zen of Python》（python之禅）中说，每件事都应该有直白的做法，而且最好只有一种。</p><ul><li>采用内联形式的否定词 ，而不要把否定词放在整个表达式的前面，例如，应该写 if a is not b 而不是 if not a is b。</li><li>不要通过检测长度的方法来判断列表是否为空，而是应该采用if not somelist来判定。</li><li>同上条，如果判断列表不为空也是一样的， </li><li>不要编写单行的if语句、for循环、while循环及except复合语句，而是应该把这些语句分成多行来书写，以示清晰。</li><li>import语句应该重视放在文件开头.</li><li>引入模块的时候，总是应该使用绝对名称，而不应该根据当前模块的路径来使用相对名称，例如，引入bar包中的foo模块时，应该完成的写出 from bar import foo，而不应该简写为import foo。</li><li>如果一定要以相对的名称来编写import语句，那就采用明确的写法:from.import foo。</li><li>文件中的那些import语句应该按照顺序划分为三个部分，分别为标准库模块、第三方模块以及自用模块。各import语句应该按照模块的字母顺序来排列。</li></ul><p>Tips： vscode可以采用pylint来自动检测受测代码是否符合pep8。<br><a href="https://www.pylint.org/" target="_blank" rel="noopener">https://www.pylint.org/</a></p><h3 id="第三条"><a href="#第三条" class="headerlink" title="第三条"></a>第三条</h3><h5 id="了解bytes、str、和unicode的区别"><a href="#了解bytes、str、和unicode的区别" class="headerlink" title="了解bytes、str、和unicode的区别"></a>了解bytes、str、和unicode的区别</h5><ul><li>python3有两种表示字符序列的类型，bytes和str，前者的实例中包含原始的8位值，后者的实例中包含Unicode字符。</li><li>python2中也有两种表示字符序列的类型，str和Unicode. 前者包含原始的八位值，后者的实例着包含unicode字符。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-29-10.png" alt="e"></li><li>bytes 类型，是指一堆字节的集合，十六进制表现形式，两个十六进制数构成一个 byte ，以 b 开头的字符串是 bytes 类型。计算机只能存储二进制，字符、图片、视频、音乐等想存到硬盘上，必须以正确的方式编码成二进制后再存，但是转成二进制后不是直接以 0101010 的形式表示的，而是用bytes() 的类型来表示的。</li><li>把Unicode字符表示为二进制数据（原始八位值）有很多办法，常见且推荐的编码方式就是UTF-8。</li><li>但是python3 的str实例和python2的Unicode实例都没有和特定的二进制编码形式相关联，想要把Unicode字符转换为二进制数据，就必须使用encode方法，想要把二进制数据转化成为Unicode字符，则必须使用decode 方法。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-34-59.png" alt="f"></li><li>在 Python3 中内存里的字符串是以 Unicode 编码的，Unicode 的其中一个特性就是跟所有语言编码都有映射关系，所以 UTF-8 格式的文件，在 Windows 电脑上若是不能看，就可以把 UTF-8 先解码成 Unicode ，再由 Unicode 编码成 GBK 就可以了。<br><img src="/2020/03/10/Effective-Python/2020-03-07-14-32-20.png" alt="g"><h5 id="字符串的转换"><a href="#字符串的转换" class="headerlink" title="字符串的转换"></a>字符串的转换</h5></li><li>在Python3中，接受str或byts，并总是返回str的方法:  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, bytes):<span class="comment">#注意这个函数</span></span><br><span class="line">        value = bytes_or_str.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li><li>接受str或bytes，并总是返回bytes的方法：  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bytes_or_str, str):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li><li>在Python2中，接受str或unicode，并总是返回unicode的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_unicode(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, str):</span><br><span class="line">        value &#x3D; unicode_or_str.decode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure></li><li>接受str或unicode，并总是返回str的方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def to_str(unicode_or_str):</span><br><span class="line">    if isinstance(unicode_or_str, unicode):</span><br><span class="line">        value &#x3D; unicode_or_str.encode(&#39;utf-8&#39;)</span><br><span class="line">    else:</span><br><span class="line">        value &#x3D; unicode_or_str</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure><h5 id="推荐的文件操作符"><a href="#推荐的文件操作符" class="headerlink" title="推荐的文件操作符"></a>推荐的文件操作符</h5>如果通过open函数获取文件句柄，该句柄会采用UTF-8编码格式来操作文件。<br>而在Python2中，文件操作的默认编码格式则是二进制形式。这可能会导致程序出现奇怪的错误。<br>例如，向文件中随机写入一些二进制数据。下面这种方法Python2中可以正常运行，但是在Python3中则不行：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TypeError: must be str, <span class="keyword">not</span> bytes</span><br></pre></td></tr></table></figure>上述情况是因为Python3给open函数添加了名为encoding的新参数，而这个新参数默认值是’utf-8′。这样在文件句柄上进行read和write操作时，系统就要求开发者必须传入包含unicode字符的str实例，而不接受包含二进制数据的bytes实例。</li></ul><p>解决这个问题，可以用二进制写入模式(‘wb’)来开启待操作的文件，按照这种方式可同时适配Python2和Python3：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>(读取文件也同理，可使用’rb’模式)</p><h3 id="第四条"><a href="#第四条" class="headerlink" title="第四条"></a>第四条</h3><p>用辅助函数来取代复杂的表达式</p><ul><li>开发者很容易过度运用Python的语法特性，从而写出那种特别复杂并且难以理解的单行表达式。</li><li>请把复杂的表达式移入辅助函数中。如果要反复使用相同的逻辑，那就更应该那么做。</li><li>使用if/esle表达式，要比用or或者and 这样的Boolean操作符写出的表达式更清晰。</li></ul><h3 id="第五条"><a href="#第五条" class="headerlink" title="第五条"></a>第五条</h3><p>了解切割序列的方法<br>python提供了一种把序列切成小块的写法，这种切片操作很容易四开发者轻易的访问序列中的某些元素所构成的子集。<br>最简单的用法，就是对内置list和bytes进行切割。<br>切割操作还可以延伸到实现了<strong>getitem</strong>和<strong>setitem</strong>这两个特殊方法的python类上，参见28条。</p><ul><li>不要写多余的代码。但start索引为零或者end索引为序列长度时，应该将其忽略</li><li>切片操作不会计较start或者end索引是否越界，这样我们很容易从前端或者后端开始。</li><li>对list赋值时，如果使用切片操作，就会把原列表中处在相关范围内的值替换成新值，即便它们的长度不同也依然可以替换。</li></ul><h3 id="第六条"><a href="#第六条" class="headerlink" title="第六条"></a>第六条</h3><p>在单词切片操作内，不要同时指定start、 end 和 stride </p><ul><li>问题在于采用stride方式进行切片时，经常会出现不符合预期的结果</li><li>切割列表时，如果制定了stride，代码就会变得费解。尤其是stride为负值的时候更是如此.</li><li>在同一个切片操作内，不要同时使用start、end和stride. 如果确实需要执行这种操作，那就考虑将其拆解为两条赋值语句，其中一条做范围切割，另一条做步进，或者考虑使用内置itertools模块中的islice.</li></ul><p>tips：<br><code>mystring[::-1]#反转字符串</code></p><h3 id="第七条"><a href="#第七条" class="headerlink" title="第七条"></a>第七条</h3><p>用列表推导来取代map和filter<br>python提供了一种精炼的写法，可以根据一个列表来制作另外一个列表.这种表达式称为list comprehension （列表推导）</p><ul><li>列表推导要比内置的map和filter函数清晰</li><li>列表推导可以很跳过输入列表中的某些元素</li><li>字典与集也支持推导表达式</li></ul><h3 id="第八条"><a href="#第八条" class="headerlink" title="第八条"></a>第八条</h3><p>不要使用含有两个以上表达式的列表推导</p><ul><li>列表推导支持多级循环，每一级循环也支持多项条件</li><li>超过两个表达式的列表推导难以理解，应该尽量避免<br>Tips：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br><span class="line">print(flat)</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="comment">#下面两种写法是等效的</span></span><br><span class="line"><span class="comment">#要从列表中取出大于4的偶数</span></span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">if</span> x %<span class="number">2</span> ==<span class="number">0</span>]</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt;<span class="number">4</span> <span class="keyword">and</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="第九条"><a href="#第九条" class="headerlink" title="第九条"></a>第九条</h3><p>用生成器表达式来改写数据量较大的列表推导<br>列表推导的缺点是，对于输入序列中的每个值来说，都要创建一项仅含一项元素的全新列表，但输入数据较大时，可能会消耗大量内存，并导致程序崩溃。<br>为了解决此问题，python 提供了生成式表达式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt))</span><br><span class="line">print(it)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x101b81480</span>&gt;</span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">57</span></span><br></pre></td></tr></table></figure><p>Tips：<br>获取文件每行的字符数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(temp.txt)]</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure><ul><li>当输入的数据量较大时，列表推导可能会因为占用太对内存而出问题。</li><li>由生成表达式所返回的迭代器，可以逐次产生输出值，从而避免了内存用量问题。</li><li>把某个生成器表达式说返回的迭代器，放在另一个生成器表达式的for子表达式中，即可将二者组合起来。</li><li>串在一起的生成器表达式执行速度很快。 </li></ul><h3 id="第十条"><a href="#第十条" class="headerlink" title="第十条"></a>第十条</h3><p>尽量用enumerate取代range<br>在一些列的整数上面迭代，内置的range函数很有用，<br>当迭代列表的时候，通常还想知道当前元素在列表中的索引。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(flavor_list)):</span><br><span class="line">    flavor = flavor_lsit[i]</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure><p>这种代码不利于理解，python提供了enumerate来解决此问题。enumerate可以把各种迭代器包装为生成器，以便稍后产生输出值，生成器每次产生一对输出值，前者为循环下标，后者表示从迭代器中获取到的下一个序列元素，这样写出来的代码会非常整洁。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i+<span class="number">1</span>,flavor))</span><br></pre></td></tr></table></figure><ul><li>enumerate函数提供了一种精简的写法，可以在遍历迭代器时获知每个元素的索引</li><li>尽量用enumerate来改写那种将range与下标访问相结合的序列遍历代码</li><li>可以给enumerate 提供第二个参数，已指定开始计数时所用的值（默认为0）</li></ul><p>Tips:<br>还可以直接指定enumerate开始计数所用的值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i ,flavor <span class="keyword">in</span> enumerate(flavor_list，<span class="number">1</span>):</span><br><span class="line">    print(<span class="string">"%d:%s"</span>%(i,flavor))</span><br></pre></td></tr></table></figure><h3 id="第十一条"><a href="#第十一条" class="headerlink" title="第十一条"></a>第十一条</h3><p>用zip函数同时遍历两个迭代器</p><ul><li><p>使用for循环</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Cecilia</span><br></pre></td></tr></table></figure><p>上面这段代码问题在一，整个循环语句看上去很乱，用下标来访问names和letters会使代码不易阅读。<br>改用enumerate可以稍稍缓解这个问题，但仍然不够理想。</p></li><li><p>使用for循环加enumerate</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names)：</span><br><span class="line">    count =letters[i]</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure></li><li><p>使用zip</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Cecilia'</span>, <span class="string">'Kufu'</span>, <span class="string">'JayChou'</span>]</span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letter):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure></li><li><p>内置的zip函数可以平行的遍历多个迭代器</p></li><li><p>Python3中的zip相当于生成器，会在遍历过程中逐次产生元组，而Python2中的zip则是直接把这些元组完全生成号，并一次性的返回给整份列表。</p></li><li><p>如果提供的迭代器长度不等，那么zip就会自动提前终止。</p></li><li><p>itertools 内置模块中的zip_longest函数可以平行的遍历多个迭代器，而不用在乎它们的长度是否相等。</p></li></ul><h3 id="不要在for和while循环后面写else语块"><a href="#不要在for和while循环后面写else语块" class="headerlink" title="不要在for和while循环后面写else语块"></a>不要在for和while循环后面写else语块</h3><ul><li>python 有种特殊语法，可在 for及 while 循环的内部语句块之后紧跟一个else块。</li><li>只有当整个循环主体都没遇到break语句时，循环后面的else块才会执行。</li><li>不要再循环后面使用else块，因为在这种写法即不直观，又容易引人误解。</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/lipandeng/p/11162039.html" target="_blank" rel="noopener">https://www.cnblogs.com/lipandeng/p/11162039.html</a><br><a href="https://lingyunfx.com/?page_id=152" target="_blank" rel="noopener">https://lingyunfx.com/?page_id=152</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写高质量代码的59+91个建议读书笔记&lt;/p&gt;
&lt;h3 id=&quot;第一条&quot;&gt;&lt;a href=&quot;#第一条&quot; class=&quot;headerlink&quot; title=&quot;第一条&quot;&gt;&lt;/a&gt;第一条&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;确认自己所用的python版本。&lt;/li&gt;
&lt;li&gt;确保该版本与你想使用的python版本相符。&lt;/li&gt;
&lt;li&gt;优先使用python3&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Windows平台下：&quot;&gt;&lt;a href=&quot;#Windows平台下：&quot; class=&quot;headerlink&quot; title=&quot;Windows平台下：&quot;&gt;&lt;/a&gt;Windows平台下：&lt;/h5&gt;&lt;p&gt;&lt;code&gt;$python --version&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/2020/03/10/Effective-Python/2020-03-07-11-15-23.png&quot; alt=&quot;a&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>GameCourse101</title>
    <link href="http://yoursite.com/2020/03/10/GameCourse101/"/>
    <id>http://yoursite.com/2020/03/10/GameCourse101/</id>
    <published>2020-03-10T11:14:04.000Z</published>
    <updated>2020-03-15T14:31:37.941Z</updated>
    
    <content type="html"><![CDATA[<p>计算机图形学入门 课程学习笔记</p><h2 id="第一节-引入"><a href="#第一节-引入" class="headerlink" title="第一节 引入"></a>第一节 引入</h2><p>怎么判断一个游戏画面的水平，有一个很简单的方法就是画面亮不亮。</p><h2 id="第二节-线性代数"><a href="#第二节-线性代数" class="headerlink" title="第二节 线性代数"></a>第二节 线性代数</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量是带有方向的量<br>重要的两个量是方向和长度<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-49-03.png" alt>  </p><a id="more"></a><p>数学： 向量<br>物理： 矢量<br>向量长度：<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-49-24.png" alt><br>向量加法（求和）：<br>几何上<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-49-38.png" alt><br>数学上<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-49-58.png" alt><br>我们把向量表示成直角坐标系这种形式是有助于计算向量的长度的。  </p><h4 id="向量的点乘和叉乘"><a href="#向量的点乘和叉乘" class="headerlink" title="向量的点乘和叉乘"></a>向量的点乘和叉乘</h4><p>向量更广泛的用法<br><img src="/2020/03/10/GameCourse101/2020-03-08-12-50-12.png" alt>  </p><h5 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-12-50-25.png" alt><br>左边是两个向量，右边是一个数字。<br>如果两个向量都是单位向量，那么它们点乘的结果就是余弦的值。  </p><p><img src="/2020/03/10/GameCourse101/2020-03-08-12-58-31.png" alt><br>点乘既然是一种运算，运算法则都会满足一些性质。<br>交换律 结合律 分配律  </p><p><img src="/2020/03/10/GameCourse101/2020-03-08-13-08-11.png" alt><br>如果是在坐标系下，就跟简单。  </p><p><img src="/2020/03/10/GameCourse101/2020-03-08-13-02-30.png" alt>  </p><ol><li>点乘在图形学最重要的作用就是找到两个向量的夹角。<br>比如 光从哪个地方射过来（向量）物体表面法线是什么样的（向量）我们从哪里看（向量）</li><li>第二个重要作用就是找到一个向量的投影到另一个向量是长什么样的。<br>投影算出来有什么好处呢？ 我们可以把一个向量分解成两个向量，一个平行一个垂直。这样可以帮助我们把任意向量分解到任意坐标轴。<br> <img src="/2020/03/10/GameCourse101/2020-03-08-13-17-01.png" alt></li><li>在图形学里，我们还可以根据点乘的结果判定两个向量是否接近是否远离。</li><li>向量点乘还可以告诉大家一个前与后的信息，如图（向量a和向量b点乘为正值且接近1，向量a和向量c点乘为负值，如果有一个向量跟向量a一样，那点乘结果为1，如果有一个向量正好在虚线上，那点乘的值为0，如果跟向量a正好相反，那点乘结果为-1）<br><img src="/2020/03/10/GameCourse101/2020-03-08-13-44-08.png" alt>  </li></ol><h5 id="叉乘（叉积）"><a href="#叉乘（叉积）" class="headerlink" title="叉乘（叉积）"></a>叉乘（叉积）</h5><p>叉乘是给定两个向量计算出同时垂直与这两个向量的新的向量，另外同时垂直这两个向量也就是必然垂直这两个向量形成的平面<br><img src="/2020/03/10/GameCourse101/2020-03-08-13-57-13.png" alt><br><strong>右手螺旋定则</strong>（DirectX是右手，openGL是左手）。<br>定义，右手伸值大拇指向天空，四个拇指朝向手心握（逆时针运动），如果大拇指向大地，四个拇指朝向手心握（顺时针运动）。这里右手指向天空为正，所以逆时针运动为正。</p><p>例子：</p><ol><li>Z叉乘X,XYZXYZ,Z到X就是顺时针，所以得到正Y。</li><li>Y叉乘X，XYZXYZ,Y到X就是逆时针，所以得到负Z。</li></ol><p>向量的叉乘并不满足交换律（如果要交换需要加一个负号）<br>向量的叉积还有一个作用是我们利用它来建立一个三维空间中的直角坐标系<br><img src="/2020/03/10/GameCourse101/2020-03-08-14-04-16.png" alt><br>几何：<br><img src="/2020/03/10/GameCourse101/2020-03-08-14-36-32.png" alt>  </p><p>叉积怎么算，有什么用处：<br><img src="/2020/03/10/GameCourse101/2020-03-08-14-37-55.png" alt><br>特别重要 </p><p><img src="/2020/03/10/GameCourse101/2020-03-08-14-38-58.png" alt></p><ol><li>判定左和右<br>如图左侧，XY为平面，通过右手螺旋定则，Z为朝向我们自身的向量，如果想判断向量b在向量a左侧还是右侧（什么是左侧右侧? 从向量a顺时针旋转到达向量b为左侧，逆时针为右侧），在这里根据图示很容易看出来向量b是在向量a的左侧，如果用数字表示就是 向量a叉乘向量b得到的结果是正值（指向身体）就说明向量b在向量a的左侧，如果向量b叉乘向量a得到的结果是负值（指向身体外侧），那就说明向量a在向量b右侧，</li><li>判定内与外<br>如图右侧，先判断向量AP是否在向量AB的左侧，在判断向量BP是否在向量BC的左侧，在判断向量AP是否在ac的左侧，如果都是在左侧就说明点P在三角形内部，否则肯定有一个判断是在右侧。<br>这里假设了ABC三个点是逆时针排布，如果换成顺时针也没有问题，只不过是都在左侧。<br>所以我们可以忽略三角形的排布顺序，只要三个边左或者右保持一致就说明点在三角形内部。这点非常重要，是光栅化的基础（用来判断像素是否在三角形的内部）。</li></ol><h4 id="向量定义坐标系"><a href="#向量定义坐标系" class="headerlink" title="向量定义坐标系"></a>向量定义坐标系</h4><p><img src="/2020/03/10/GameCourse101/2020-03-08-15-51-31.png" alt><br>向量叉乘可以定义一些互相垂直的轴，就会形成坐标系如图。<br><img src="/2020/03/10/GameCourse101/2020-03-08-15-52-25.png" alt><br>这里顶一个uvw坐标系，三个向量单位长度都为1，互相垂直，给你u和v 叉乘得到w。<br>我们可以利用投影把任意一个向量分解到三个轴上去，利用点乘，因为什么呢？向量P点乘向量U，等于是向量P的长度乘以向量U的长度在乘以cosθ，向量U又恰好是单位向量为1，等于是向量P的长度乘以cosθ，根据下图三角函数，就会得出向量P在向量U上的投影，同理获得向量P在向量V和向量W上的投影，有了这三个投影就可以获得坐标系下的这个向量。<br><img src="/2020/03/10/GameCourse101/2020-03-08-16-07-00.png" alt><br>cosA = c/b  </p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><img src="/2020/03/10/GameCourse101/2020-03-08-16-47-04.png" alt><br><strong>在图像学里，变换就是矩阵的最大应用。</strong><br><img src="/2020/03/10/GameCourse101/2020-03-08-20-44-32.png" alt>  </p><h5 id="矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量"><a href="#矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量" class="headerlink" title="矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量."></a>矩阵乘以和加上一个常量就是把矩阵的每个元素乘以和加上一个常量.</h5><h5 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-20-53-06.png" alt><br>矩阵乘矩阵必须要符合条件才能乘，如图必须第一个矩阵的列数和第二个矩阵的行数相同相乘才有意义。<br><strong>关于新得到的矩阵每一个元素都是什么，有不同的数学定义，这个地方比较不容易记住，这里给大家提供一个容易记得方法，比如左下角这个8，他的坐标是三行一列，这里三行对应第一个矩阵（0，4），一列对应第二个矩阵（3，2），这两个向量点乘。</strong><br><img src="/2020/03/10/GameCourse101/2020-03-08-21-50-50.png" alt><br>矩阵乘法是没有交换律的，但是矩阵是由结合律和分配律。  </p><h5 id="矩阵乘向量"><a href="#矩阵乘向量" class="headerlink" title="矩阵乘向量"></a>矩阵乘向量</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-21-53-53.png" alt></p><blockquote><p>一个矩阵如何和一个向量乘？当我们认为向量是列向量就有意义了（也就是说M永远为1）。    </p></blockquote><p><em>这是最重要的核心。</em><br>下面表示一个2D向量按Y轴镜像的操作。</p><h5 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-22-01-06.png" alt><br>性质： 如果要乘两个矩阵在转置好比相对后一个矩阵做装置在乘以前一个矩阵做转置的结果。</p><h5 id="特殊的矩阵，单位矩阵"><a href="#特殊的矩阵，单位矩阵" class="headerlink" title="特殊的矩阵，单位矩阵"></a>特殊的矩阵，单位矩阵</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-22-07-51.png" alt><br>对角阵，只有对角线上有非零的元素，<br>矩阵的逆：如果你能找到一个矩阵，和原来的矩阵相乘，不管乘得顺序，得到的结果都是I，那么我们就认为这两个矩阵是互逆的。<br>逆矩阵的计算和转置的矩阵很相似。</p><h5 id="向量点乘和叉乘的矩阵形式"><a href="#向量点乘和叉乘的矩阵形式" class="headerlink" title="向量点乘和叉乘的矩阵形式"></a>向量点乘和叉乘的矩阵形式</h5><p><img src="/2020/03/10/GameCourse101/2020-03-08-22-12-11.png" alt><br>点乘：向量a点乘向量b 等于向量a转置和向量b的乘法。<br>叉乘：相对点乘困难一些，相当于把向量a转换成一个矩阵（dual matrix）乘以向量b</p><h2 id="第三节-变换"><a href="#第三节-变换" class="headerlink" title="第三节 变换"></a>第三节 变换</h2><p><img src="/2020/03/10/GameCourse101/2020-03-14-16-48-49.png" alt></p><p><img src="/2020/03/10/GameCourse101/2020-03-14-16-53-27.png" alt></p><h4 id="我们为什么要学习变换："><a href="#我们为什么要学习变换：" class="headerlink" title="我们为什么要学习变换："></a>我们为什么要学习变换：</h4><ul><li>Modeling：<br>位移 旋转 缩放<br>很多动画就是由各种不同的变换合成在一起形成的。</li><li>Viewing：<br><img src="/2020/03/10/GameCourse101/2020-03-14-16-58-58.png" alt><br>光栅化成像涉及到大量的变换。<br>3D -&gt; 2D 从三维到二维的变换我们叫做投影，这个投影也是一种非常重要的变换，之后会学到。<h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><img src="/2020/03/10/GameCourse101/2020-03-14-17-01-01.png" alt><br>今天我们的目标就是，把矩阵和变换联系起来。<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="标准缩放"><a href="#标准缩放" class="headerlink" title="标准缩放"></a>标准缩放</h5><img src="/2020/03/10/GameCourse101/2020-03-14-17-02-15.png" alt><br>横轴和纵轴都缩放了0.5，也就是说把任何一个点坐标(X,Y)进行缩放操作0.5倍。<br>如果用数学形式表示, 可以表示为<br><img src="/2020/03/10/GameCourse101/2020-03-14-17-06-00.png" alt><br>如果用矩阵形式表示可以表示为对角矩阵。<br><img src="/2020/03/10/GameCourse101/2020-03-14-17-06-36.png" alt><br>是不是这样的，我们可以验证一下。<br><img src="/2020/03/10/GameCourse101/2020-03-14-17-32-25.png" alt><h5 id="如果XY的缩放各不相同"><a href="#如果XY的缩放各不相同" class="headerlink" title="如果XY的缩放各不相同:"></a>如果XY的缩放各不相同:</h5><img src="/2020/03/10/GameCourse101/2020-03-14-17-34-39.png" alt><h5 id="如果是反射（对称）的操作："><a href="#如果是反射（对称）的操作：" class="headerlink" title="如果是反射（对称）的操作："></a>如果是反射（对称）的操作：</h5><img src="/2020/03/10/GameCourse101/2020-03-14-17-36-36.png" alt><br>等于是Y轴不变，X轴反过来。<h5 id="如果是切变的操作："><a href="#如果是切变的操作：" class="headerlink" title="如果是切变的操作："></a>如果是切变的操作：</h5><img src="/2020/03/10/GameCourse101/2020-03-14-17-39-12.png" alt><br>注意这里可以通过一个点的变换前到变换后的变化推导出,Y是不变的，X是变成了X+ay，由x+ay倒推出矩阵.<h5 id="如果是旋转的操作："><a href="#如果是旋转的操作：" class="headerlink" title="如果是旋转的操作："></a>如果是旋转的操作：</h5><img src="/2020/03/10/GameCourse101/2020-03-14-18-00-56.png" alt><br>默认是绕(0,0)点旋转，逆时针旋转.<br><img src="/2020/03/10/GameCourse101/2020-03-14-18-00-15.png" alt><br>简单的推导：</li><li>不管再复杂的操作，先找到一个一一对应的关系点，再倒推。<br><img src="/2020/03/10/GameCourse101/2020-03-14-18-13-23.png" alt><br>通过（1，0）点的对应关系点配合三角函数可以得到矩阵AC值，那么通过（0，1）点的对应关系点可以找到BC.<h5 id="变换的共同点"><a href="#变换的共同点" class="headerlink" title="变换的共同点"></a>变换的共同点</h5><img src="/2020/03/10/GameCourse101/2020-03-14-18-33-00.png" alt><br>X pu ruai mu = 变换矩阵*X<br>这样变换和矩阵的联系就建立起来了，对于一个变换就可以用矩阵来表示。<br>概念区分： 我们要用一个相同维度的矩阵来乘以向量。</li></ul><h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><h5 id="为什么要学习齐次坐标，为什么要引入这个复杂的东西。"><a href="#为什么要学习齐次坐标，为什么要引入这个复杂的东西。" class="headerlink" title="为什么要学习齐次坐标，为什么要引入这个复杂的东西。"></a>为什么要学习齐次坐标，为什么要引入这个复杂的东西。</h5><p>因为平移变换特别特殊。<br><img src="/2020/03/10/GameCourse101/2020-03-14-18-40-34.png" alt><br>如果简单的写出来，是挺简单的，但是没有办法转换成矩阵:<br><img src="/2020/03/10/GameCourse101/2020-03-14-18-41-24.png" alt><br>所以无奈之下必须要用齐次坐标。<br><img src="/2020/03/10/GameCourse101/2020-03-14-18-42-38.png" alt><br>平移操作并不属于一个线性变换（因为线性变换必须等于一个向量等于一个矩阵乘以另外一个向量），但是我们不希望把平移当作一个特殊的情况处理，因为人类总是懒的。所以有没有办法可以把我们提到的所有变换归纳成一个最简单的变换来表示。<br>tradeoff：权衡.</p><h5 id="齐次坐标-1"><a href="#齐次坐标-1" class="headerlink" title="齐次坐标"></a>齐次坐标</h5><p><img src="/2020/03/10/GameCourse101/2020-03-14-19-26-18.png" alt><br>如果XY表示点的坐标那就加上1，如果是向量加上0。为什么区别对待?<br>因为向量具有<strong>平移不变性</strong>：<br>如果有一个向量经过一个表示平移的矩阵，我们希望它的结果还是XY0.</p><blockquote><p>向量是个所谓的“过程量”，不依赖于本身的位置。<br><img src="/2020/03/10/GameCourse101/2020-03-14-19-39-25.png" alt></p></blockquote><ol><li>如果两个向量相加，结果是新的向量（x1+x2，y1+y2，0+0）有意义。</li><li>如果两个点相减（形成一个从被减数指向减数向量）（x1-x2，y1-y2，1-1=0）点减点等于向量，有意义。</li><li>如果是点加向量，一个点沿着向量移动到一个新的点上，<br>（x1+x2，y1+y2，1+0=1）有意义。</li><li>一个点加一个点，没意义，扩充的定义。</li><li>对于任何的二维点，我们认为，(x/w,y/2,w/w),w!=0(0就是向量了。)</li><li>一个点加一个点，表示这两个点的中点。为什么？因为一个点加一个点w会变成2，这个w变成1的过程就是在求中点。</li></ol><p>最重要的不是这些变换，而是目的，我们的目的是就是为了把所有的变换写出一个矩阵乘以一个向量的形式。</p><h5 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h5><p><img src="/2020/03/10/GameCourse101/2020-03-14-20-00-24.png" alt><br>线性变换+位移，对于类似的变换就叫仿射变换。<br>所有的仿射变换都可以写成齐次坐标这种形式。<br>验证：<br><img src="/2020/03/10/GameCourse101/2020-03-14-20-03-21.png" alt><br>只要表示<strong>仿射变换</strong>最后一行都是001，理论上只用存储上面的部分就行了。</p><h5 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h5><p>逆变换是指把一个变换的操作反过来。<br>在数学对应的正好是乘以这个变换的逆矩阵（一个矩阵乘以它自己的逆矩阵一定等于单位矩阵）<br><img src="/2020/03/10/GameCourse101/2020-03-15-13-31-02.png" alt></p><h5 id="变换组合-分解"><a href="#变换组合-分解" class="headerlink" title="变换组合/分解"></a>变换组合/分解</h5><p><img src="/2020/03/10/GameCourse101/2020-03-15-13-38-30.png" alt><br>对于这样一个变换我们可以把它看成先平移在旋转，如下图：<br><img src="/2020/03/10/GameCourse101/2020-03-15-13-39-04.png" alt><br>但是结果不对，因为旋转还是绕(0,0)点。怎么操作对呢？如下图：<br><img src="/2020/03/10/GameCourse101/2020-03-15-13-40-32.png" alt></p><p>如此可以得到两个信息：</p><ol><li>复杂的变换可以通过简单的变化得到。</li><li>变换的顺序非常重要。(对应矩阵乘法不满足交换律{变换就是在某一个向量前面乘以一个矩阵，再变换一次就是再在前面乘以一个矩阵，矩阵的乘的顺序变换那结果就会发生变化})<br><img src="/2020/03/10/GameCourse101/2020-03-15-13-45-44.png" alt><br><img src="/2020/03/10/GameCourse101/2020-03-15-13-46-04.png" alt><br>先乘旋转矩阵再乘平移矩阵，也就是等号左边逐个变换逐个向左写，等会右边乘的时候也是从右往左乘（跟整数乘法正好相反），推广概念如下图：<br><img src="/2020/03/10/GameCourse101/2020-03-15-13-51-43.png" alt><br>Tips：矩阵没有交换律，但是有结合律。可以把A1到An乘完得到一个矩阵在和向量相乘，也就是说，<strong>一个矩阵就可以表示非常复杂的变换</strong></li></ol><p>同样道理，变换既然可以合成也就可以分解。如下图：<br><img src="/2020/03/10/GameCourse101/2020-03-15-13-57-30.png" alt><br>如果我们想已给定点为中心进行旋转，可以分解如图，先把这个点移到（0,0）点{移动一个-C}，然后旋转，再移动回去{移动一个C}</p><h5 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h5><p>三维的变换就是把二维的变换拿过去做类比就可以（包括齐次坐标表示）。<br>三维空间也会有线性变换，三维空间也会有平移。也不希望三维空间的平移变成特殊现学，也就再次用齐次坐标，再加一个数。四维数表示三维空间的点和向量。<br><img src="/2020/03/10/GameCourse101/2020-03-15-14-06-16.png" alt><br>4X4矩阵<br><img src="/2020/03/10/GameCourse101/2020-03-15-14-15-08.png" alt><br>三维空间中 仿射变换的情况下， 最后一行肯定是（0，0，0，1）</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如上图的变换，是先表示的线性变换还是先表示的位移？<br>是先进行的线性变换，再进行的位移。遇到此类问题可以考虑不用齐次坐标的表示。<br><img src="/2020/03/10/GameCourse101/2020-03-15-14-20-14.png" alt><br><img src="/2020/03/10/GameCourse101/2020-03-15-14-21-42.png" alt></p><h2 id="第四节-变换续"><a href="#第四节-变换续" class="headerlink" title="第四节 变换续"></a>第四节 变换续</h2><h5 id="上节的补充"><a href="#上节的补充" class="headerlink" title="上节的补充"></a>上节的补充</h5><p>二维情况下，如果不考虑齐次坐标，变换可以用2x2的矩阵来表示，<br><img src="/2020/03/10/GameCourse101/2020-03-15-14-46-17.png" alt><br>注意这里:<br>cos -θ 等于cosθ<br>sin -θ 等于-sinθ</p><p>这里有两个情况：</p><ol><li>和上面的矩阵相比这样我们就发现，旋转θ角和旋转-θ角就是把这个矩阵做了一个转置（行列对换）。  </li><li>从定义上来看，旋转θ角和旋转-θ角，应该是一个互逆的关系，旋转-θ角应该就是旋转θ角的到的矩阵的逆。<br>由此可以得出，如下图：<br><img src="/2020/03/10/GameCourse101/2020-03-15-15-04-08.png" alt><br>旋转矩阵的转置等于旋转矩阵的逆<br>tips：<br>在数学上如果一个矩阵的逆等于这个矩阵的转置，那么这个矩阵叫做正交矩阵。</li></ol><h5 id="上节的复习"><a href="#上节的复习" class="headerlink" title="上节的复习"></a>上节的复习</h5><p><img src="/2020/03/10/GameCourse101/2020-03-15-15-08-03.png" alt></p><h5 id="本节"><a href="#本节" class="headerlink" title="本节"></a>本节</h5><p><img src="/2020/03/10/GameCourse101/2020-03-15-15-37-29.png" alt><br>把三维变换结束掉之后，重点是viewing变换。</p><h5 id="三维变换-1"><a href="#三维变换-1" class="headerlink" title="三维变换"></a>三维变换</h5><p><img src="/2020/03/10/GameCourse101/2020-03-15-15-39-20.png" alt><br><img src="/2020/03/10/GameCourse101/2020-03-15-15-43-42.png" alt><br><img src="/2020/03/10/GameCourse101/2020-03-15-15-43-58.png" alt><br><img src="/2020/03/10/GameCourse101/2020-03-15-15-44-37.png" alt><br>对于三维空间的旋转变换，如果直接考虑绕任意一个轴旋转是很复杂的，但是如果绕XYZ的话就会相对简单，比如绕X轴移动的平面，其X坐标是不会发生任何改变的，发生改变的是Y，Z两个轴的数值。所以Rx和Rz都是有一个轴是不发生任何改变。<br><img src="/2020/03/10/GameCourse101/2020-03-15-16-48-58.png" alt><br>注意RxRz的符号是一致的，但是Ry是反的为什么呢，图上如果要的到Y就是Z叉乘X（xyzxyz循环对称性质），因为是反着的，所以结果符号是反的。</p><blockquote><p>这是因为二维平面定义时，逆时针实际是在三维从Z正向看，因此三维绕Y旋转，逆时针实际上是从Z向X运动，但是旋转矩阵的行列对应关系是X向Z转,取逆（转置）就得到了。<br><img src="/2020/03/10/GameCourse101/2020-03-15-16-48-21.png" alt><br>对于任意一个旋转，我们可以把它分解为绕X绕Y绕Z旋转。<br><img src="/2020/03/10/GameCourse101/2020-03-15-17-07-40.png" alt></p></blockquote><p><img src="/2020/03/10/GameCourse101/2020-03-15-17-11-12.png" alt><br>默认向量n的起点在原点，如果不是的话，可以用上一节的方法，先把它移动到原点，变换完再挪回去。  </p><h5 id="Viewing变换"><a href="#Viewing变换" class="headerlink" title="Viewing变换"></a>Viewing变换</h5><p>最终目的，是把三维空间里面的东西变成二维的。<br><img src="/2020/03/10/GameCourse101/2020-03-15-17-31-42.png" alt><br>|现实生活里拍照片动作|viewing变换动作|<br>|——————|————–|<br>|找好位置摆好pos|模型变换 model transformation|<br>|找到一个好的角度|视图变换 view transformation|<br>|茄子|投影变换 projection transformation|<br>简称MVP变换<br>怎么做view变换呢？<br><img src="/2020/03/10/GameCourse101/2020-03-15-17-56-38.png" alt></p><ol><li>位置 往哪看 </li><li>往哪看</li><li>相机本身的向上方向</li></ol><p><img src="/2020/03/10/GameCourse101/2020-03-15-18-00-49.png" alt></p><p><img src="/2020/03/10/GameCourse101/2020-03-15-21-13-05.png" alt></p><p>注意这里还是右手坐标系，可以使用右手螺旋定则判定。<br><img src="/2020/03/10/GameCourse101/2020-03-15-21-24-36.png" alt></p><p>怎么把这种变换表示成矩阵呢？<br><img src="/2020/03/10/GameCourse101/2020-03-15-21-26-48.png" alt></p><ol><li>位移： 注意应该先做线性变换在做平移，但是为了理解方便这里先做了平移，后做线性变换，但是接下来往左写，是一样的。</li><li>旋转：这里把某个向量旋转成标准轴不好实现，但是反过来把某个标准轴旋转成某个向量好实现，所以我们就等于先求出逆变换，（这里的矩阵逆用的很巧妙），怎么对一个旋转矩阵求逆呢？利用旋转矩阵是正交矩阵，正交矩阵的逆就是它的转置（本节课开始证明的）。</li><li>这个Mview矩阵就可以把摄影机移动到零点，同理也可以把其他所有东西移动到相对位置上。视图变换  </li></ol><p><img src="/2020/03/10/GameCourse101/2020-03-15-22-04-47.png" alt><br>总结：</p><ol><li>任何时候只要相机和物体应用同样的变换或者位移，结果不变。</li><li>视图变换操作的是相机，其他物体跟着变换。</li></ol><h5 id="Projection-transforamtion投影变换"><a href="#Projection-transforamtion投影变换" class="headerlink" title="Projection transforamtion投影变换"></a>Projection transforamtion投影变换</h5><ol><li>Orthographic projection 正交投影</li><li>Perspective projection 透视投影</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机图形学入门 课程学习笔记&lt;/p&gt;
&lt;h2 id=&quot;第一节-引入&quot;&gt;&lt;a href=&quot;#第一节-引入&quot; class=&quot;headerlink&quot; title=&quot;第一节 引入&quot;&gt;&lt;/a&gt;第一节 引入&lt;/h2&gt;&lt;p&gt;怎么判断一个游戏画面的水平，有一个很简单的方法就是画面亮不亮。&lt;/p&gt;
&lt;h2 id=&quot;第二节-线性代数&quot;&gt;&lt;a href=&quot;#第二节-线性代数&quot; class=&quot;headerlink&quot; title=&quot;第二节 线性代数&quot;&gt;&lt;/a&gt;第二节 线性代数&lt;/h2&gt;&lt;h3 id=&quot;向量&quot;&gt;&lt;a href=&quot;#向量&quot; class=&quot;headerlink&quot; title=&quot;向量&quot;&gt;&lt;/a&gt;向量&lt;/h3&gt;&lt;p&gt;向量是带有方向的量&lt;br&gt;重要的两个量是方向和长度&lt;br&gt;&lt;img src=&quot;/2020/03/10/GameCourse101/2020-03-08-12-49-03.png&quot; alt&gt;  &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="computer graphics" scheme="http://yoursite.com/tags/computer-graphics/"/>
    
  </entry>
  
  <entry>
    <title>Maya卡顿优化</title>
    <link href="http://yoursite.com/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</id>
    <published>2020-03-09T15:50:34.000Z</published>
    <updated>2020-03-11T02:24:46.913Z</updated>
    
    <content type="html"><![CDATA[<p>针对美术制作的 Maya 卡顿优化</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h3><ul><li>解释分析器</li><li>求值工具包</li></ul><h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><h3 id="信息获取-1"><a href="#信息获取-1" class="headerlink" title="信息获取"></a>信息获取</h3><ul><li><p>Viewport 2.0,必须拥有正确的图形配置和图形驱动程序版本。有关 Maya 认证显卡和最新驱动程序版本的信息：</p><p><a href="https://knowledge.autodesk.com/certified-graphics-hardware" target="_blank" rel="noopener">https://knowledge.autodesk.com/certified-graphics-hardware</a></p></li></ul><ul><li><p>GPU 内存</p><p>对于包含大量纹理、几何体或缓存动画的场景，请务必记下显卡上可用的 GPU RAM 量，如果 GPU RAM 使用量非常接近显卡的 GPU RAM 限制，纹理可能无法加载，并且场景可能显示为着色模式。此时将显示一条错误信息，指明已超出纹理 RAM 限制并建议您减小“最大纹理分辨率”(Max Texture Resolution)钳制。</p><p>查看 GPU 内存使用情况（以 MB 为单位），请使用Mel命令 </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ogs -gpu</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/1558686550786.png" alt="1558686550786"></p></li><li><p>查看卡的 GPU RAM 限制，请参见“Maya 的输出窗口”(Output Window of Maya)。</p><p><img src="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/1558686723618.png" alt="图片1"></p></li></ul><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><ul><li><p>尽量关闭屏幕空间环境光遮挡、多重采样抗锯齿、运动模糊。</p></li><li><p>不使用复杂的Shader（例如复杂的 ShaderFX 网络）或大量使用 DirectX 11 ubershader 的场景。</p></li><li><p>禁用灯光和灯光阴影。</p></li><li><p>GPU 实例化可减少 GPU 内存使用量。</p><p><img src="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/1558687101606.png" alt="图片2"></p></li><li><p>减小摄影机的远剪裁距离，以便在视口中显示较少的几何体</p></li><li><p>隐藏无需显示的对象</p></li><li><p>卸载引用文件</p></li><li><p>将对象更改为Bounding Box模式</p></li><li><p>关闭多个Maya，同时运行 Maya 和其他 3D 程序，需要额外的 GPU 内存。</p></li><li><p>可以考虑使用GPU缓存工作流程</p><p><img src="/2020/03/09/Maya%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/1558688555512.png" alt="图片3"></p><p>关于GPU缓存工作流程的更多内容：</p><p><a href="https://knowledge.autodesk.com/zh-hans/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/CHS/Maya-ManagingScenes/files/GUID-C893BE60-6E65-4F36-8005-FD4D1A0E9822-htm.html" target="_blank" rel="noopener">https://knowledge.autodesk.com/zh-hans/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/CHS/Maya-ManagingScenes/files/GUID-C893BE60-6E65-4F36-8005-FD4D1A0E9822-htm.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;针对美术制作的 Maya 卡顿优化&lt;/p&gt;
&lt;h2 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h2&gt;&lt;h3 id=&quot;信息获取&quot;&gt;&lt;a href=&quot;#信息获取&quot; class=&quot;headerlink&quot; title=&quot;信息获取&quot;&gt;&lt;/a&gt;信息获取&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;解释分析器&lt;/li&gt;
&lt;li&gt;求值工具包&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;GPU&quot;&gt;&lt;a href=&quot;#GPU&quot; class=&quot;headerlink&quot; title=&quot;GPU&quot;&gt;&lt;/a&gt;GPU&lt;/h2&gt;&lt;h3 id=&quot;信息获取-1&quot;&gt;&lt;a href=&quot;#信息获取-1&quot; class=&quot;headerlink&quot; title=&quot;信息获取&quot;&gt;&lt;/a&gt;信息获取&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Viewport 2.0,必须拥有正确的图形配置和图形驱动程序版本。有关 Maya 认证显卡和最新驱动程序版本的信息：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://knowledge.autodesk.com/certified-graphics-hardware&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://knowledge.autodesk.com/certified-graphics-hardware&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GPU 内存&lt;/p&gt;
&lt;p&gt;对于包含大量纹理、几何体或缓存动画的场景，请务必记下显卡上可用的 GPU RAM 量，如果 GPU RAM 使用量非常接近显卡的 GPU RAM 限制，纹理可能无法加载，并且场景可能显示为着色模式。此时将显示一条错误信息，指明已超出纹理 RAM 限制并建议您减小“最大纹理分辨率”(Max Texture Resolution)钳制。&lt;/p&gt;
&lt;p&gt;查看 GPU 内存使用情况（以 MB 为单位），请使用Mel命令 &lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Maya" scheme="http://yoursite.com/tags/Maya/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客如何插入图片</title>
    <link href="http://yoursite.com/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-09T14:47:30.000Z</published>
    <updated>2020-03-11T02:26:21.966Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>首先确认主页配置的_config.yml中：post_asset_folder:true.<br><img src="/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-07.png" alt="图片测试0"></p></li><li><p>在你的hexo目录下执行：<br><code>npm install hexo-asset-image --save</code><br>若出现错误则先执行：<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><a id="more"></a></li><li><p>等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。</p></li><li><p>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中。<br><img src="/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-25.png" alt="图片测试1"></p></li><li><p>在xxxx.md中按照markdown的格式引入图片.</p></li></ol><p>引用：<br><a href="https://www.jianshu.com/p/a2786cdb06e1" target="_blank" rel="noopener">系列4：总结别人hexo博客如何插图片方法（有自己实现的图片实例）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先确认主页配置的_config.yml中：post_asset_folder:true.&lt;br&gt;&lt;img src=&quot;/2020/03/09/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/Snipaste_2020-03-09_22-50-07.png&quot; alt=&quot;图片测试0&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在你的hexo目录下执行：&lt;br&gt;&lt;code&gt;npm install hexo-asset-image --save&lt;/code&gt;&lt;br&gt;若出现错误则先执行：&lt;br&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="http://yoursite.com/2019/12/03/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/03/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-03T03:32:35.000Z</published>
    <updated>2020-03-15T05:00:35.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h5 id="1-设置-Git-全局用户名和邮箱"><a href="#1-设置-Git-全局用户名和邮箱" class="headerlink" title="1. 设置 Git 全局用户名和邮箱"></a>1. 设置 Git 全局用户名和邮箱</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;gitaccount&quot; #设置用户名</span><br><span class="line">$ git config --global user.email &quot;gitaccount@example.com&quot; #设置用户名</span><br><span class="line">$ git config --global user.name #查看用户名</span><br><span class="line">$ git config --global user.email #查看邮箱</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-使用流程命令"><a href="#2-使用流程命令" class="headerlink" title="2. 使用流程命令"></a>2. 使用流程命令</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git init #初始化仓库</span><br><span class="line">$ git status # 查看git版本控制状态</span><br><span class="line">$ git add xxxxxx # 加入文件tracked</span><br><span class="line">$ git commit -m &quot;描述&quot; #提交文件到暂存区</span><br><span class="line">$ git log #查看日志</span><br><span class="line">$ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;sunyuxianggit&#x2F;sunyuxianggit.github.io.git #预提交到远端仓库（关联本地和远程仓库）</span><br><span class="line">$ git push -u origin master</span><br><span class="line">$ git reset --hard HEAD^^ #一个^就是前一个版本两个就是前两个版本</span><br></pre></td></tr></table></figure><h5 id="3-常见报错"><a href="#3-常见报错" class="headerlink" title="3. 常见报错"></a>3. 常见报错</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists.</span><br><span class="line">$ git remote rm origin #删除远程 URL</span><br><span class="line">ref:https:&#x2F;&#x2F;blog.csdn.net&#x2F;top_code&#x2F;article&#x2F;details&#x2F;50381432</span><br></pre></td></tr></table></figure><h5 id="4-速度问题"><a href="#4-速度问题" class="headerlink" title="4. 速度问题"></a>4. 速度问题</h5><ul><li><p>设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; </span><br><span class="line">git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy</span><br><span class="line">git config --global https.proxy</span><br></pre></td></tr></table></figure></li><li><p>取消设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;h5 id=&quot;1-设置-Git-全局用户名和邮箱&quot;&gt;&lt;a href=&quot;#1-设置-Git-全局用户名和邮箱&quot; class=&quot;headerlink&quot; title=&quot;1. 设置 Git 全局用户名和邮箱&quot;&gt;&lt;/a&gt;1. 设置 Git 全局用户名和邮箱&lt;/h5&gt;   &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name &amp;quot;gitaccount&amp;quot; #设置用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email &amp;quot;gitaccount@example.com&amp;quot; #设置用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name #查看用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email #查看邮箱&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Houdini 学习笔记</title>
    <link href="http://yoursite.com/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-11T03:31:04.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><p>我们可以看到，houdini是一个将各种独立的语境（context）融合在一起的操作系统。<br><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-04-14-02-15.png" alt></p><a id="more"></a><h2 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h2><h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><p><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-03-19-00-29.png" alt></p><ol><li>Detail 最高层级的数据，对应整个Object；</li><li>Primitive 几何对象中的组成部件，比如一个三角面片，一张NURBS曲面，或Volume；</li><li>Point 几何对象上面的一个点；</li><li>Vertex 一个Point可能同时存在于多个相邻的Primitive上，因此共享同一个Point的 多个primitive会各自存一份对Point的引用，称为Vertex。</li></ol><h3 id="属性优先级"><a href="#属性优先级" class="headerlink" title="属性优先级"></a>属性优先级</h3><p><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-04-16-03-43.png" alt></p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="属性-Attribute"><a href="#属性-Attribute" class="headerlink" title="属性 Attribute"></a>属性 Attribute</h3><p>最重要的数据类型就数属性了</p><h4 id="读取-修改属性"><a href="#读取-修改属性" class="headerlink" title="读取/修改属性"></a>读取/修改属性</h4><ul><li>使用已经定义的同层级属性的方式为：@变量名<ul><li>v@Cd 颜色属性</li><li>@P 位置属性</li><li>@ptnum 点ID</li><li>@primnum 图元ID</li></ul></li><li>不同层级之间的属性读取<ul><li>point(…)</li><li>prim(…)</li><li>detail(…)</li></ul></li></ul><h4 id="增加属性"><a href="#增加属性" class="headerlink" title="增加属性"></a>增加属性</h4><ul><li>数据类型 @变量名<ul><li>i@name（赋予整型）</li><li>i[]@name（赋予数组）</li></ul></li><li>在定义一个新的属性时，等号右边（即我们赋予该属性的初始值）必须是常量，也就是说只能是具体的数值， 不能包含任何函数或运算。<ul><li>对：float@mass=1；</li><li>错：float@mass =1/area;</li><li>错：vector @up = set(0,1,1);</li></ul></li></ul><h4 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h4><ul><li>属性在整个节点网络中，一旦你创建了，在人为手动删除它之前，就是一直存在并且全局都可见的（就是任何时候，只有你想要就可以读取）。因此属性是非常消耗空间和性能的，应当尽可能节约使用，如果预计将来再也不需要这个属性时，就应当使用Attribute Delete删除掉。</li><li><a href="https://link.zhihu.com/?target=https%3A//www.sidefx.com/docs/houdini/nodes/sop/attribdelete.html">Attribute Delete</a></li></ul><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><p> <img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/entagma_attributes.png" alt></p><h3 id="变量-Variable"><a href="#变量-Variable" class="headerlink" title="变量 Variable"></a>变量 Variable</h3><ul><li><p>一些VEX代码中的变量，如果它们只会在该节点的代码里面用到，那么就没有必要设置为属性了，我们称之为局部变量，就是它只属于所在的这个节点，节点算完之后就把它所占用的空间释放了，生不带来，死不带去。</p><p><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-02-26-17-23-21.png" alt></p></li><li><p>数组创建 float array_name[] </p></li><li><p>变量转向量 vector pos = set(x_var,y_var,z_var)</p></li></ul><h3 id="参数-Parameter"><a href="#参数-Parameter" class="headerlink" title="参数 Parameter"></a>参数 Parameter</h3><ul><li>参数一般出现在节点的paramter窗口，我们可以通过参数这些对节点进行调整。<br>参数非常重要，所以这里详细讲它的几种使用方式：<ul><li>在窗口上，对参数进行自动链接；<br>右键点击源参数，选择”Copy parameter”。<br>右击你要粘贴到的那个参数，选择”Paste relative reference”。</li><li>在窗口上，对参数进行手动链接；<br>此处使用的并不是VEX，而是HScript表达式，但是由于太重要了，就也写在这里：<br>在目标参数处输入函数ch(“源参数路径”)，源参数路径的格式有3种情况：<br><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-03-19-30-55.png" alt></li><li>在窗口上，手动创建参数；流程见下图，注意在”Parameter Description”一栏，我们新创建的变量有2个名称：Name和Label，Name是参数“真正”的名字，我们在使用ch(“参数名”)或者VEX内引用该参数时，都用的是Name，注意，Name不能包含空格；但是Label可以包含空格，作为参数在用户界面上显示的名称。<br><img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-03-19-31-43.png" alt></li><li>在Wrangle节点里，用VEX代码读取窗口上的参数；同上，使用chi, chf, chv, chs即可。</li></ul></li></ul><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li><p>printf 打印函数<br>  <code>printf(&quot;str&quot;);</code></p></li><li><p>addpoint 添加点函数</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addpoint</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="keyword">int</span> point_number)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addpoint</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">vector</span> pos)</span></span></span><br></pre></td></tr></table></figure></li><li><p>addprim 添加图元函数<br>  Adds a primitive to the geometry.</p><p>  <code>int  addprim(int geohandle, string type)</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addprim</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> type, <span class="keyword">int</span> pt0)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addprim</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> type, <span class="keyword">int</span> pt0, <span class="keyword">int</span> pt1)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addprim</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> type, <span class="keyword">int</span> pt0, <span class="keyword">int</span> pt1, <span class="keyword">int</span> pt2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">addprim</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> type, <span class="keyword">int</span> pt0, <span class="keyword">int</span> pt1, <span class="keyword">int</span> pt2, <span class="keyword">int</span> pt3)</span></span></span><br></pre></td></tr></table></figure></li><li><p>addvertex 添加顶点函数<br>  Adds a vertex to a primitive in a geometry.<br>  <code>int  addvertex(int geohandle, int prim_num, int point_num)</code></p></li><li><p>rand 随机函数<br>  Creates a random number between 0 and 1 from a seed.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">float  rand(float seed)</span><br><span class="line">vector2  rand(float seed)</span><br><span class="line">vector  rand(float seed)</span><br><span class="line">vector4  rand(float seed)</span><br><span class="line">float  rand(float seed, float seed2)</span><br><span class="line">vector2  rand(float seed, float seed2)</span><br><span class="line">vector  rand(float seed, float seed2)</span><br><span class="line">vector4  rand(float seed, float seed2)</span><br><span class="line">float  rand(vector2 seed)</span><br><span class="line">vector2  rand(vector2 seed)</span><br><span class="line">vector  rand(vector2 seed)</span><br><span class="line">vector4  rand(vector2 seed)</span><br><span class="line">float  rand(vector seed)</span><br><span class="line">vector2  rand(vector seed)</span><br><span class="line">vector  rand(vector seed)</span><br><span class="line">vector4  rand(vector seed)</span><br><span class="line">float  rand(vector4 seed)</span><br><span class="line">vector2  rand(vector4 seed)</span><br><span class="line">vector  rand(vector4 seed)</span><br><span class="line">vector4  rand(vector4 seed)</span><br></pre></td></tr></table></figure></li><li><p>fit 重映射函数<br>  Takes the value in one range and shifts it to the corresponding value in a new range.<br>  <code>float  fit(float value, float omin, float omax, float nmin, float nmax)</code></p></li><li><p>ch 滑块函数<br>  Evaluates a channel (or parameter) and return its value.<br>  <code>ch(&quot;string&quot;);</code></p></li><li><p>curlnoise 卷曲噪点函数<br>  Computes divergence free noise based on Perlin noise.<br>  <code>vector  curlnoise(vector xyz);</code><br>  <code>vector  curlnoise(vector4 xyzt)</code></p></li><li><p>push 数组添加元素函数<br>  Adds an item to an array.<br>  <code>void  push(&lt;type&gt;&amp;array[], &lt;type&gt;value)</code><br>  <code>void  push(&lt;type&gt;&amp;array[], &lt;type&gt;values[])</code></p></li><li><p>pop 数组弹出函数<br>  Removes the last element of an array and returns it. <code>&lt;type&gt; pop(&lt;type&gt;&amp;array[])</code><br>  <code>&lt;type&gt; pop(&lt;type&gt;&amp;array[], int index)</code></p></li><li><p>removeindex 数组删除元素函数<br>  Removes an item at the given index from an array.<br>  <code>&lt;type&gt; removeindex(&lt;type&gt;&amp;array[], int index)</code></p></li><li><p>nearpoint 查找最近顶点函数<br>  Finds the closest point in a geometry. </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">nearpoint</span><span class="params">(&lt;geometry&gt;geometry, <span class="built_in">vector</span> pt)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">nearpoint</span><span class="params">(&lt;geometry&gt;geometry, <span class="built_in">vector</span> pt, <span class="keyword">float</span> maxdist)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">nearpoint</span><span class="params">(&lt;geometry&gt;geometry, <span class="built_in">string</span> ptgroup, <span class="built_in">vector</span> pt)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">nearpoint</span><span class="params">(&lt;geometry&gt;geometry, <span class="built_in">string</span> ptgroup, <span class="built_in">vector</span> pt, <span class="keyword">float</span> maxdist)</span></span></span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">    </span><br><span class="line">* nearpoints 查找最近顶点函数 </span><br><span class="line">    Finds the closest point in a geometry. </span><br><span class="line">​&#96;&#96;&#96;c</span><br><span class="line">    int [] nearpoints(&lt;geometry&gt;geometry, vector pt, float maxdist)</span><br><span class="line">    </span><br><span class="line">    int [] nearpoints(&lt;geometry&gt;geometry, vector pt, float maxdist, int maxpts)</span><br><span class="line">    </span><br><span class="line">    int [] nearpoints(&lt;geometry&gt;geometry, string ptgroup, vector pt, float maxdist)</span><br><span class="line">    </span><br><span class="line">    int [] nearpoints(&lt;geometry&gt;geometry, string ptgroup, vector pt, float maxdist, int maxpts)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>point 从几何体上读取点的某个属性的值函数<br>  Reads a point attribute value from a geometry.<br>  <code>point(&lt;geometry&gt;geometry, string attribute_name, int pointnumber)</code></p></li><li><p>primpoints 从几何体上读取点函数<br>  Returns the list of points on a primitive.<br>  <code>int [] primpoints(&lt;geometry&gt;geometry, int primnum)</code></p></li><li><p>distance 距离函数<br>  Returns the distance between two points.<br>  <code>float  distance(vector2 a, vector2 b)</code></p></li><li><p>removepoint 删除点函数<br>  Removes a point from the geometry.<br>  <code>int  removepoint(int geohandle, int point_number)</code></p></li><li><p>primpoint 将图元/顶点转换为点的ID函数.<br>  Converts a primitive/vertex pair into a point number.<br>  <code>int primpoint(&lt;geometry&gt;, int primnum, int vertex)</code></p></li><li><p>itoa 整型转字符串函数<br>  Converts an integer to a string.<br>  <code>string  itoa(int number)</code></p></li><li><p>getbbox_max 计算几何的边界框的最小值函数<br>  Returns the maximum of the bounding box for the geometry..<br>  <code>vector  getbbox_max(geometry)</code></p></li><li><p>getbbox_max 计算几何的边界框的最大值函数<br>  Computes the minimum of the bounding box for the geometry.<br>  <code>vector  getbbox_max(&lt;geometry&gt;geometry, string primgroup)</code></p></li><li><p>getbbox_size 返回边界框的尺寸函数<br>  Returns the size of the bounding box for the geometry.<br>  <code>vector  getbbox_size(&lt;geometry&gt;geometry)</code><br>  <code>vector  getbbox_size(&lt;geometry&gt;geometry, string primgroup)</code></p></li><li><p>lerp 在值之间执行双线性插值函数</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Performs bilinear interpolation between the values.</span><br><span class="line"><span class="function"><span class="keyword">float</span>  <span class="title">lerp</span><span class="params">(<span class="keyword">float</span> value1, <span class="keyword">float</span> value2, <span class="keyword">float</span> amount)</span></span></span><br><span class="line">Performs bilinear interpolation between corresponding components.</span><br><span class="line">&lt;<span class="built_in">vector</span>&gt; lerp(&lt;<span class="built_in">vector</span>&gt;value1, &lt;<span class="built_in">vector</span>&gt;value2, <span class="keyword">float</span> amount)</span><br></pre></td></tr></table></figure></li><li><p>removeprim 删除图元函数<br>  Removes a primitive from the geometry.<br>  <code>int  removeprim(int geohandle, int prim_number, int andpoints)</code></p></li><li><p>pow 冪函數<br>  Raises the first argument to the power of the second argument.</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span>  <span class="title">pow</span><span class="params">(<span class="keyword">float</span> n, <span class="keyword">float</span> exponent)</span></span></span><br><span class="line">&lt;vector&gt; pow(&lt;vector&gt;v, float exponent)</span><br></pre></td></tr></table></figure></li><li><p>setpointattrib设置顶点属性函数<br>  Sets a point attribute in a geometry.</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">setpointattrib</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> name, <span class="keyword">int</span> point_num, &lt;type&gt;value, <span class="built_in">string</span> mode=<span class="string">"set"</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">setpointattrib</span><span class="params">(<span class="keyword">int</span> geohandle, <span class="built_in">string</span> name, <span class="keyword">int</span> point_num, &lt;type&gt;value[], <span class="built_in">string</span> mode=<span class="string">"set"</span>)</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>npoints 得到几何体的点数函数<br>  Returns the number of points in the input or geometry file.<br>  <code>int  npoints(&lt;geometry&gt;geometry)</code></p></li><li><p>resize 设置数组长度函数<br>  Sets the length of an array.<br>  <code>void  resize(&lt;type&gt;&amp;array[], int size)</code></p></li><li><p>argsort 数组排序函数<br>  Returns the indices of a sorted version of an array.<br>  <code>int [] argsort(&lt;type&gt;value[])</code></p></li><li><p>setpointgroup 添加点组函数<br>  Adds or removes a point to/from a group in a geometry.<br>  <code>int  setpointgroup(int geohandle, string name, int point_num, int value, string mode=&quot;set&quot;)</code><br>  geohandle</p><p>  A handle to the geometry to write to. Currently the only valid value is 0 or geoself, which means the current geometry in a node. (This argument may be used in the future to allow writing to other geometries.)</p><p>  name</p><p>  The name of the group to modify.</p><p>  point_num</p><p>  The point number to add or remove from the group.</p><p>  value</p><p>  1 to put the point in the group, 0 to remove the point from the group. This is ignored if mode is “toggle”.</p><p>  mode</p><p>  Use “set” to set the point’s membership according to the value. Use “toggle” to toggle the point’s membership, regardless of the value.</p></li><li><p>pointprims 返回一个图元包含的点函数<br>  pointprims<br>  Returns the list of primitives containing a point.<br>  <code>int [] pointprims(&lt;geometry&gt;geometry, int ptnum)</code></p></li></ul><ul><li>intersect 计算射线与几何的交叉函数<br>  This function computes the first intersection of a ray with geometry.</li></ul><ul><li><p>detail 从几何读取详细信息属性值的函数</p><p>  Reads the value of a detail attribute value from a geometry.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type&gt; detail(&lt;geometry&gt;geometry, string attribute_name, int ignored&#x3D;0)</span><br><span class="line"></span><br><span class="line">&lt;type&gt;[] detail(&lt;geometry&gt;geometry, string attribute_name, int ignored&#x3D;0)</span><br></pre></td></tr></table></figure></li><li><p>radians 弧度函数<br>  Converts the argument from degrees into radians.<br>  从度数转弧度<br>  <code>float  radians(float num_in_degs)</code></p></li><li><p>rotate  旋转函数<br>  Applies a rotation to the given matrix.</p>  <figure class="highlight plain"><figcaption><span>rotate(matrix2 &m, float amount)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void  rotate(matrix3 &amp;m, float amount, vector axis)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix &amp;m, float amount, vector axis)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix3 &amp;m, vector angles, int xyz)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix &amp;m, vector angles, int xyz)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix3 &amp;m, float angle, int axis)</span><br><span class="line"></span><br><span class="line">void  rotate(matrix &amp;m, float angle, int axis)</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* scale 缩放函数</span><br><span class="line">    Scales the given matrix in three directions simultaneously (X, Y, Z - given by the components of the scale_vector)</span><br></pre></td></tr></table></figure><p>  void  scale(matrix2 &amp;m, vector2 scale_vector)</p><p>  void  scale(matrix &amp;m, vector scale_vector)</p><p>  void  scale(matrix3 &amp;m, vector scale_vector)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* translate 位移函数</span><br><span class="line">    Translates a matrix by a vector.</span><br></pre></td></tr></table></figure><p>  void  translate(matrix &amp;m, vector amount)</p><p>  void  translate(matrix &amp;m, vector4 amount)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* quaternion  四元数函数</span><br><span class="line">    Creates a vector4 representing a quaternion.</span><br><span class="line">    创建一个表示四元数的vector4</span><br></pre></td></tr></table></figure><p>  vector4  quaternion(matrix3 rotations)</p><p>  Creates a vector4 representing a quaternion from a 3×3 rotational matrix.</p><p>  vector4  quaternion(float angle, vector axis)</p><p>  Creates a vector4 representing a quaternion from an angle and axis. The angle is specified in radians.</p><p>  vector4  quaternion(vector angleaxis)</p><p>  Creates a vector4 representing a quaternion from a combined angle/axis. This is the normalized rotation axis multiplied by the rotation angle in radians.</p><p>  There used to be a fourth form that took a rotation vector. It has been renamed to eulertoquaternion and now takes radians.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* qrotate 四元数旋转函数</span><br><span class="line"></span><br><span class="line">    Rotates a vector by a quaternion.</span><br><span class="line">    通过四元数旋转向量。</span><br><span class="line">    &#96;vector  qrotate(vector4 quaternion, vector v)&#96;</span><br><span class="line"></span><br><span class="line">* slerp 四元数基于偏差的融和函数</span><br><span class="line"></span><br><span class="line">    Quaternion blend between q1 and q2 based on the bias.</span><br><span class="line">    &#96;vector4  slerp(vector4 q1, vector4 q2, float bias)&#96;</span><br><span class="line"></span><br><span class="line">* primintrinsic  从几何读取基本图元函数</span><br><span class="line"></span><br><span class="line">    Reads a primitive intrinsic from a geometry.</span><br><span class="line">    从几何读取基本图元</span><br></pre></td></tr></table></figure><p>  <type> primintrinsic(<geometry>geometry, string intrinsic_name, int prim_num)</geometry></type></p><p>  <type>[] primintrinsic(<geometry>geometry, string intrinsic_name, int prim_num)</geometry></type></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 常用表达式</span><br><span class="line">* $FF 帧变量</span><br><span class="line"></span><br><span class="line">## 节点</span><br><span class="line"></span><br><span class="line">* scatter</span><br><span class="line">撒点 散布节点</span><br><span class="line"></span><br><span class="line">* isooffset</span><br><span class="line">配合散布节点使用 可以散布到物体内部并且在位置上有一定随机</span><br><span class="line"></span><br><span class="line">* attribute randomize</span><br><span class="line">随机某个属性</span><br><span class="line"></span><br><span class="line">* attribute paint</span><br><span class="line">绘制变量属性,结合scatter可以实现局部撒点</span><br><span class="line"></span><br><span class="line">* relax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 快捷键</span><br><span class="line">* 弹出代码框 ALT+E</span><br><span class="line">* 弹出当前选中的功能区 ALT + SHIFT+ C</span><br><span class="line">* 调整焦点 选中相机视口 回车（Show handle）+ Z</span><br><span class="line"></span><br><span class="line">## vex语法</span><br><span class="line"></span><br><span class="line">* for 循环</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;c</span><br><span class="line">    for(int i &#x3D; 0 ; i&gt;num;i++)&#123;</span><br><span class="line">        something;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>foreach循环</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach(<span class="keyword">int</span> npt;npts)&#123;</span><br><span class="line">    something;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>条件判断</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if()&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if()&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br><span class="line">else if()&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="外部函数导入和外部编辑器设置"><a href="#外部函数导入和外部编辑器设置" class="headerlink" title="外部函数导入和外部编辑器设置"></a>外部函数导入和外部编辑器设置</h2><ul><li>外部编辑器设置<ol><li>找到 C:\Users\username\Documents\houdini18.0 下找到** houdini.env **</li><li>加入这一行代码  注意路径和路径反斜线写法<br><code>Editor = &quot;C:/Users/username/AppData/Local/Programs/Microsoft VS Code/Code.exe&quot;</code></li><li>然后重启houdini</li></ol></li><li>外部函数导入<ol><li>找到 C:\Users\username\Documents\houdini18.0 下找到** houdini.env **</li><li>加入这一行代码  注意路径反斜线写法和结尾字符<br><code>HOUDINI_VEX_PATH = &quot;C:/Users/sunyuxiang/Documents/houdini18.0/Custom_VEX;&amp;&quot;</code></li><li>然后把函数放到这里即可C:\Users\sunyuxiang\Documents\houdini18.0\Custom_VEX</li><li>然后重启houdini</li><li>调用方法 #include “你的函数文件夹名”</li></ol></li><li>打开代码窗口<ol><li>Alt+E</li></ol></li></ul><h2 id="每节例子总结"><a href="#每节例子总结" class="headerlink" title="每节例子总结"></a>每节例子总结</h2><ul><li><p>给顶点的法线信息指认随机生成的向量，通过滑块调整随机种子</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> seed = chf(<span class="string">"seed"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set random scale (0 ... 0.1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> pscale = rand(@ptnum+seed);<span class="comment">//定义一个 浮点变量</span></span><br><span class="line">pscale *= <span class="number">.1</span>; <span class="comment">//浮点变量缩小十分之1</span></span><br><span class="line">f@pscale = pscale; <span class="comment">//设置属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set random orientation using N(&#123;-1,-1,-1&#125; ... &#123;1,1,1&#125;)</span></span><br><span class="line"><span class="built_in">vector</span> randdir = rand(@ptnum+seed);</span><br><span class="line"></span><br><span class="line"><span class="comment">//randdir = fit(randdir,&#123;0,0,0&#125;,&#123;1,1,1&#125;,&#123;-1,-1,-1&#125;,&#123;1,1,1&#125;);</span></span><br><span class="line"><span class="comment">// 因为@ptnum是正轴递增，所以random的结果太相似 所以重新映射一下</span></span><br><span class="line">randdir = fit01(randdir,&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">//给顶点的法线信息指认随机生成的向量</span></span><br><span class="line">v@N = randdir;</span><br></pre></td></tr></table></figure></li><li><p>所有点的向量实时指向某个点<br>  为了得到指向某个点的向量，我们需要用目标点减去基点如图：<br>  <img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-02-18-20-23-42.png" alt></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//拿到接口1的 第0个顶点的属性名"P"的值</span></span><br><span class="line"><span class="built_in">vector</span> tgtpos = <span class="built_in">point</span>(<span class="number">1</span>,<span class="string">"P"</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 目标点减去 模板点 得到向量</span></span><br><span class="line"><span class="built_in">vector</span> dir = tgtpos - v@P;</span><br><span class="line"><span class="comment">//归一化向量</span></span><br><span class="line"><span class="comment">//v@N =dir;</span></span><br><span class="line">v@N =normalize(dir);</span><br></pre></td></tr></table></figure></li><li><p>使用卷积化随机函数创建向量赋予点</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> f = chv(<span class="string">"Frequency"</span>);</span><br><span class="line"><span class="built_in">vector</span> o = chv(<span class="string">"offset"</span>);</span><br><span class="line"><span class="comment">//这里是卷积化随机向量</span></span><br><span class="line"><span class="built_in">vector</span> dir = curlnoise((v@P * f)+ o);</span><br><span class="line"><span class="comment">//归一化向量</span></span><br><span class="line">v@N =normalize(dir);</span><br></pre></td></tr></table></figure></li></ul><ul><li>使用nearpoints函数查找最近的点并创建线  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">float</span> maxdist = chf(<span class="string">"max_Dist"</span>);</span><br><span class="line"><span class="keyword">float</span> mindist = chf(<span class="string">"Min_Dist"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到函数</span></span><br><span class="line"><span class="keyword">int</span> npts[] = nearpoints(<span class="number">0</span>,v@P,maxdist);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除找到的自己</span></span><br><span class="line">removeindex(npts,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋予属性给点</span></span><br><span class="line">i[]@npts = npts;</span><br><span class="line"></span><br><span class="line">foreach(<span class="keyword">int</span> npt;npts)&#123;</span><br><span class="line">    <span class="built_in">vector</span> npos = <span class="built_in">point</span>(<span class="number">0</span>,<span class="string">"p"</span>,npt);</span><br><span class="line">    <span class="keyword">float</span> dist = distance(v@P,npos);</span><br><span class="line">    <span class="keyword">if</span>(dist &gt; mindist)&#123;</span><br><span class="line">        addprim(<span class="number">0</span>,<span class="string">"polyline"</span>,@ptnum,npt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="理解矩阵很好的教程"><a href="#理解矩阵很好的教程" class="headerlink" title="理解矩阵很好的教程"></a>理解矩阵很好的教程</h2><p> <img src="/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/entagma_martrix.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;软件结构&quot;&gt;&lt;a href=&quot;#软件结构&quot; class=&quot;headerlink&quot; title=&quot;软件结构&quot;&gt;&lt;/a&gt;软件结构&lt;/h2&gt;&lt;p&gt;我们可以看到，houdini是一个将各种独立的语境（context）融合在一起的操作系统。&lt;br&gt;&lt;img src=&quot;/2019/12/01/Houdini_Entagma_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020-03-04-14-02-15.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Houdini" scheme="http://yoursite.com/tags/Houdini/"/>
    
  </entry>
  
  <entry>
    <title>Python文件打包成可执行文件</title>
    <link href="http://yoursite.com/2019/12/01/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/12/01/Python%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-13T13:52:02.560Z</updated>
    
    <content type="html"><![CDATA[<p>Python是一个脚本语言，被解释器解释执行。它的发布方式：</p><h2 id="py-文件"><a href="#py-文件" class="headerlink" title=".py 文件"></a>.py 文件</h2><p>没什么好讲的，开源项目或者个人练习，直接提供源码最简单粗暴，需要使用者自行安装Python并且安装依赖的各种库。</p><h2 id="pyc-文件"><a href="#pyc-文件" class="headerlink" title=".pyc 文件"></a>.pyc 文件</h2><p>如果觉得源码写的差劲不好意思被别人看到，或者出于保密等不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#代码</span><br><span class="line">import py_compile</span><br><span class="line">py_compile.compile(&quot;D:\Python\main.py&quot;)            # 相对路径或绝对路径</span><br><span class="line"></span><br><span class="line">#命令行下</span><br><span class="line">python -m py_compile test.py</span><br><span class="line">#会在相同路径里面创建__pycache__文件夹，编译过的pyc文件就在里面</span><br><span class="line"></span><br><span class="line">#多个文件</span><br><span class="line">import compileall</span><br><span class="line">compileall.compile_dir(&quot;存放海量py的目录&quot;)</span><br></pre></td></tr></table></figure><h2 id="可执行exe文件"><a href="#可执行exe文件" class="headerlink" title="可执行exe文件"></a>可执行exe文件</h2><ul><li><p>pyInstaller</p><pre><code>1.安装pyInstaller</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pyinstaller #安装</span><br><span class="line">$ pyinstaller --version #查看版本</span><br></pre></td></tr></table></figure><p>  2.如果查看版本报错</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;pyinstall&#39; is not recognized as an internal or external command,operable program or batch file.#需要系统变量里的Path变量下添加其所在目录，然后重启命令行即可.</span><br></pre></td></tr></table></figure><p>  3.使用pyInstaller：</p><figure class="highlight plain"><figcaption><span>-F helloworld.py```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">- py2exe</span><br><span class="line"></span><br><span class="line">1. 命令行&#96;&#96;pip install py2exe&#96;&#96;安装</span><br><span class="line"></span><br><span class="line">1. 在命令行内测试你的程序确定可以运行</span><br><span class="line"></span><br><span class="line">   &#96;&#96;python helloworld.py&#96;&#96;</span><br><span class="line"></span><br><span class="line">2. 创建你自己的执行脚本 (setup.py)</span><br></pre></td></tr></table></figure><pre><code>from distutils.core import setupimport py2exe</code></pre></li></ul><pre><code>   setup(console=[&quot;helloworld.py&quot;]) #这里helloworld.py替换成你的脚本   ``` 3. 在命令行Run your setup script    ``python setup.py py2exe`` 4. 然后再dist文件夹下就会看到生成的.exe 文件了5. 如果出现``IndexError: tuple index out of range``的话是因为py2exe停止支持3.4以上版本，可以换用这个地方的py2exe, 但是好像也是有问题   ref：https://stackoverflow.com/questions/41578808/python-indexerror-tuple-index-out-of-range-when-using-py2exe   ref：https://github.com/albertosottile/py2exe</code></pre><ul><li><p>cx_Freeze</p><ol><li><p><code>$ pip install cx_Freeze</code>安装</p></li><li><p><code>$ cxfreeze hello.py --target-dir dist</code>生成执行文件，如果报错无法识别就参考这个解决</p><p>ref:<a href="https://stackoverflow.com/questions/25242860/cxfreeze-command-not-found-in-windows/25243419#25243419" target="_blank" rel="noopener">https://stackoverflow.com/questions/25242860/cxfreeze-command-not-found-in-windows/25243419#25243419</a> </p></li></ol></li><li><p>auto-py-to-exe 2.6.6</p><ol><li><code>$ pip install auto-py-to-exe</code> 安装</li><li>````$ auto-py-to-exe`` 使用</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python是一个脚本语言，被解释器解释执行。它的发布方式：&lt;/p&gt;
&lt;h2 id=&quot;py-文件&quot;&gt;&lt;a href=&quot;#py-文件&quot; class=&quot;headerlink&quot; title=&quot;.py 文件&quot;&gt;&lt;/a&gt;.py 文件&lt;/h2&gt;&lt;p&gt;没什么好讲的，开源项目或者个人练习，直接提供源码最简单粗暴，需要使用者自行安装Python并且安装依赖的各种库。&lt;/p&gt;
&lt;h2 id=&quot;pyc-文件&quot;&gt;&lt;a href=&quot;#pyc-文件&quot; class=&quot;headerlink&quot; title=&quot;.pyc 文件&quot;&gt;&lt;/a&gt;.pyc 文件&lt;/h2&gt;&lt;p&gt;如果觉得源码写的差劲不好意思被别人看到，或者出于保密等不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 进程和线程学习笔记</title>
    <link href="http://yoursite.com/2019/12/01/Python%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/01/Python%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-11T02:24:32.260Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="进程和线程概述"><a href="#进程和线程概述" class="headerlink" title="进程和线程概述"></a>进程和线程概述</h3><p>进程：对于操作系统来说，一个任务就是一个进程（Process）</p><p>线程：在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p></li><li><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multprocessing # Python 中的 multiprocess 包提供了多进程支持</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#process multprocessing包中的一个类表示进程对象</span><br><span class="line"></span><br><span class="line">from multiprocessing import Process</span><br><span class="line">from tqdm import tqdm</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid())) #getpid()可以拿到进程的ID。</span><br><span class="line">    for i in tqdm(range(10000000)):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;: </span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">有化部分 ，这句代码以上的部分，可以被其它的调用，以下的部分只有这个文件自己可以看见，如果文件被调用了，其他人是无法看见私有化部分的</span><br><span class="line">也就是说你自己运行该模块的时候 这句话是执行的 因为自己运行时__name__就是__main__，而当别人调用你这个模块时，以下代码会被忽略，此时的__name__是模块名</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    print(&#39;Parent process %s.&#39; % os.getpid())</span><br><span class="line">    p &#x3D; Process(target&#x3D;run_proc, args&#x3D;(&#39;test1&#39;,))</span><br><span class="line">    d &#x3D; Process(target&#x3D;run_proc, args&#x3D;(&#39;test2&#39;,))</span><br><span class="line">    print(&#39;Child process will start.&#39;)</span><br><span class="line">    p.start()#调用进程</span><br><span class="line">    d.start()#调用进程</span><br><span class="line">    p.join()#join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步</span><br><span class="line">    d.join()</span><br><span class="line">    print(&#39;Child process end.&#39;)</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#Pool multprocessing包中的一个类，如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</span><br><span class="line"></span><br><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def long_time_task(name):</span><br><span class="line">    # for i in tqdm(range(10000000)):</span><br><span class="line">    #     pass</span><br><span class="line">    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end &#x3D; time.time()</span><br><span class="line">    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    print(&#39;Parent process %s.&#39; % os.getpid())</span><br><span class="line">    p &#x3D; Pool(4)</span><br><span class="line">    #创建子进程池</span><br><span class="line">    #参数数决定同时运行多少进程 如果是4 task4会等待 0 1 2 3 运行完在运行，如果是5 就0 1 2 3 4 一起运行</span><br><span class="line">    #如果你的参数大于你的CPU线程数还是要等待</span><br><span class="line">    #把参数去掉，就是按照操作系统的核数来</span><br><span class="line">    </span><br><span class="line">    for i in range(13):</span><br><span class="line">        p.apply_async(long_time_task, args&#x3D;(i,)) #注意这里，因为是类所有调用函数是 P.</span><br><span class="line">    print(&#39;Waiting for all subprocesses done...&#39;)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&#39;All subprocesses done.&#39;)</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#这种方法可以实现任意进程间的通信，这里写的是主、子进程间的通信</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def foo(aa):#必须要接收一个元祖</span><br><span class="line">    message &#x3D; aa.get()  # 管子的另一端放在子进程这里，子进程接收到了数据</span><br><span class="line">    print(&#39;子进程已收到数据...&#39;)</span><br><span class="line">    print(message)  # 子进程打印出了数据内容...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;: </span><br><span class="line"></span><br><span class="line">    xt &#x3D; multiprocessing.Queue()  # 创建进程通信的Queue，你可以理解为我拿了个管子来...</span><br><span class="line">    jc &#x3D; multiprocessing.Process(target&#x3D;foo, args&#x3D;(xt,))  # multiprocessing.Process创建子进程</span><br><span class="line">    jc.start()  # 启动子进程</span><br><span class="line">    print(&#39;主进程准备发送数据...&#39;)</span><br><span class="line">    xt.put(&#39;有内鬼，终止交易！&#39;)  # 将管子的一端放在主进程这里，主进程往管子里丢入数据</span><br><span class="line">    jc.join()</span><br></pre></td></tr></table></figure><ul><li><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：</span><br><span class="line">import time, threading</span><br><span class="line"># 新线程执行的代码:</span><br><span class="line">def loop():</span><br><span class="line">    print(&#39;thread %s is running...&#39; % threading.current_thread().name)</span><br><span class="line">    n &#x3D; 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&#39;thread %s ended.&#39; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(&#39;thread %s is running...&#39; % threading.current_thread().name)</span><br><span class="line">t &#x3D; threading.Thread(target&#x3D;loop, name&#x3D;&#39;LoopThread&#39;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(&#39;thread %s ended.&#39; % threading.current_thread().name)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;进程和线程概述&quot;&gt;&lt;a href=&quot;#进程和线程概述&quot; class=&quot;headerlink&quot; title=&quot;进程和线程概述&quot;&gt;&lt;/a&gt;进程和线程概述&lt;/h3&gt;&lt;p&gt;进程：对于操作系统来说，一个任务就是一个进程（Process）&lt;/p&gt;
&lt;p&gt;线程：在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;multprocessing # Python 中的 multiprocess 包提供了多进程支持&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Top 10 ways to make Maya go FASTER</title>
    <link href="http://yoursite.com/2019/12/01/Top%2010%20ways%20to%20make%20Maya%20go%20FASTER/"/>
    <id>http://yoursite.com/2019/12/01/Top%2010%20ways%20to%20make%20Maya%20go%20FASTER/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-14T08:15:18.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1关闭一些显示设置："><a href="#1关闭一些显示设置：" class="headerlink" title="1关闭一些显示设置："></a>1关闭一些显示设置：</h2><p>首先是阴影，然后OCC，然后运动模糊然后抗锯齿</p><h2 id="2关闭材质球实时预览"><a href="#2关闭材质球实时预览" class="headerlink" title="2关闭材质球实时预览"></a>2关闭材质球实时预览</h2><p>可以改用右键单个refresh swatch</p><h2 id="3选择暂停viewport"><a href="#3选择暂停viewport" class="headerlink" title="3选择暂停viewport"></a>3选择暂停viewport</h2><a id="more"></a><h2 id="4确保不实用的插件不加载"><a href="#4确保不实用的插件不加载" class="headerlink" title="4确保不实用的插件不加载"></a>4确保不实用的插件不加载</h2><p>还可以导入的时候不自动载入ref，选择手动载入</p><h2 id="5关闭模型的Adaptive-open-Subdiv"><a href="#5关闭模型的Adaptive-open-Subdiv" class="headerlink" title="5关闭模型的Adaptive open Subdiv"></a>5关闭模型的Adaptive open Subdiv</h2><h2 id="6设置Viewport2-0"><a href="#6设置Viewport2-0" class="headerlink" title="6设置Viewport2.0"></a>6设置Viewport2.0</h2><p>1浮点渲染目标，此设置与色彩管理有关系，代价是CPU的RAM</p><p>推荐，R32G32B32A32_Float &gt; R16G16B16A16_Float</p><p>也可以完全禁用</p><p>2性能下把透明贴图算法改成 Alpha Cut</p><p>代价是牺牲了半透明的效果，但是提高了速度</p><h2 id="7使用贴图时，最轻量的贴图是JPEG"><a href="#7使用贴图时，最轻量的贴图是JPEG" class="headerlink" title="7使用贴图时，最轻量的贴图是JPEG"></a>7使用贴图时，最轻量的贴图是JPEG</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1关闭一些显示设置：&quot;&gt;&lt;a href=&quot;#1关闭一些显示设置：&quot; class=&quot;headerlink&quot; title=&quot;1关闭一些显示设置：&quot;&gt;&lt;/a&gt;1关闭一些显示设置：&lt;/h2&gt;&lt;p&gt;首先是阴影，然后OCC，然后运动模糊然后抗锯齿&lt;/p&gt;
&lt;h2 id=&quot;2关闭材质球实时预览&quot;&gt;&lt;a href=&quot;#2关闭材质球实时预览&quot; class=&quot;headerlink&quot; title=&quot;2关闭材质球实时预览&quot;&gt;&lt;/a&gt;2关闭材质球实时预览&lt;/h2&gt;&lt;p&gt;可以改用右键单个refresh swatch&lt;/p&gt;
&lt;h2 id=&quot;3选择暂停viewport&quot;&gt;&lt;a href=&quot;#3选择暂停viewport&quot; class=&quot;headerlink&quot; title=&quot;3选择暂停viewport&quot;&gt;&lt;/a&gt;3选择暂停viewport&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="maya" scheme="http://yoursite.com/tags/maya/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo创建个人blog网页的笔记</title>
    <link href="http://yoursite.com/2019/12/01/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E7%BD%91%E9%A1%B5%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/01/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%E7%BD%91%E9%A1%B5%E7%9A%84%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-01T14:53:13.000Z</published>
    <updated>2020-03-15T04:53:14.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装支持软件"><a href="#安装支持软件" class="headerlink" title="安装支持软件"></a>安装支持软件</h2><ol><li><p>下载并安装node.js.<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p></li><li><p>下载好可以在cmd里面通过查看版本号来确认安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v #参看node版本号</span><br><span class="line">$ npm -v # 查看npm包管理器版本号</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>由于npm国内下载包速度太慢，所以可以里面npm安装一个cnpm（使用淘宝源）加快速度，不需要可以跳过，同理可以通过查看版本号确认安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry&#x3D;&quot;https:&#x2F;&#x2F;registry.npm.taobao.org&quot; #-g表示全局安装</span><br><span class="line">$ cnpm -v#参看cnpm 版本号</span><br></pre></td></tr></table></figure></li><li><p>使用cnpm 安装hexo，同理可以通过查看版本号确认安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g hexo-cli #全局安装hexo</span><br><span class="line">$ hexo -v #参看hexo版本号</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用hexo搭建博客"><a href="#使用hexo搭建博客" class="headerlink" title="使用hexo搭建博客"></a>使用hexo搭建博客</h2><ol><li><p>首先建立一个空的文件夹blog</p></li><li><p>命令行进入blog文件夹</p></li><li><p>使用hexo生成博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init #生成博客</span><br></pre></td></tr></table></figure></li><li><p>使用hexo server进行本地预览博客，预览完成后Ctrl+C退出预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s#本地预览博客</span><br></pre></td></tr></table></figure></li><li><p>使用hexo new 新建文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n &quot;文章名&quot;</span><br></pre></td></tr></table></figure></li><li><p>先使用hexo clean 清除已经创建的页面，在使用hexo generated生成页面，建议生成先进行本地预览。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean #清除</span><br><span class="line">$ hexo g #生成</span><br></pre></td></tr></table></figure></li></ol><h2 id="如何把博客布置到github上"><a href="#如何把博客布置到github上" class="headerlink" title="如何把博客布置到github上"></a>如何把博客布置到github上</h2><ol><li><p>首先在github自己的账号内新建仓库，注意仓库名就是你的域名。仓库名必须是 [账户名.github.io]</p></li><li><p>安装git并在git下设置用户名和邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name [username]</span><br><span class="line">git config --global user.email [email]</span><br></pre></td></tr></table></figure></li><li><p>在bolg文件夹下安装git部署插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>设置一下bolg文件夹的_config.yml，注意每个冒号后面有空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git </span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;sunyuxianggit&#x2F;sunyuxianggit.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>部署到github，中间需要输入github的账号密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo doploy#部署到GitHub</span><br></pre></td></tr></table></figure></li><li><p>常见错误：</p><ul><li><p>fatal: in unpopulated submodule ‘.deploy_git’</p><p> 这种情况可以先安装下相关的依赖：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git –save</span><br><span class="line">$ rm -rf .deploy_git#删掉</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d#重新生成和部署</span><br></pre></td></tr></table></figure></li><li><p>执行hexo inint 命令报错hexo:无法加载文件…..\npm\hexo.psl，因为在此系统中禁止运行脚本<br><a href="https://blog.csdn.net/JONE_WUQINGJIANG/article/details/103044919" target="_blank" rel="noopener">https://blog.csdn.net/JONE_WUQINGJIANG/article/details/103044919</a></p></li><li><p>安装hexo后，初始化博客，出现bash: hexo: command not found<br>找到C:\Users\Administrator\AppData\Roaming\npm\node_modules\hexo\bin\，将此目录新增到path环境变量中(注：Administrator改成你自己的账户名)</p></li><li><p>重新安装hexo <code>npm install -g hexo-cli</code>如果出现如下错误<br><a href="https://blog.csdn.net/liting1996/article/details/79612248" target="_blank" rel="noopener">https://blog.csdn.net/liting1996/article/details/79612248</a></p></li><li><p>重新安装npm <code>npm install -g npm</code></p></li></ul></li></ol><h2 id="日常更新文章"><a href="#日常更新文章" class="headerlink" title="日常更新文章"></a>日常更新文章</h2><ol><li>命令行进入blog文件夹使用<code>$ hexo new</code> 新建文章</li><li>使用<code>$ hexo clean</code>清除老页面，然后在使用<code>$ hexo generated</code>生成页面</li><li>使用<code>$ hexo server</code>本地预览没有问题后，使用 <code>$ hexo deploy</code>部署到Github</li></ol><h2 id="如何更换主题"><a href="#如何更换主题" class="headerlink" title="如何更换主题"></a>如何更换主题</h2><ol><li><p>命令行进入blog</p></li><li><p>使用git clone 功能 clone喜欢的主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;Molunerfinn&#x2F;hexo-theme-melody.git</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: yilia#这里</span><br></pre></td></tr></table></figure></li></ol><h2 id="多台设备同步管理"><a href="#多台设备同步管理" class="headerlink" title="多台设备同步管理"></a>多台设备同步管理</h2><ol><li>原创建博客设备把源文件上传到GitHub，上传时注意检查所有.gitignore文件忽略情况和把node_modules文件夹删掉（因为内部文件名太长，上传的话git报错）.</li><li>另一台电脑上将源代码clone下来之后，直接执行 <code>cnpm install</code>把node_modules安装回来.</li><li>然后<code>hexo s</code>正常使用.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装支持软件&quot;&gt;&lt;a href=&quot;#安装支持软件&quot; class=&quot;headerlink&quot; title=&quot;安装支持软件&quot;&gt;&lt;/a&gt;安装支持软件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载并安装node.js.&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载好可以在cmd里面通过查看版本号来确认安装成功。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ node -v #参看node版本号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm -v # 查看npm包管理器版本号&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>

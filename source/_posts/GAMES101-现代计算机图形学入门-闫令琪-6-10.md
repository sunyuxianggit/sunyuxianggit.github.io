---
title: GAMES101-现代计算机图形学入门-闫令琪(6-10)
date: 2020-03-24 19:34:27
tags: computer graphics
---

## 第六节
##### 上节课复习
![](2020-03-25-10-26-53.png)
MVP（model模型变换- view跟随摄影机变换到相对（0，0，0）位置 - project 投影变换（-1，1的3次方的空间））变换之后在进行视口变换（viewport，-1，1的3次方的空间变换到分辨率空间)
##### Antialiasing 抗锯齿
根据上节课的判断，我们可以得到某些像素带你的中心在三角形内部，某些不在，如图：
![](2020-03-27-11-05-28.png)
我们想得到的是这样的三角形：
![](2020-03-27-11-05-50.png)
结果把对应的像素填充完得到这样的三角形：
![](2020-03-27-11-05-36.png)
Aliasing 走样/锯齿
![](2020-03-27-11-08-05.png)
我们要想抗锯齿首先要明白锯齿是怎么来的。
![](2020-03-27-11-09-57.png)
采样是图形学中广泛存在的做法，光栅化的过程，其实就是在屏幕空间用一系列离散的点（也就是像素的中心）进行是否在三角形内这么一个函数的采样。
![](2020-03-27-11-14-26.png)
照片也是采样：一副照片，就是说所有到达这个感光元件的所在平面的光学信息，我们把它们离散成一系列图片上的像素的过程。

![](2020-03-27-11-21-37.png)
采样不光可以发生在不同的未知，也可以发生在不同的时间。
视频就是在时间上的采样。
![](2020-03-27-11-23-38.png)
采样是广泛存在的，采样的问题也是广泛存在的。
Artifacts(瑕疵)
![](2020-03-27-11-27-36.png)
采样的问题：
1. 锯齿
2. 摩尔纹（把采样的过程的奇数行和奇数列去掉在对起来就会产生这样的问题）
3. 顺时针变成逆时针(采样速度太慢)
信号变化太快，导致采样速度跟不上。


![](2020-03-27-11-35-31.png)
如何做抗锯齿，在采样之前先做个模糊或者滤波。
![](2020-03-27-11-36-16.png)
![](2020-03-27-11-40-29.png)
这样操作完之后效果还不错：
![](2020-03-27-14-39-16.png)
如果是先采样后模糊呢？结果是不行。
![](2020-03-27-14-40-02.png)

为什么?
为什么说采样的速度的跟不上信号变换的速度就会产生走样，  
为什么先去做采样，后做模糊操作达不到反走样效果  

为了解释为什么需要引入频率  
##### Frequency 频率：
![](2020-03-27-16-57-07.png)
最简单的正弦余弦波： 差别就是相位不一样。
![](2020-03-27-16-58-16.png)
通过调整系数，会得到不同的余弦波，它们的不同在于频率不同，这里我们定义一个事情，cos2pifx, f就是频率，f就可以定义频率变换有多快，周期就是频率的倒数。
为什么要介绍这些呢？
微积分里面傅里叶基数展开：任何一个周期函数，都可以写成一系列正弦和余弦函数的线性组合以及一个常数项  
![](2020-03-27-17-23-50.png)
![](2020-03-27-17-30-47.png)
所谓傅里叶变换，其实就是把函数给变成不同频率的段，并且把这些段显示出来。  
![](2020-03-27-17-38-16.png)
小例子，相同的采样频率，对应上不同的变化频率，采样结果反应实际的效果越差。  
由此我们可以看出来，采样的频率应该跟随被采样的频率变换。

![](2020-03-27-17-45-11.png)
如果同一个采样点，采样两种截然不同的函数，结果是一致的，像这样的情况就叫走样/混叠。
##### Filtering 滤波：
所谓滤波，就是去掉一系列特定的频率。  
傅里叶变换可以帮住我们理解这样事情。  
![](2020-03-27-17-50-02.png)

左边的图经过傅里叶变换可以变成右边这幅图。  
图像空间变成频率空间。  
频率空间怎么理解呢，中心我们把它理解为最低频的区域，边缘是最高频的区域。在不同频率上有多少信息我们用亮度表示，可以看出这幅图大多数信息集中在低频上。对于自然的图片一般都是这样的。为什么会有水平和竖直的道呢?简单说原因是我们在分析一个信号时会认为它是一个周期性重复信号，对于不周期重复的信号，我们认为它是Tiling的，那我们会发现，正常的图片的左右和上下是会发生剧烈变换的，就会产生一个极高的高频。  
图形的频率信息可以理解为图像相邻像素间色彩的变化。  
傅里叶变换能够可以让我看到任何图像（任何信号）在各个不同的频率上长什么样，也叫做频谱图。  

![](2020-03-27-18-07-23.png)
滤波就是去掉一些频率的内容。把低频去掉（就是把图像中变化缓慢的色块去掉）， 在反傅里叶变换，可以得到一张显示物体的边界的图片。  
这种滤波叫高通滤波（只有高频信息可以通过）。  
为什么说高频信息对应上人物边界上呢，因为边界就是信息变化剧烈的地方，  

![](2020-03-27-18-41-46.png)
把高频信息抹掉，只留下低频信息，在反傅里叶变换变回图片，可以得到一张模糊的图片  
这种滤波叫低通滤波（只有低频信息可以通过）。  
意味着边界被去掉了，模糊了。  

![](2020-03-27-18-46-37.png)
保留了某一段频段，我们就会得到这样的效果。  

![](2020-03-27-19-07-20.png)
滤波就去掉某一特定频率的信息。  
滤波又等于平均又等于卷积。  
![](2020-03-27-19-23-41.png)


##### Convolution 卷积：
![](2020-03-27-20-40-01.png)
![](2020-03-27-20-42-54.png)
什么是卷积？  
其实就是加权平均。  
所谓卷积是，在原始的信号附近取若干数用某一种滤波器的平均（图形学上简化的卷积）。  
![](2020-03-27-20-45-50.png)
时域的卷积等于频域的乘积。(这块没搞懂，但是好像不影响)  
例子：  
![](2020-03-27-20-54-51.png)
任何一个像素都是它周围3*3像素的平均  
拿到一幅图，先把它做傅里叶变换变成频域上的结果，3*3的卷积核也做傅里叶变换可以变成频域上，时域上做的卷积（上排乘起来），对应到频域上就是把两个信号乘起来，我们就发现大量的信息都变成黑的，只有中心一部分有信息，就像过了一个低通滤波。  
![](2020-03-27-21-05-48.png)
卷积核，3*3乘以1/9，不乘亮度就爆了。等于一个像素+旁边八个像素在除以9。我们管他叫低通滤波器。
![](2020-03-27-21-10-59.png)
![](2020-03-27-21-11-43.png)
如果这个box变大变小呢？
更大box做卷积操作，得到的结果越模糊，频域上的结果就超级小，更小的box，比像素还小，等于没做滤波，把所有频率都留下来了，


![](2020-03-28-13-58-00.png)
从频域的角度看采样。  
采样其实就是重复频率上的内容。  
![](2020-03-28-13-58-43.png)
时域的卷积等于频域的乘积
采样就是重复一个原始信号的频谱。
![](2020-03-28-14-02-32.png)
频谱上采样间隔越大，重复的频谱就越密，密到叠到一起就是走样。

##### Antialiasing 反走样：

![](2020-03-28-14-06-56.png)
做法：
1. 680*440分辨率的显示器光栅化一个三角形，一个像素非常大，那当然看起来锯齿很严重，如果视网膜显示屏分辨率很高，对应像素很小，意味着像素和像素的间隔小，意味着采样间隔小，意味着在频谱上，频谱的搬移间隔大不容易混叠到一起，所以走样小。但是受制于物理空间实际因素，不可能开启某个反走样的效果提高分辨率。
![](2020-03-28-14-12-40.png)
2. **先做模糊，后做采样。**对应到频率上来说，模糊就是低通滤波，去掉高频信号，在采样，就不会发生混叠了。

![](2020-03-28-14-14-13.png)
实际操作中，我们用什么滤波器来进行卷积操作呢？  
对应到三角形，我们怎么把三角形变成模糊三角形?  
用一个一定大小的低通滤波器对它进行卷积。  
![](2020-03-28-14-16-53.png)  
![](2020-03-28-14-47-15.png)
反走样的基本方法：
对原始的三角形做以像素大小为卷积核的操作，或者说求个平均，然后在做采样。
如图对于任何一个像素，就是这些情况。

一个三角形对它覆盖的每个像素求个平均，怎么才能把一个三角形在某一个像素里面覆盖的区域算出来？
一个近似的方法。
![](2020-03-28-15-25-24.png)
一个像素划分成4*4个点，算出近似覆盖率，
![](2020-03-28-15-27-12.png)
![](2020-03-28-15-29-41.png)
![](2020-03-28-15-29-04.png)
MSAA解决了对信号的模糊这一步操作，采样是隐含在里面的，MSAA 并没有提高分辨率，而是为了得到一个近似合理的覆盖率。
![](2020-03-28-15-33-24.png)
![](2020-03-28-15-33-27.png)
结果还是挺明显的。
![](2020-03-28-15-34-08.png)
没有免费的午餐，增大了计算量，工业界会使用不同排列的采样点，而且每个采样点会得到复用，所以实际上的计算量没有那么高。  
抗锯齿有很多种方法，最有代表的就是FXAA（图像后期处理）和 TAA（复用上一帧得到感应到结果）  
超分辨率：  
从低分辨率到高分辨率  
本质上还是 采样不足的问题，用深度学习猜出来。


## 第七节 

### 上节复习 

1. Rasterization 光栅化
2. 采样
3. 反走样
先采样后做模糊为什么是错的？先采样就是在频谱上进行搬移，产生混叠。再模糊等于对画面施加了一个低通滤波。

### Visibility/Occlusion 可见和遮蔽
##### Z-buffering
![](2020-03-28-16-33-48.png)
先绘制远的，再绘制近的，近的遮挡远的，就像油画绘制方式，这种算法叫做画家算法。  
怎么计算深度（先画哪个）其实挺难的，特别是互相覆盖的情况。   
![](2020-03-28-16-44-43.png)
为了解决这个问题，引入了Zbuffer算法（广泛采用）   
![](2020-03-28-16-46-31.png)  
对三角形不好排远近顺序，但是对像素排序好排序，每一个像素在这个像素内去记录所表示的几何最浅深度（离我们最近的距离）。   
为了完成深度缓存，通常的做法是，渲染结果图片的同时生成深度图（深度缓冲）。
然后我们利用深度缓存去处理遮挡关系。   

重要的说明，我们在变换中假设摄影机放在原点朝-Z看，所以Z越小离摄影机越远，越大离摄影机越近。  
为了方便ZBuff计算，现在我们重新定义Z越小离摄影机越近，Z越大越远。  
![](2020-03-28-17-17-22.png)
越近值越小，越黑，越大值越大，越白。
![](2020-03-28-17-18-44.png)

假如有一个像素，我先画了地板，后面又被物体覆盖了，那么在这个像素上，我们查看一下两个东西在这个点的深度，小的覆盖大的。并且更新右边深度图。  
每一个像素内记录最浅深度。  

![](2020-03-28-17-21-47.png)
深度缓存： 首先认为所有像素记录的深度都是无限远的，然后把一个个三角形以任意顺序做光栅化变成像素，再在任意三角形覆盖的任意像素的深度信息跟原有的zbuffer作比较，如果比它小，就更新这个像素的颜色和深度到图片和zbuffer上。

下面是伪代码。
```py
for t in [所有三角形列表]:#在所有三角形列表内循环
    for pixel in t:#在三角形的所有像素列表内循环
        if pixel.z < Zbuffer[pixel.xy]:#判断像素的深度信息是否小于zbuffer如果小于就更新 图片颜色 和zbuffer深度.
            framebuffer[x,y] =pixel.rgb
            Zbuffer[pixel.xy] = pixel.z 
        else:#否则啥也不干
            pass
```
![](2020-03-28-17-34-48.png)
例子：
一开始所有的像素对应的深度缓存，存的都无限大的数直（R）后面一个三角形的深度在5，5比无限大小，所以先画图像再更新Zbuffer,然后第二个三角形的深度对比进来，对比每一个像素的深度值，小的像素绘制然后更新，大的就不绘制不更新（5遮挡8），通过这种办法我们可以维护一个逐像素的深度缓存正确。最后我们会得到正确的图像和深度缓存。  
![](2020-03-28-18-55-28.png)
总结一下：  
画家算法，要花O(Nlog(N))。  
深度缓存算法，O(n) N=三角形个数。  
这里这里我们并没有排序所有像素，我们只是记录。等于对每个像素求一堆三角形里面的最小值。  

假设不会有两个三角形在同一个像素有完全一致的深度，那么如果先画紫色或者先画红色三角形，结果都是一致的。  
对于反走样的MSAA的方法,对于一个像素中间采样多个点，对于Zbuffer也要对每一个采样点求一个值。  

注：Zbruffer处理不了透明物体。  

### Shading 着色
为什么要学着色？
![](2020-03-30-10-28-01.png)  
![](2020-03-30-10-46-05.png)  
引入明暗和颜色。  
这门课里，对不同物体应用不同材质的过程叫做shading。  
##### 简单的反射（着色）模型
![](2020-03-30-10-50-38.png)
![](2020-03-30-10-52-21.png)
高光-漫反射-间接光照
把这三部分都分析表示出来，自然可以做出一种材质。使得它长得跟杯子很相似，在开始之前我们需要定义一些东西。  
![](2020-03-30-11-01-15.png)  
1. 表面方向：在一个小范围可以认为面是平面。面朝向的方向是法线n（表示方向用单位向量）。  
2. 观测方向：从shading point 往相机连一条线就是v（表示方向用单位向量）。  
3. 光源方向：动shading point 往光源连一条线就是I（表示方向用单位向量）。  
4. shading point这个点的本身物体表面属性：颜色，亮度等。  
![](2020-03-30-11-06-23.png)
Shading in Local:目前来说我们所说的着色，我们考虑只考虑这个点和其它我们定义的方向属性，但是先不考虑是否在阴影内，也不考虑其它物体是否存在。

##### Diffuse Item 漫反射的表示：
![](2020-03-30-11-11-37.png)
什么叫漫反射，有一根光线打到物体的某一个点上，会被均匀的反射到各个方向上就叫漫反射，我们把这个表诉出来就行。
![](2020-03-30-11-14-54.png)
Lambert's Cosine Law  
同样的光照到不同角度的物体上亮度为什么会不同，第一张图接受6根光线，第二张图表面旋转60度接受3根光线，通过观测可以推导出物体表面法线和光线来源的夹角可以决定物体表面有多亮。  
一个科学解释：首先要考虑光是能量，我们要看到的是这些物体接收了多少能量，接收能量当然跟面积有关，我们考虑shading point接受多少能量，指的是一个单位面积接收了多少能量。  
![](2020-03-30-16-28-30.png)
能力的衰减，光源在中心，根据能量守恒定律，小的球壳上必然每个点的能量很多，大的球壳，球壳表面积增加，必然每个点分担的能量变少。
那我们定义半径为一的球壳上一个点能量为I,那根据能量守恒我们可以算出来半径为r的一个点能量为I/r的平方。
![](2020-03-30-17-57-23.png)
结论  
1. 光线在传播过程中，如果考虑单位面积，在任何以为所能接收到能量，和光线传播的距离成平方反比，（对于任何一点，光线传播越长，单位面积上所接收到的能量衰减越多）  
2. 假设知道点光源，知道shading point离点光源有多远，我们就知道有多少能量传播到shading point ，又根据Lambert's Cosine Law 我们知道有多少光会被接收，到达和接收算出来那我们就可以得到diffuse的表示方法  
![](2020-03-31-10-20-54.png)

1. 点光源距离shading point 为2，我们知道点光源强度I知道r就可以算出来在shading point shang 到达了多少能量。  
2. 根据Lambert's, n点乘i可以得到余弦（为了避免得到没有物理意义的负数，光线从下面射到上面，这里用了一个max函数），知道了会接收多少能量。  
3. shading point为什么会有颜色，是因为它本身吸收了一定能量，然后反射出来是它不吸收的能量，也就是被看到的颜色，不同的点有不同的吸收率也就得到不同的颜色，这里我们定义了一个系数kd（表示diffuse），如果kd是1（灰度）就表示所有能量都被吸收了，没有能量被反射出去，如果是一个3维向量（rgb）就表示了颜色。  
4. 光线打到shading point 反射光是均匀的半球，所以从哪看都一样，所以跟v完全没关系。  

![](2020-03-31-10-46-05.png)

注：这是一个经验模型，并不是完全符合物理的模型。


## 第八节
##### 上节课复习
![](2020-03-31-11-34-08.png)
上节课学了Blinn -Phong着色模型，在一定的光照下，希望算清楚一个点是什么样的亮度。有什么样的颜色。分析了茶杯图片，着色分为漫反射项，高光项，和环境光项。
有两个事情再强调下：
1. 我们所谓的着色是在某一个shading point，要想得到一整张图要在很多地方应用很多次
2. lighting 的方向，是指从shading point 指向光源，从光源的位置减去shading point的位置在归一化变成的单位向量。


##### Specular Term 高光项的表示：
![](2020-03-31-22-57-12.png)
什么是高光: 平面比较光滑，接近镜面（如果是镜面就是根据入射角，法线很容易算出出射角如图V，如果是接近镜面就是在镜面反射的出射角附近如图R），如果能观察到高光那么观测角就在R接近，其他时间肯定看不到。
![](2020-03-31-23-05-19.png)
聪明的Blinn-Phong模型：  
当我的观察方向和镜面方式R接近的时候，其实就说明法线方向和所谓“半程向量”很接近。
求两个单位向量的角平分线，很简单，两个向量一加，根据平行四边形法则，加出来的方向一定在中心，在做一下归一会就是h了。  
h（半程向量）和n（法线）接近就说明V（观测方向）和R（反射方向）接近。  
这样的好处就是如果要判断我是否看的到高光只需要看n（法线）和h（半程向量）是否接近。  
（怎么样衡量两个向量是否接近，就看两个向量的点乘的结果是否接近1）

1. ks 表示镜面反射系数。
2. （I/r的平方）多少能量到达。
3. 这里为啥不考虑多少能量接收，因为blinn phone是一个经验模型
4. n和h点乘判断我的视角和高光有多接近，（为了避免得到没有物理意义的负数，光线从下面射到上面，这里用了一个max函数）
![](2020-03-31-23-36-28.png)
5. 指数P是因为点乘的容忍度太高，向量偏离很大点乘数还是很高，如图，如果直接拿来用的话高光范围太大到45度还能看到，给定一个指数可以控制曲线也就是控制高光范围比如系数64到15度的时候就没有高光了，blinn pong模型经常用到100-200.
![](2020-03-31-23-43-12.png)
列是镜面反射系数变换，行是系数变换。





环境光照的表示：

##### Illumination & Shading

##### Graphics Pipeline



